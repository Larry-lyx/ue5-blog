<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>接口 (Interface)</title>
    <url>/ue5-blog/2025/12/09/ProgrammingSkills/Interface/</url>
    <content><![CDATA[<h1 id="核心总结"><a href="#核心总结" class="headerlink" title="核心总结"></a>核心总结</h1><p>接口是游戏开发中“按功能归类”的核心手段，可突破类继承的层级限制，让不同类型的对象实现同一套功能逻辑；<br>在UE中结合<code>BlueprintNativeEvent</code>使用，既能保证功能统一，又能避免频繁类型转换(Cast)，提升代码效率与扩展性。</p>
<span id="more"></span>

<h1 id="为什么需要接口-Interface"><a href="#为什么需要接口-Interface" class="headerlink" title="为什么需要接口(Interface)"></a>为什么需要接口(Interface)</h1><p>按“对象类型”的继承体系（如EnemyBase→Enemy1、ItemBase→Collectible）能解决同类对象的复用问题，但无法满足“跨类型共享功能”的需求：<br>例如开发“鼠标指向目标高亮”功能时，敌人、收集物、地图出入口等完全不同的对象，都需要实现高亮逻辑——这些对象类型差异极大，无法通过继承复用代码，而接口正是解决这类问题的核心方案。</p>
<p>从调用方视角（如PlayerController），实现高亮功能无需知晓目标是“敌人”还是“收集物”，只需明确两个核心：</p>
<ol>
<li>目标是否支持高亮功能；</li>
<li>如何触发目标的高亮逻辑。</li>
</ol>
<p>接口的本质是功能约定：</p>
<ul>
<li>接口类仅声明功能（如<code>HighlightActor()</code>），不实现具体逻辑；</li>
<li>任意对象只要继承该接口，就必须实现对应的功能逻辑；</li>
<li>调用方只需针对接口编程，无需关注对象具体类型，且子类实现接口函数时，可直接使用自身的成员变量（如敌人的Mesh、收集物的Sprite）。</li>
</ul>
<h1 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Interface.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// UE接口必须用此宏声明（替代GENERATED_BODY）</span></span><br><span class="line"><span class="built_in">UINTERFACE</span>(MinimalAPI)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UHighlightInterface</span> : <span class="keyword">public</span> UInterface</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">GENERATED_BODY</span>()</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GAME_API</span> IHighlightInterface</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">UFUNCTION</span>(BlueprintNativeEvent)</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">HighlightActor</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Enemy.h</span></span><br><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GAME_API</span> AEnemy : <span class="keyword">public</span> IHighlightInterface</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">HighlightActor_Implementation</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Enemy.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AEnemy::HighlightActor_Implementation</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">GetMesh</span>()-&gt;<span class="built_in">SetRenderCustomDepth</span>(<span class="literal">true</span>);</span><br><span class="line">	Weapon-&gt;<span class="built_in">SetRenderCustomDepth</span>(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// PlayerController.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">APlayerController::HighlightActor</span><span class="params">(AActor* InActor)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">IsValid</span>(InActor) &amp;&amp; InActor-&gt;<span class="built_in">Implements</span>&lt;UHighlightInterface&gt;())</span><br><span class="line">	&#123;</span><br><span class="line">		IHighlightInterface::<span class="built_in">Execute_HighlightActor</span>(InActor);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h1><h2 id="使用BlueprintNativeEvent避免频繁Cast"><a href="#使用BlueprintNativeEvent避免频繁Cast" class="headerlink" title="使用BlueprintNativeEvent避免频繁Cast"></a>使用BlueprintNativeEvent避免频繁Cast</h2><p>Cast 操作会产生类型检查开销，尤其在高频调用（如每帧检测鼠标指向）时，直接用<code>Implements&lt;&gt;+Execute_</code>调用接口函数，效率远高于<code>Cast&lt;IHighlightInterface&gt;(InActor)</code>后调用函数。</p>
<h2 id="接口的继承特性"><a href="#接口的继承特性" class="headerlink" title="接口的继承特性"></a>接口的继承特性</h2><p>若父类实现了某接口，其子类会自动继承该接口（如 EnemyBase 实现 IHighlightInterface，Enemy1&#x2F;Enemy2 无需重复声明即可使用高亮功能）。</p>
]]></content>
      <categories>
        <category>ProgrammingSkills</category>
      </categories>
      <tags>
        <tag>Interface</tag>
      </tags>
  </entry>
  <entry>
    <title>类的继承 (Inheritance)</title>
    <url>/ue5-blog/2025/12/09/ProgrammingSkills/Inheritance/</url>
    <content><![CDATA[<h1 id="核心总结"><a href="#核心总结" class="headerlink" title="核心总结"></a>核心总结</h1><p>类的继承是游戏开发中实现代码复用、逻辑扩展的核心手段，其核心价值在于：</p>
<ul>
<li>通过基类统一抽象通用逻辑，子类定制差异化行为；</li>
<li>保证代码可维护性，尤其在C++&#x2F;蓝图混合开发中，需兼顾封装性与灵活扩展。</li>
</ul>
<span id="more"></span>

<h1 id="基类"><a href="#基类" class="headerlink" title="基类"></a>基类</h1><p>游戏开发中，为同类对象构建基类是提升开发效率的核心习惯，核心原因有二：</p>
<ol>
<li><strong>通用逻辑复用</strong>：大量游戏对象（如敌人、道具、技能）存在共性属性&#x2F;行为（如血量、受击逻辑、销毁逻辑），基类可集中封装这些通用逻辑，避免重复编码；</li>
<li><strong>批量扩展便捷</strong>：后续需为某类对象新增功能（如所有敌人添加“被击硬直”）时，只需修改基类，所有子类自动继承，无需逐个调整。</li>
</ol>
<p>在UE开发中，几乎所有自定义C++类都会配套创建<strong>蓝图基类</strong>，核心优势在于：</p>
<ul>
<li>配置灵活：无需硬编码&#x2F;重新编译，即可调整Mesh、数值参数（如敌人血量、技能冷却时间），快速验证效果；</li>
<li>轻量逻辑快速迭代：简单逻辑（如UI提示、音效触发）可直接在蓝图中实现，开发效率高，且非密集计算类逻辑几乎无性能损耗。</li>
</ul>
<p>但蓝图也有明确的使用边界：</p>
<ul>
<li>复杂逻辑易因节点布线混乱导致维护成本高；</li>
<li>版本控制中难以追踪蓝图的具体修改内容。<br>因此最佳实践是：蓝图仅处理“配置+极简逻辑”，复杂逻辑仍放在C++中实现。</li>
</ul>
<h1 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h1><p>丰富的功能实现依赖灵活的继承体系：子类可继承父类的变量&#x2F;函数，也可重写函数逻辑，极大提升代码扩展性。</p>
<h2 id="核心问题：为何要区分-public-protected-private-访问权限？"><a href="#核心问题：为何要区分-public-protected-private-访问权限？" class="headerlink" title="核心问题：为何要区分 public&#x2F;protected&#x2F;private 访问权限？"></a>核心问题：为何要区分 public&#x2F;protected&#x2F;private 访问权限？</h2><p>个人开发中，若类的规模小、仅自己维护，权限区分的影响不明显；但在团队协作或源码复用场景下，权限划分是“降低理解成本、避免逻辑混乱”的关键：</p>
<ul>
<li><strong>public</strong>：对外暴露的核心接口（如<code>GetHealth()</code>），使用者无需关注内部实现，直接调用即可；</li>
<li><strong>protected</strong>：仅子类可访问&#x2F;重写的逻辑（如<code>OnTakeDamage()</code>），保证子类可定制，又避免外部随意调用；</li>
<li><strong>private</strong>：父类纯内部逻辑（如辅助计算的临时变量），完全隐藏实现细节，防止意外篡改。</li>
</ul>
<p>因此，当类的逻辑逐渐复杂时，需梳理头文件：明确权限划分、添加注释说明接口用途，让使用者快速知晓“哪些可调用、哪些可重写、哪些不可触碰”，无需深挖实现细节。</p>
<h1 id="类与实例"><a href="#类与实例" class="headerlink" title="类与实例"></a>类与实例</h1><p>类是“模板”，实例是基于模板创建的“具体对象”：类中定义的非静态变量&#x2F;函数，会在每个实例中独立存在（如两个Enemy实例的血量、位置相互独立）。</p>
<h2 id="静态成员的适用场景"><a href="#静态成员的适用场景" class="headerlink" title="静态成员的适用场景"></a>静态成员的适用场景</h2><p>对无需区分实例的通用逻辑&#x2F;数据（如全局配置、工具函数），可添加<code>static</code>关键字绑定到类上，核心优势：</p>
<ol>
<li>性能优化：无需创建实例即可调用，减少内存占用；</li>
<li>逻辑统一：所有实例共享同一数据&#x2F;逻辑。</li>
</ol>
<h2 id="关键注意点"><a href="#关键注意点" class="headerlink" title="关键注意点"></a>关键注意点</h2><p>UE开发中需牢记：继承后的属性&#x2F;函数始终归属于“具体实例”，而非类本身。例如：</p>
<ul>
<li>为<code>Enemy1</code>实例绑定的受击回调，仅会响应该实例的受击事件；</li>
<li>修改<code>Enemy2</code>实例的血量，不会影响其他Enemy实例的状态。<br>即使IDE的自动提示已经十分完善，也需时刻明确“操作的是类模板还是实例对象”，避免因边界混淆导致逻辑错误。</li>
</ul>
]]></content>
      <categories>
        <category>ProgrammingSkills</category>
      </categories>
      <tags>
        <tag>Inheritance</tag>
      </tags>
  </entry>
  <entry>
    <title>函数库 (Library)</title>
    <url>/ue5-blog/2025/12/10/ProgrammingSkills/Library/</url>
    <content><![CDATA[<h1 id="核心总结"><a href="#核心总结" class="headerlink" title="核心总结"></a>核心总结</h1><p>自定义函数库是UE开发中解耦跨类通用逻辑、提升代码复用性的核心手段，通过封装静态通用函数，可避免重复编码、减少性能损耗（如频繁Cast），同时让跨模块&#x2F;无继承关系的类高效共享算法与工具逻辑。</p>
<span id="more"></span>

<h1 id="自定义函数库的优势"><a href="#自定义函数库的优势" class="headerlink" title="自定义函数库的优势"></a>自定义函数库的优势</h1><ol>
<li><strong>解耦跨类复用逻辑</strong>：许多通用算法（如位置计算、数据校验）的使用方无明显继承关系（如敌人召唤逻辑、战利品生成、弹道计算），函数库可作为“公共逻辑容器”，脱离类的继承层级限制；</li>
<li><strong>提升开发效率</strong>：将可复用逻辑（如角色周围随机位置生成）提前封装为通用函数，后续开发无需重复编写&#x2F;调试，直接调用即可；</li>
<li><strong>全局高效访问</strong>：函数库中的函数需声明为<code>static</code>（静态），无需创建类实例即可调用，兼顾全局访问性与性能；</li>
<li><strong>统一维护入口</strong>：通用逻辑集中管理，后续修改（如调整位置算法的精度）只需改函数库，所有调用方自动生效，降低维护成本。</li>
</ol>
<h1 id="自定义函数库的核心内容"><a href="#自定义函数库的核心内容" class="headerlink" title="自定义函数库的核心内容"></a>自定义函数库的核心内容</h1><h2 id="1-通用算法（通用化参数设计）"><a href="#1-通用算法（通用化参数设计）" class="headerlink" title="1. 通用算法（通用化参数设计）"></a>1. 通用算法（通用化参数设计）</h2><p>封装无业务耦合的纯算法逻辑，参数设计需足够通用，避免硬编码，适配多场景调用。</p>
<h3 id="2-轻量化类型转换（封装static-cast的Setter-Getter）"><a href="#2-轻量化类型转换（封装static-cast的Setter-Getter）" class="headerlink" title="2. 轻量化类型转换（封装static_cast的Setter&#x2F;Getter）"></a>2. 轻量化类型转换（封装static_cast的Setter&#x2F;Getter）</h3><p>UE中<code>Cast</code>操作（动态类型转换）性能开销大，需尽量避免；对于自定义扩展的框架类型（如GAS的<code>GameplayEffectContext</code>），可将<code>static_cast</code>封装到函数库，减少重复转换逻辑，提升调用效率。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UCustomAbilitySystemLibrary::SetIsBlockedHit</span><span class="params">(FGameplayEffectContextHandle&amp; EffectContextHandle, <span class="type">bool</span> bInIsBlockedHit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (FCustomGameplayEffectContext* CustomContext = <span class="built_in">static_cast</span>&lt;FCustomGameplayEffectContext*&gt;(EffectContextHandle.<span class="built_in">Get</span>()))</span><br><span class="line">	&#123;</span><br><span class="line">		CustomContext-&gt;<span class="built_in">SetBlockedHit</span>(bInIsBlockedHit);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="自定义函数库的关键规范"><a href="#自定义函数库的关键规范" class="headerlink" title="自定义函数库的关键规范"></a>自定义函数库的关键规范</h3><ol>
<li><strong>类继承要求</strong>：必须继承<code>UBlueprintFunctionLibrary</code>，否则无法作为全局函数库使用；</li>
<li><strong>函数声明规则</strong>：<ul>
<li>函数需为<code>static</code> + <code>UFUNCTION(BlueprintCallable)</code>，支持C++&#x2F;蓝图双端调用；</li>
<li>加<code>Category</code>分类，便于蓝图中搜索和管理；</li>
</ul>
</li>
<li><strong>参数设计原则</strong>：<ul>
<li>通用算法参数“按需开放”（如角度范围设默认值），适配多场景；</li>
<li>避免传入冗余参数，核心参数前置，可选参数后置并设默认值；</li>
</ul>
</li>
<li><strong>性能注意</strong>：<ul>
<li>函数库仅封装轻量逻辑（算法、类型转换），不存放状态变量；</li>
<li>避免在函数库中执行耗时操作（如加载资源、遍历大量数据）；</li>
</ul>
</li>
<li><strong>头文件循环引用提醒</strong>：<br>函数库中若直接引用其他类的头文件，这些被引用的类将无法反向包含函数库头文件（触发循环引用报错）。建议通过“前向声明”替代直接包含：仅在函数库头文件中对所需类做前向声明（如<code>class FCustomGameplayEffectContext;</code>），函数具体实现放在cpp文件中，且仅在cpp里包含对应类的头文件，避免循环引用问题。</li>
</ol>
]]></content>
      <categories>
        <category>ProgrammingSkills</category>
      </categories>
      <tags>
        <tag>Library</tag>
      </tags>
  </entry>
  <entry>
    <title>智能指针 (Pointer)</title>
    <url>/ue5-blog//2025/12/10/ProgrammingSkills-Pointer/</url>
    <content><![CDATA[<h1 id="核心总结"><a href="#核心总结" class="headerlink" title="核心总结"></a>核心总结</h1><p>UE中的智能指针是管理对象生命周期、避免裸指针风险的核心工具，分为适配引擎GC的UObject专属指针（TObjectPtr&#x2F;TWeakObjectPtr等）和管理非UObject的通用共享指针（TSharedPtr）；</p>
<p>在实际使用中，最常见的是TObjectPtr，但有时调用引擎内置的函数时可能需使用 &#x2F; 返回特定指针类型，需了解相关转换规则和其中异同。</p>
<span id="more"></span>

<h1 id="为什么使用智能指针"><a href="#为什么使用智能指针" class="headerlink" title="为什么使用智能指针"></a>为什么使用智能指针</h1><p>原生C++裸指针存在三大核心问题：</p>
<ol>
<li><strong>野指针风险</strong>：对象被销毁后，裸指针未置空，访问时导致程序崩溃；</li>
<li><strong>内存泄漏</strong>：UObject指针未被GC追踪，无引用时无法自动回收；</li>
<li><strong>GC兼容问题</strong>：裸指针无法被UE垃圾回收系统识别，易出现“对象误回收”或“内存泄漏”。</li>
</ol>
<p>智能指针的核心价值：</p>
<ul>
<li>自动管理指针生命周期，适配UE GC机制；</li>
<li>避免手动管理内存（new&#x2F;delete），减少人为失误；</li>
<li>区分“强引用&#x2F;弱引用”，灵活控制对象回收逻辑。</li>
</ul>
<h1 id="使用指南"><a href="#使用指南" class="headerlink" title="使用指南"></a>使用指南</h1><h2 id="TObjectPtr"><a href="#TObjectPtr" class="headerlink" title="TObjectPtr"></a>TObjectPtr</h2><p>适用于所有UObject子类实例指针（Actor&#x2F;Component&#x2F;Widget等），替代原生裸指针（UComponent* → TObjectPtr<UComponent>）。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明</span></span><br><span class="line">TObjectPtr&lt;UStaticMeshComponent&gt; MeshComp;</span><br><span class="line"><span class="comment">// 赋值</span></span><br><span class="line">MeshComp = <span class="built_in">CreateDefaultSubobject</span>&lt;UStaticMeshComponent&gt;(<span class="built_in">TEXT</span>(<span class="string">&quot;Mesh&quot;</span>));</span><br><span class="line"><span class="comment">// 访问：直接使用，无需额外解引用</span></span><br><span class="line"><span class="keyword">if</span> (MeshComp) &#123; MeshComp-&gt;<span class="built_in">SetVisibility</span>(<span class="literal">true</span>); &#125;</span><br></pre></td></tr></table></figure>

<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>无需手动释放，GC自动管理；支持与裸指针互转，完全兼容原有UObject逻辑。</p>
<h2 id="TWeakObjectPtr"><a href="#TWeakObjectPtr" class="headerlink" title="TWeakObjectPtr"></a>TWeakObjectPtr</h2><p>UObject弱引用指针，不阻止GC回收对象，仅“观察”对象是否存活。<br>适用于需引用对象但不希望阻止其回收（如UI引用场景Actor、技能引用目标Enemy）。<br>核心优点是<strong>多线程</strong>访问时安全，而TObjectPtr仅在主线程中使用，并未设计线程安全。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 主线程持有</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>()</span><br><span class="line">TObjectPtr&lt;AActor&gt; MyActor;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 多线程使用安全缓存弱引用</span></span><br><span class="line">TWeakObjectPtr&lt;AActor&gt; WeakActor = MyActor;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SomeThreadFunction</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (WeakActor.<span class="built_in">IsValid</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        AActor* ValidActor = WeakActor.<span class="built_in">Get</span>();</span><br><span class="line">        <span class="comment">// 线程安全读操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="TSharedPtr"><a href="#TSharedPtr" class="headerlink" title="TSharedPtr"></a>TSharedPtr</h2><p>通用共享指针，基于引用计数管理<strong>非UObject类型</strong>（原生C++类、结构体），自动释放内存。用于管理非UObject类型（如自定义数据结构、第三方库对象）。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">TSharedPtr&lt;FMyData&gt; Ptr = <span class="built_in">MakeShared</span>&lt;FMyData&gt;();</span><br><span class="line"></span><br><span class="line">TSharedPtr&lt;FMyData&gt; Ptr2 = Ptr; <span class="comment">// 引用计数+1</span></span><br><span class="line">Ptr.<span class="built_in">Reset</span>();                    <span class="comment">// 引用计数-1</span></span><br></pre></td></tr></table></figure>

<h2 id="TSubclassOf"><a href="#TSubclassOf" class="headerlink" title="TSubclassOf"></a>TSubclassOf</h2><p>类引用指针（而非实例指针），限制仅能指向指定类及其子类，编译期校验类型。<br>适用于动态生成Actor&#x2F;创建对象时指定类（如Spawn Actor、创建Component）。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明：仅允许指向AEnemy及其子类</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere)</span><br><span class="line">TSubclassOf&lt;AEnemy&gt; EnemyClass;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用：生成指定类的实例</span></span><br><span class="line">AEnemy* NewEnemy = <span class="built_in">GetWorld</span>()-&gt;<span class="built_in">SpawnActor</span>&lt;AEnemy&gt;(EnemyClass, SpawnLoc, FRotator::ZeroRotator);</span><br></pre></td></tr></table></figure>

<h2 id="Handle"><a href="#Handle" class="headerlink" title="Handle"></a>Handle</h2><p>很多时候，我们使用的数据类型都会有后缀Handle，使用Handle的作用如下：</p>
<ul>
<li>资源或数据的间接引用<br>Handle 通常不直接存储数据或资源本身，而是存储了对数据的引用标识符或指针，用来访问或操作真正的数据。这种间接引用方便管理。</li>
<li>异步和并发安全<br>Handle机制适合异步任务（例如异步加载、异步寻路等），请求方持有Handle可随时查询结果或取消请求，且Handle可防止直接访问未准备好的数据。</li>
<li>节省内存和降低开销<br>由于Handle只是轻量索引或ID，复制和传递成本低，适合频繁传递和存</li>
</ul>
<p>以上内容作为理解，实际使用的时候还是主要根据IDE的类型提示，灵活处理即可。</p>
<h3 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h3><p>存储的是类的UClass对象，非实例；蓝图中可通过下拉框选择子类，类型安全。</p>
<h2 id="指针转换-Get"><a href="#指针转换-Get" class="headerlink" title="指针转换 (.Get())"></a>指针转换 (.Get())</h2><ul>
<li><strong>作用</strong>：从智能指针中提取原生裸指针，适用于所有UE智能指针；</li>
<li><strong>注意</strong>：仅临时使用，不改变智能指针的生命周期，避免长期持有返回的裸指针。</li>
</ul>
]]></content>
      <categories>
        <category>ProgrammingSkills</category>
      </categories>
      <tags>
        <tag>Pointer</tag>
        <tag>Handle</tag>
      </tags>
  </entry>
  <entry>
    <title>委托 (Delegate)</title>
    <url>/ue5-blog/2025/12/09/ProgrammingSkills/Delegate/</url>
    <content><![CDATA[<h1 id="核心总结"><a href="#核心总结" class="headerlink" title="核心总结"></a>核心总结</h1><p>委托的核心价值可概括为两点：</p>
<ol>
<li><p><strong>解耦：</strong><br>发送方仅负责在合适时机广播事件，无需知晓接收方逻辑；接收方专注实现回调，无需关联发送方细节，双方独立扩展逻辑。</p>
</li>
<li><p><strong>异步：</strong><br>接收方无需预判事件触发时间，只需提前绑定回调函数，事件广播时自动执行，降低时机同步成本。</p>
</li>
</ol>
<span id="more"></span>

<h1 id="什么是委托-Delegate"><a href="#什么是委托-Delegate" class="headerlink" title="什么是委托(Delegate)"></a>什么是委托(Delegate)</h1><p>游戏系统中存在大量跨对象的交互事件——事件发起者执行某个行为后，其他对象需要对该行为做出响应。</p>
<p>以“子弹击中敌人”为例：子弹触发Overlap事件是行为发起端，若直接在子弹代码中修改敌人血量、硬直等属性，会导致代码扩展性极差（比如不同敌人有不同的减伤、免硬直等差异化逻辑）。核心问题在于：子弹无需知晓被击中对象的具体类型和响应逻辑，所有“受击后的处理”都应归属于被击中对象自身。</p>
<p>委托（Delegate）正是解决这类问题的核心机制，其本质是一套“事件通信管道”：</p>
<ul>
<li>事件发起者只需负责向“管道”发送消息，无需关心谁会接收、如何处理；</li>
<li>事件接收者提前将处理逻辑（回调函数）绑定到“管道”，当收到消息时自动执行逻辑。</li>
</ul>
<p>需明确委托机制的三个核心要素：</p>
<ol>
<li>委托事件（即“通信管道”）：需要定义在某个通用类中；</li>
<li>消息发送：事件发起方在合适的时机触发委托、广播消息；</li>
<li>回调绑定：事件接收方需在事件发生前，将处理函数绑定到委托上。</li>
</ol>
<p>这里的核心易错点是<strong>绑定时机</strong>：回调函数的绑定必须早于委托广播，否则接收方无法响应。即便在“自身向自身发消息”的场景中，代码层面仍需先定义回调逻辑、完成绑定，再执行委托广播——回调函数的代码书写顺序在前，实际执行却在收到消息后，这也是委托使用中易混淆的点。</p>
<h1 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// DelegateSender.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 动态多播委托（支持蓝图绑定）：需声明参数类型+参数名</span></span><br><span class="line"><span class="built_in">DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam</span>(FOnSingleParamEvent, int32, DamageValue); </span><br><span class="line"><span class="comment">// 2. 普通多播委托（仅C++可用）：只需参数类型，参数名用注释说明（提升可读性）</span></span><br><span class="line"><span class="built_in">DECLARE_MULTICAST_DELEGATE_TwoParams</span>(FOnTwoParamEvent, FVector, <span class="comment">/* HitLocation */</span>, AActor*, <span class="comment">/* HitActor */</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// MULTICAST表示有多个接受方，多个接收方都会自动执行回调</span></span><br><span class="line"><span class="comment">// 如果是单播委托，使用Execute进行触发</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 委托发送方类（示例：子弹类）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GAME_API</span> UDelegateSender : <span class="keyword">public</span> UObject</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 声明委托实例（供外部绑定回调）</span></span><br><span class="line">    FOnSingleParamEvent OnDamageEvent;       <span class="comment">// 单参数委托实例（如传递伤害值）</span></span><br><span class="line">    FOnTwoParamEvent OnHitEvent;             <span class="comment">// 双参数委托实例（如传递击中位置+击中对象）</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// DelegateSender.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 委托发送方：在事件触发时机广播委托（示例：子弹检测到击中时）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UDelegateSender::TriggerHitEvent</span><span class="params">(int32 Damage, FVector HitLoc, AActor* HitActor)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 广播委托：所有绑定的回调函数会自动执行</span></span><br><span class="line">    OnDamageEvent.<span class="built_in">Broadcast</span>(Damage);</span><br><span class="line">    OnHitEvent.<span class="built_in">Broadcast</span>(HitLoc, HitActor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// DelegateReceiver.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;DelegateReceiver.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;DelegateSender.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 委托接收方：绑定回调函数到发送方的委托（需在事件触发前完成绑定）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UDelegateReceiver::BindToDelegate</span><span class="params">(UDelegateSender* Sender)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!Sender) <span class="keyword">return</span>; <span class="comment">// 空指针校验</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方式1：绑定成员函数（最常用）</span></span><br><span class="line">    <span class="comment">// AddUObject：接收方为UObject子类时使用，自动处理生命周期（对象销毁时解绑）</span></span><br><span class="line">    Sender-&gt;OnDamageEvent.<span class="built_in">AddUObject</span>(<span class="keyword">this</span>, &amp;UDelegateReceiver::OnReceiveDamage);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方式2：绑定Lambda表达式（适合简单逻辑，无需单独写成员函数）</span></span><br><span class="line">    Sender-&gt;OnHitEvent.<span class="built_in">AddLambda</span>(</span><br><span class="line">        [<span class="keyword">this</span>](FVector HitLocation, AActor* HitActor) <span class="comment">// 捕获this以访问接收方成员</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 击中事件的回调逻辑</span></span><br><span class="line">            <span class="built_in">UE_LOG</span>(LogTemp, Log, <span class="built_in">TEXT</span>(<span class="string">&quot;击中位置：%s&quot;</span>), *HitLocation.<span class="built_in">ToString</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 委托回调函数（对应OnDamageEvent）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UDelegateReceiver::OnReceiveDamage</span><span class="params">(int32 DamageValue)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 接收方的处理逻辑</span></span><br><span class="line">    <span class="built_in">UE_LOG</span>(LogTemp, Log, <span class="built_in">TEXT</span>(<span class="string">&quot;收到伤害值：%d&quot;</span>), DamageValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="疑难解释"><a href="#疑难解释" class="headerlink" title="疑难解释"></a>疑难解释</h1><h2 id="1-委托的定义位置：并非必须绑定发送方"><a href="#1-委托的定义位置：并非必须绑定发送方" class="headerlink" title="1. 委托的定义位置：并非必须绑定发送方"></a>1. 委托的定义位置：并非必须绑定发送方</h2><p>委托的声明位置可灵活调整——既可以定义在事件发送方，也可以定义在接收方，但核心前提是：<strong>委托的广播方（实际触发者）必须能获取到委托所属类的实例</strong>。</p>
<p>这一点容易引发“解耦不彻底”的疑问：绑定回调时，接收方需要包含委托定义类的头文件，看似仍存在耦合。以子弹击中敌人的场景为例：若委托定义在子弹类（发送方），敌人需持有子弹指针才能绑定回调，这意味着“敌人必须知道触发伤害的具体类型”；即便委托定义在敌人类（接收方），子弹需知道敌人的类型才能广播委托——两种方式都违背“敌人无需知晓攻击来源、子弹无需知晓被击目标”的解耦原则（尤其当子弹&#x2F;敌人类型扩展后，代码修改成本会急剧增加）。</p>
<h2 id="2-解耦方案：委托归属于“通用基类”"><a href="#2-解耦方案：委托归属于“通用基类”" class="headerlink" title="2. 解耦方案：委托归属于“通用基类”"></a>2. 解耦方案：委托归属于“通用基类”</h2><p>为进一步解耦，实战中会将委托定义在<strong>通用基类</strong>中：</p>
<ul>
<li>发送方（如子弹）仅需依赖该通用基类，无需知晓具体接收方类型，只需在事件触发时调用基类的委托广播接口；</li>
<li>接收方（如不同类型的敌人、道具）继承该通用基类，重写&#x2F;绑定自定义回调函数，实现差异化的事件处理；</li>
<li>核心优势：发送方和接收方仅依赖“通用基类”，彼此完全隔离，新增子弹&#x2F;敌人类型时无需修改原有逻辑。</li>
</ul>
<p>需要注意的是，委托代表的通信管道是和<strong>实例</strong>同级的，一个实例代表一个单独的通信管道。</p>
<h2 id="3-场景适配：委托-vs-GAS的GE（GameplayEffect）"><a href="#3-场景适配：委托-vs-GAS的GE（GameplayEffect）" class="headerlink" title="3. 场景适配：委托 vs GAS的GE（GameplayEffect）"></a>3. 场景适配：委托 vs GAS的GE（GameplayEffect）</h2><p>子弹击中造成伤害、附加Debuff、击飞（Knockback）等战斗事件，看似可用委托实现，但这类事件的上下文（伤害数值、Debuff类型、击飞力度等）复杂且需支持扩展，纯委托方案会因参数膨胀、逻辑分散变得难以维护。</p>
<p>在GAS框架中，这类战斗事件更适合用 <strong>GE</strong> 处理：GE天然封装了属性修改、效果叠加、持续时间等战斗逻辑，且通过GameplayTag实现灵活的触发&#x2F;取消规则，比委托更贴合“技能-属性-状态”的联动需求。</p>
<p>而简单的多播委托更适配<strong>UI交互场景</strong>：比如角色属性（血量、蓝量）变化时更新UI、技能冷却完成时刷新按钮状态——此时可将委托定义在ASC中，所有UI组件绑定该委托，当属性&#x2F;状态变更时广播委托，UI组件自动更新显示，无需业务逻辑层关心具体UI实现。这也是GAS框架中ASC、AS的核心作用之一：作为“通用事件枢纽”，统一管理属性变更、技能状态等事件的广播与回调，兼顾解耦与扩展性。</p>
<h1 id="蓝图中的广播-Event-Dispatcher"><a href="#蓝图中的广播-Event-Dispatcher" class="headerlink" title="蓝图中的广播 Event Dispatcher"></a>蓝图中的广播 Event Dispatcher</h1><p>蓝图中使用广播很简单，仍然是三步：注册、广播、回调；<br><img src="/ue5-blog/2025/12/09/ProgrammingSkills/Delegate/image.png" alt="alt text"><br><img src="/ue5-blog/2025/12/09/ProgrammingSkills/Delegate/image1.png" alt="alt text"></p>
]]></content>
      <categories>
        <category>ProgrammingSkills</category>
      </categories>
      <tags>
        <tag>Delegate</tag>
      </tags>
  </entry>
  <entry>
    <title>反射系统 (Reflection)</title>
    <url>/ue5-blog/2025/12/09/ProgrammingSkills/Reflection/</url>
    <content><![CDATA[<h1 id="核心总结"><a href="#核心总结" class="headerlink" title="核心总结"></a>核心总结</h1><p>UE的反射系统是突破C++静态编译限制的核心机制，通过一系列宏为C++代码注入“运行时类型信息”，实现蓝图交互、序列化、编辑器可视化、属性自动同步等关键功能；<br>在实际应用中最需要的，就是熟悉一些常用的反射宏。</p>
<span id="more"></span>

<h1 id="为什么需要反射-Reflection"><a href="#为什么需要反射-Reflection" class="headerlink" title="为什么需要反射(Reflection)"></a>为什么需要反射(Reflection)</h1><p>原生C++是静态编译型语言，编译后丢失类、属性、函数的元信息，无法在运行时动态获取&#x2F;修改类的成员（比如无法通过字符串“Health”直接找到角色的血量变量）。</p>
<p>而游戏开发中，大量场景需要“运行时动态操作类成员”：</p>
<ul>
<li>蓝图要访问C++定义的血量、技能函数；</li>
<li>存档系统要自动序列化&#x2F;反序列化角色属性；</li>
<li>编辑器要可视化显示C++变量（如Mesh、数值参数）并支持实时修改；</li>
<li>GAS要动态遍历角色的Attribute属性，实现技能效果计算。</li>
</ul>
<p>UE的反射系统正是为解决这些问题而生：通过反射宏标记C++元素，让UE在编译时生成额外的“元信息表”，运行时可通过该表动态访问、修改类的成员，无需硬编码关联。</p>
<h1 id="UE中的反射宏"><a href="#UE中的反射宏" class="headerlink" title="UE中的反射宏"></a>UE中的反射宏</h1><h2 id="UCLASS"><a href="#UCLASS" class="headerlink" title="UCLASS"></a>UCLASS</h2><p>创建类时自动生成核心宏（<code>GENERATED_BODY()</code>），无需手动修改；</p>
<h2 id="UPROPERTY"><a href="#UPROPERTY" class="headerlink" title="UPROPERTY"></a>UPROPERTY</h2><ol>
<li><strong>编辑器权限</strong><ul>
<li><code>EditDefaultsOnly</code>：仅蓝图&#x2F;类的默认值面板可修改，场景实例不可改；</li>
<li><code>EditAnywhere</code>：蓝图默认值+场景实例面板均可修改。</li>
</ul>
</li>
<li><strong>蓝图权限</strong><ul>
<li><code>BlueprintReadOnly</code>：蓝图仅可读，不可修改；</li>
<li><code>BlueprintReadWrite</code>：蓝图可读写，仅在蓝图需操作该变量时使用。</li>
</ul>
</li>
<li><strong>分类管理</strong><ul>
<li><code>Category = &quot;父类 | 子类&quot;</code>：用<code>|</code>分割层级（如<code>Category = &quot;Enemy | Combat&quot;</code>），让编辑器面板属性归类更清晰。</li>
</ul>
</li>
<li><strong>委托专属</strong><ul>
<li><code>BlueprintAssignable</code>：蓝图可绑定委托回调；</li>
<li><code>BlueprintCallable</code>：蓝图可主动触发委托广播；</li>
<li>注：仅<code>DECLARE_DYNAMIC_*</code>系列动态委托支持上述关键字，原生委托（无DYNAMIC）无效。</li>
</ul>
</li>
<li><strong>存档序列化</strong><ul>
<li><code>SaveGame</code>：标记变量需纳入存档系统，读档时自动恢复值。</li>
</ul>
</li>
<li><strong>私有变量暴露</strong><ul>
<li><code>meta = (AllowPrivateAccess = &quot;true&quot;)</code>：private中的变量需加此元数据，才能被反射系统识别（蓝图&#x2F;编辑器可见）。</li>
</ul>
</li>
<li><strong>网络同步</strong></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基础同步：服务器修改后自动同步到客户端</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>(Replicated)</span><br><span class="line"><span class="type">float</span> CurrentHealth = <span class="number">100.0f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同步+回调：变量同步后触发指定函数（更新UI/逻辑）</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>(ReplicatedUsing=OnRep_HealthChanged)</span><br><span class="line"><span class="type">float</span> SyncHealth = <span class="number">100.0f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同步回调函数（必须加UFUNCTION()）</span></span><br><span class="line"><span class="built_in">UFUNCTION</span>()</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OnRep_HealthChanged</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 必须重写该函数完成同步注册</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UAttributeSet::GetLifetimeReplicatedProps</span><span class="params">(TArray&lt;FLifetimeProperty&gt;&amp; OutLifetimeProps)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Super::<span class="built_in">GetLifetimeReplicatedProps</span>(OutLifetimeProps);</span><br><span class="line">    <span class="comment">// 注册同步变量（COND_None=无条件同步，REPNOTIFY_Always=始终触发回调）</span></span><br><span class="line">    <span class="built_in">DOREPLIFETIME_CONDITION_NOTIFY</span>(UAttributeSet, Health, COND_None, REPNOTIFY_Always);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GAS属性同步回调</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UAttributeSet::OnRep_Health</span><span class="params">(<span class="type">const</span> FGameplayAttributeData&amp; OldHealth)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">GAMEPLAYATTRIBUTE_REPNOTIFY</span>(UAttributeSet, Health, OldHealth);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>关键注意点:</strong><br>空<code>UPROPERTY()</code>并非无意义：所有<code>UObject</code>子类指针（如<code>UComponent*</code>&#x2F;<code>AActor*</code>）必须添加，否则 UE 的 GC（垃圾回收）无法追踪指针，可能导致内存泄漏（无引用时不回收）或野指针（被误回收）。</p>
<h2 id="UFUNCTION"><a href="#UFUNCTION" class="headerlink" title="UFUNCTION"></a>UFUNCTION</h2><ol>
<li><strong>蓝图执行</strong></li>
</ol>
<ul>
<li><code>BlueprintCallable</code>：蓝图可调用，有执行引脚，可修改对象状态；</li>
<li><code>BlueprintPure</code>：蓝图可调用，无执行引脚，仅用于状态获取 &#x2F; 纯计算（不修改变量）。</li>
</ul>
<ol start="2">
<li><strong>蓝图实现 &#x2F; 扩展</strong></li>
</ol>
<ul>
<li><code>BlueprintImplementableEvent</code>：C++ 声明函数，蓝图中实现逻辑（无 C++ 实现体）；</li>
<li><code>BlueprintNativeEvent</code>：C++ 提供基础实现（函数名加<code>_Implementation</code>后缀），蓝图可重写扩展；调用时用<code>Execute_XXX()</code>。</li>
</ul>
<ol start="3">
<li><strong>网络同步</strong></li>
</ol>
<ul>
<li><code>NetMulticast</code>：服务器调用，所有客户端（含服务器）执行；需搭配<code>Reliable</code>（可靠传输）&#x2F;<code>Unreliable</code>（高频低优先级）；</li>
<li><code>Server</code>（客户端调、服务器执行）、<code>Client</code>（服务器调、客户端执行），需搭配<code>WithValidation</code>（参数验证）。</li>
</ul>
<ol start="4">
<li><strong>元数据扩展</strong></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// DefaultToSelf：参数默认值为自身；DisplayName：自定义蓝图节点名称</span></span><br><span class="line"><span class="built_in">UFUNCTION</span>(BlueprintCallable, meta=(DefaultToSelf=<span class="string">&quot;WorldContextObject&quot;</span>, DisplayName=<span class="string">&quot;自定义函数名&quot;</span>))</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CustomFunction</span><span class="params">(UObject* WorldContextObject)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="USTRUCT"><a href="#USTRUCT" class="headerlink" title="USTRUCT"></a>USTRUCT</h2><ul>
<li>BlueprintType ，标记自定义结构体，允许蓝图中声明该结构体变量、作为函数参数 &#x2F; 返回值；</li>
</ul>
]]></content>
      <categories>
        <category>ProgrammingSkills</category>
      </categories>
      <tags>
        <tag>Reflection</tag>
      </tags>
  </entry>
  <entry>
    <title>单例 (Singleton)</title>
    <url>/ue5-blog//2025/12/10/ProgrammingSkills/Singleton/</url>
    <content><![CDATA[<h1 id="核心总结"><a href="#核心总结" class="headerlink" title="核心总结"></a>核心总结</h1><p>单例的核心是确保类&#x2F;结构体在程序运行期间仅有<strong>一个全局实例</strong>，并提供统一的静态访问入口。<br>实际应用中，最常见的场景式采用原生C++单例实现GameplayTag的集中管理，避免多实例导致Tag重复注册、数值不一致，保证各个模块共享一套Tag。</p>
<span id="more"></span>

<h1 id="单例的使用场景"><a href="#单例的使用场景" class="headerlink" title="单例的使用场景"></a>单例的使用场景</h1><p>单例适用于“需全局统一访问、仅初始化一次”的场景：</p>
<ol>
<li><strong>全局常量&#x2F;配置管理</strong>：GameplayTag是游戏内通用标记（属性、技能、状态等），需全局唯一注册、跨模块共享，单例可确保所有模块使用同一套Tag，避免重复定义；</li>
<li><strong>全局状态管理</strong>：如游戏全局开关（音效、无敌模式）、跨场景共享的核心参数，单例保证状态唯一且修改可全局感知；</li>
<li><strong>全局服务类</strong>：如日志管理、网络请求封装，单例避免多实例导致的资源冲突（如重复创建网络连接）。</li>
</ol>
<h1 id="单例的构建和引用"><a href="#单例的构建和引用" class="headerlink" title="单例的构建和引用"></a>单例的构建和引用</h1><h2 id="1-单例的核心构建规则"><a href="#1-单例的核心构建规则" class="headerlink" title="1. 单例的核心构建规则"></a>1. 单例的核心构建规则</h2><h3 id="头文件（-h）设计：封闭实例-开放访问"><a href="#头文件（-h）设计：封闭实例-开放访问" class="headerlink" title="头文件（.h）设计：封闭实例+开放访问"></a>头文件（.h）设计：封闭实例+开放访问</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 核心：私有静态实例 + 公有静态Get方法，确保唯一实例 + 全局访问</span></span><br><span class="line"><span class="keyword">struct</span>  <span class="title class_">FCustomGameplayTags</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 全局访问入口：返回const引用，避免外部修改实例</span></span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">const</span> FCustomGameplayTags&amp; <span class="title">Get</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> GameplayTags;&#125;</span><br><span class="line">    <span class="comment">// 初始化方法：单独封装Tag注册逻辑，在游戏启动时执行</span></span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">InitializeNativeGameplayTags</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 需全局共享的GameplayTag变量</span></span><br><span class="line">    FGameplayTag Attributes_Primary_Strength;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 私有静态实例：仅类内可访问，避免外部创建多实例</span></span><br><span class="line">	<span class="type">static</span> FCustomGameplayTags GameplayTags;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="源文件（-cpp）实现：初始化实例-注册逻辑"><a href="#源文件（-cpp）实现：初始化实例-注册逻辑" class="headerlink" title="源文件（.cpp）实现：初始化实例+注册逻辑"></a>源文件（.cpp）实现：初始化实例+注册逻辑</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化静态实例（程序启动时创建，全局唯一）</span></span><br><span class="line">FCustomGameplayTags FCustomGameplayTags::GameplayTags;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 封装GameplayTag的注册逻辑，仅需执行一次</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FCustomGameplayTags::InitializeNativeGameplayTags</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 向UE引擎注册自定义Native GameplayTag，绑定标记名和说明</span></span><br><span class="line">	GameplayTags.Attributes_Primary_Strength = UGameplayTagsManager::<span class="built_in">Get</span>().<span class="built_in">AddNativeGameplayTag</span>(</span><br><span class="line">		<span class="built_in">FName</span>(<span class="string">&quot;Attributes.Primary.Strength&quot;</span>) ,</span><br><span class="line">		<span class="built_in">FString</span>(<span class="string">&quot;Increases physical damage&quot;</span>)</span><br><span class="line">	);</span><br><span class="line">	<span class="comment">// 可扩展：注册更多Tag</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-单例的全局引用方式"><a href="#2-单例的全局引用方式" class="headerlink" title="2. 单例的全局引用方式"></a>2. 单例的全局引用方式</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 任意模块/类中，通过Get()获取唯一实例，访问已注册的Tag</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AEnemy::CalculateDamage</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 全局访问单例中的Tag，无需创建FCustomGameplayTags实例</span></span><br><span class="line">    <span class="type">const</span> FGameplayTag StrengthTag = FCustomGameplayTags::<span class="built_in">Get</span>().Attributes_Primary_Strength;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ProgrammingSkills</category>
      </categories>
      <tags>
        <tag>Singleton</tag>
      </tags>
  </entry>
  <entry>
    <title>BehaviorTree Service</title>
    <url>/ue5-blog/2025/12/15/SystemDesigns/AI/BTService/</url>
    <content><![CDATA[<h1 id="核心总结"><a href="#核心总结" class="headerlink" title="核心总结"></a>核心总结</h1><p>BTService（BehaviorTree Service）是行为树中负责<strong>持续更新动态关键数据</strong>的服务节点，与BTTask形成核心分工：</p>
<ul>
<li>BTTask聚焦“执行具体任务”（如释放技能、移动），是Sequence节点下的动作单元；</li>
<li>BTService聚焦“数据供给”（如更新目标位置、计算敌我距离），挂载在Selector等决策节点上，为行为树的状态决策提供实时数据。</li>
</ul>
<span id="more"></span>

<h1 id="为什么要用BTService"><a href="#为什么要用BTService" class="headerlink" title="为什么要用BTService"></a>为什么要用BTService</h1><p>行为树的核心是“状态决策+动作执行”，其中BTTask承担“动作执行”的角色（表述AI当前的行为状态），而BTService的核心价值是<strong>持续感知并更新动态数据</strong>，解决行为树“决策依据”的问题：</p>
<ul>
<li>若无BTService，行为树无法实时获取关键数据（如目标位置变化、敌我距离），决策逻辑会脱离游戏实际状态；</li>
<li>BTService将数据更新逻辑与决策&#x2F;执行逻辑解耦，既保证数据更新的独立性，也让行为树结构更简洁。</li>
</ul>
<h1 id="BTService的使用"><a href="#BTService的使用" class="headerlink" title="BTService的使用"></a>BTService的使用</h1><p>BTService主要用于更新Blackboard中的动态数据（如角色追逐的目标位置、与目标的距离），其逻辑依赖Tick触发，但可通过配置避免高频Tick带来的性能损耗，核心逻辑建议在C++端实现（适配复杂计算场景）。</p>
<h2 id="1-自定义Tick频率"><a href="#1-自定义Tick频率" class="headerlink" title="1. 自定义Tick频率"></a>1. 自定义Tick频率</h2><p>BTService无需每帧Tick，可在行为树中使用BTService的Details面板中配置Tick参数：</p>
<ul>
<li><code>Interval</code>：基础Tick间隔（单位：秒），如设置为1.0则每1秒更新一次数据；</li>
<li><code>Random Deviation</code>：Tick间隔的随机偏差值，如设置为0.5则Tick间隔在0.5~1.5秒间随机，既降低性能开销，也让AI行为更自然。</li>
</ul>
<h2 id="2-C-端核心实现步骤"><a href="#2-C-端核心实现步骤" class="headerlink" title="2. C++端核心实现步骤"></a>2. C++端核心实现步骤</h2><p>BTService常需处理复杂计算（如查找全局最近敌人、范围目标筛选），核心逻辑建议封装在C++端，步骤如下：</p>
<h3 id="步骤1：自定义BTService类，重写核心Tick函数"><a href="#步骤1：自定义BTService类，重写核心Tick函数" class="headerlink" title="步骤1：自定义BTService类，重写核心Tick函数"></a>步骤1：自定义BTService类，重写核心Tick函数</h3><p>自定义类继承自<code>BTService_BlueprintBase</code>，重写<code>TickNode</code>函数（BTService的核心执行入口，按配置的频率触发）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">TickNode</span><span class="params">(UBehaviorTreeComponent&amp; OwnerComp, uint8* NodeMemory, <span class="type">float</span> DeltaSeconds)</span> <span class="keyword">override</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="步骤2：定义Blackboard键绑定变量"><a href="#步骤2：定义Blackboard键绑定变量" class="headerlink" title="步骤2：定义Blackboard键绑定变量"></a>步骤2：定义Blackboard键绑定变量</h3><p>声明<code>FBlackboardKeySelector</code>类型变量，用于绑定行为树的Blackboard键（在行为树编辑器中可选择对应键）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere , BlueprintReadOnly)</span><br><span class="line">FBlackboardKeySelector TargetToFollowSelector;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere , BlueprintReadOnly)</span><br><span class="line">FBlackboardKeySelector DistanceToTargetSelector;</span><br></pre></td></tr></table></figure>

<h3 id="步骤3：实现动态数据更新逻辑"><a href="#步骤3：实现动态数据更新逻辑" class="headerlink" title="步骤3：实现动态数据更新逻辑"></a>步骤3：实现动态数据更新逻辑</h3><p>以“获取最近敌人并更新Blackboard数据”为例，核心函数与逻辑如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 获取所有带指定标签的Actor（区分敌友，注意：该操作开销较大，需控制Tick频率）</span></span><br><span class="line">UGameplayStatics::<span class="built_in">GetAllActorsWithTag</span>(OwningPawn , TargetTag, ActorsWithTag);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 初始化距离变量（使用UE内置最大值作为初始值）</span></span><br><span class="line"><span class="type">float</span> ClosestDistance = TNumericLimits&lt;<span class="type">float</span>&gt;::<span class="built_in">Max</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 遍历Actor计算距离，筛选最近目标</span></span><br><span class="line">OwningPawn-&gt;<span class="built_in">GetDistanceTo</span>(Actor); <span class="comment">// 计算当前Pawn与目标Actor的直线距离</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 将结果写入Blackboard，供行为树决策使用</span></span><br><span class="line">UBTFunctionLibrary::<span class="built_in">SetBlackboardValueAsObject</span>(<span class="keyword">this</span> , TargetToFollowSelector , ClosestActor);</span><br><span class="line">UBTFunctionLibrary::<span class="built_in">SetBlackboardValueAsFloat</span>(<span class="keyword">this</span> , DistanceToTargetSelector , ClosestDistance);</span><br></pre></td></tr></table></figure>

<h3 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h3><p>BTService的核心目标是“更新Blackboard数据”，行为树的决策节点（如Selector、Decorator）会读取这些数据（如判断“与目标距离是否小于攻击范围”），进而决定后续执行的BTTask（如发起进攻、追击目标）。</p>
]]></content>
      <categories>
        <category>SystemDesigns</category>
        <category>AI</category>
      </categories>
      <tags>
        <tag>BehaviorTree</tag>
        <tag>BTService</tag>
      </tags>
  </entry>
  <entry>
    <title>行为树 (BehaviorTree)</title>
    <url>/ue5-blog/2025/12/15/SystemDesigns/AI/BehaviorTree/</url>
    <content><![CDATA[<h1 id="核心总结"><a href="#核心总结" class="headerlink" title="核心总结"></a>核心总结</h1><p>行为树（BehaviorTree，简称BT）是UE中构建AI行为逻辑的核心载体，通过Selector（条件选择）、Sequence（顺序执行）两类核心节点实现AI决策，依赖Blackboard（黑板）存储动态数据，结合Task（瞬时行为）、Service（持续数据查询）、Decorator（条件判断）节点分工协作；<br>通过自定义AI Controller完成BT与AI角色的绑定，所有AI控制权由服务端掌控，确保逻辑权威且无作弊风险。</p>
<span id="more"></span>

<h1 id="BehaviorTree-与-Blackboard"><a href="#BehaviorTree-与-Blackboard" class="headerlink" title="BehaviorTree 与 Blackboard"></a>BehaviorTree 与 Blackboard</h1><p>AI行为逻辑的核心可归纳为两类决策模式，由BT的核心节点承载：</p>
<ol>
<li>条件选择逻辑：仅当满足特定条件时触发对应行为，对应Selector节点；</li>
<li>顺序执行逻辑：按固定流程依次触发行为，对应Sequence节点。</li>
</ol>
<p>BT的决策依赖Blackboard存储动态数据（如目标位置、AI状态），二者强绑定：</p>
<ul>
<li>BT中的所有功能节点（Task&#x2F;Service&#x2F;Decorator）均可读写Blackboard数据；</li>
<li>Blackboard数据实时更新，保证AI行为根据场景变化动态调整，提升流畅度。</li>
</ul>
<h2 id="1-Task"><a href="#1-Task" class="headerlink" title="1. Task"></a>1. Task</h2><p>Task是AI的“瞬时行为单元”，仅在特定时机触发，核心作用是执行具体行为或修改Blackboard数据：</p>
<ul>
<li>内置Task：UE提供基础任务（如移动、等待），无需自定义逻辑；</li>
<li>自定义Task：封装复杂逻辑（如“满足条件时释放指定技能”），适配个性化需求；</li>
<li>特殊Task：环境查询系统（EQS）也以Task形式存在（RunEQSQuery节点），其核心结果是更新Blackboard中的位置数据，而非执行行为。</li>
</ul>
<h2 id="2-Service"><a href="#2-Service" class="headerlink" title="2. Service"></a>2. Service</h2><p>Service是AI的“持续数据查询单元”，核心目的是更新Blackboard动态数据，与Task的核心区别是触发方式：</p>
<ul>
<li>触发逻辑：基于Tick触发，可自定义Tick时间间隔（避免高频计算损耗性能）；</li>
<li>适用场景：处理复杂计算（如查找最近敌人、计算敌我距离），持续刷新Blackboard数据供BT决策使用。</li>
</ul>
<h2 id="3-Decorator"><a href="#3-Decorator" class="headerlink" title="3. Decorator"></a>3. Decorator</h2><p>Decorator是AI的“条件判断单元”，每帧触发，用于校验Blackboard数据是否满足行为执行条件，关键配置如下：</p>
<ul>
<li><p>Notify Observer（通知时机）：可选On Result Change（结果变化时）、On Value Change（值变化时）；<br>说明一下，二者的区别在于，Blackboard Key为float类型时，是Distance这个数据变化就触发还是Distance &lt; Limit这个判断变化才触发；</p>
</li>
<li><p>Observer aborts（中断规则）：可选self（中断自身）、both（双向中断）、None（不中断）、Lower Priority（中断低优先级节点）；<br>self : 仅中断 Decorator 所在的当前节点（自身），不影响其他节点。<br>Lower Priority : 中断当前节点<strong>更低优先级</strong>的所有节点；仅影响“同层级且优先级更低”的节点，不中断自身。<br>both : 同时包含「Self」和「Lower Priority」的逻辑。</p>
</li>
<li><p>数据匹配：根据Blackboard Key类型（float&#x2F;bool&#x2F;Object等），选择对应的Key Query规则完成条件判断。</p>
</li>
</ul>
<h1 id="AI-Controller"><a href="#AI-Controller" class="headerlink" title="AI Controller"></a>AI Controller</h1><p>AI Controller是BT与AI角色的核心桥梁，负责加载BT、初始化Blackboard，并掌控AI行为的执行权限（仅服务端可操作）。</p>
<h2 id="1-核心配置"><a href="#1-核心配置" class="headerlink" title="1. 核心配置"></a>1. 核心配置</h2><h3 id="步骤1：自定义AI-Controller（继承AAIController）"><a href="#步骤1：自定义AI-Controller（继承AAIController）" class="headerlink" title="步骤1：自定义AI Controller（继承AAIController）"></a>步骤1：自定义AI Controller（继承AAIController）</h3><p>需在构造函数中创建Blackboard和BehaviorTree组件，作为BT与Blackboard的载体：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ACustomAIController::<span class="built_in">ACustomAIController</span>()</span><br><span class="line">&#123;</span><br><span class="line">	Blackboard = <span class="built_in">CreateDefaultSubobject</span>&lt;UBlackboardComponent&gt;(<span class="string">&quot;BlackboardComponent&quot;</span>);</span><br><span class="line">	<span class="built_in">check</span>(Blackboard);</span><br><span class="line">	BehaviorTreeComponent = <span class="built_in">CreateDefaultSubobject</span>&lt;UBehaviorTreeComponent&gt;(<span class="string">&quot;BehaviorTreeComponent&quot;</span>);</span><br><span class="line">	<span class="built_in">check</span>(BehaviorTreeComponent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="步骤2：AI角色类绑定BT与AI-Controller"><a href="#步骤2：AI角色类绑定BT与AI-Controller" class="headerlink" title="步骤2：AI角色类绑定BT与AI Controller"></a>步骤2：AI角色类绑定BT与AI Controller</h3><p>在受AI控制的角色类（如敌人）中，声明BT和自定义AI Controller的引用：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UPROPERTY</span>(EditDefaultsOnly , Category = <span class="string">&quot;AI&quot;</span>)</span><br><span class="line">TObjectPtr&lt;UBehaviorTree&gt; BehaviorTree;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span>()</span><br><span class="line">TObjectPtr&lt;ACustomAIController&gt; CustomAIController;</span><br></pre></td></tr></table></figure>

<h3 id="步骤3：初始化BT与Blackboard"><a href="#步骤3：初始化BT与Blackboard" class="headerlink" title="步骤3：初始化BT与Blackboard"></a>步骤3：初始化BT与Blackboard</h3><p>重写<code>PossessedBy</code>函数（角色被Controller接管时触发），完成BT加载与Blackboard初始化，且仅在服务端执行（AI控制权专属服务端）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PossessedBy</span><span class="params">(AController* NewController)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ACustomEnemy::PossessedBy</span><span class="params">(AController* NewController)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Super::<span class="built_in">PossessedBy</span>(NewController);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">HasAuthority</span>()) <span class="keyword">return</span>; <span class="comment">// 仅服务端处理AI逻辑，避免客户端作弊</span></span><br><span class="line">	CustomAIController = <span class="built_in">Cast</span>&lt;ACustomAIController&gt;(NewController);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 初始化Blackboard并运行行为树</span></span><br><span class="line">	CustomAIController-&gt;<span class="built_in">GetBlackboardComponent</span>()-&gt;<span class="built_in">InitializeBlackboard</span>(*BehaviorTree-&gt;BlackboardAsset);</span><br><span class="line">	CustomAIController-&gt;<span class="built_in">RunBehaviorTree</span>(BehaviorTree);</span><br><span class="line">	<span class="comment">// 初始化Blackboard默认值</span></span><br><span class="line">	CustomAIController-&gt;<span class="built_in">GetBlackboardComponent</span>()-&gt;<span class="built_in">SetValueAsBool</span>(<span class="built_in">FName</span>(<span class="string">&quot;HitReacting&quot;</span>) , <span class="literal">false</span>);</span><br><span class="line">	CustomAIController-&gt;<span class="built_in">GetBlackboardComponent</span>()-&gt;<span class="built_in">SetValueAsBool</span>(<span class="built_in">FName</span>(<span class="string">&quot;RangedAttacker&quot;</span>) , CharacterClass != ECharacterClass::Warrior);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-动态修改Blackboard值"><a href="#2-动态修改Blackboard值" class="headerlink" title="2. 动态修改Blackboard值"></a>2. 动态修改Blackboard值</h2><p>AI状态变化时，需实时更新Blackboard数据;<br>检测行为变化的一种常见式是监听GameplayTag变化并回调修改，下面的例子以Debuff_Stun为例展开：</p>
<h3 id="步骤1：注册Tag变化回调"><a href="#步骤1：注册Tag变化回调" class="headerlink" title="步骤1：注册Tag变化回调"></a>步骤1：注册Tag变化回调</h3><p>在AI角色初始化时，监听ASC上特定Tag的新增&#x2F;移除事件：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ACustomEnemy::InitAbilityActorInfo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	AbilitySystemComponent-&gt;<span class="built_in">InitAbilityActorInfo</span>(<span class="keyword">this</span> , <span class="keyword">this</span>);</span><br><span class="line">	<span class="built_in">Cast</span>&lt;UCustomAbilitySystemComponent&gt;(AbilitySystemComponent)-&gt;<span class="built_in">AbilityActorInfoSet</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 监听眩晕Tag的变化，触发回调修改Blackboard</span></span><br><span class="line">	AbilitySystemComponent-&gt;<span class="built_in">RegisterGameplayTagEvent</span>(FCustomGameplayTags::<span class="built_in">Get</span>().Debuff_Stun , EGameplayTagEventType::NewOrRemoved).<span class="built_in">AddUObject</span>(<span class="keyword">this</span> , &amp;ACustomEnemy::StunTagChanged);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">HasAuthority</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">InitializeDefaultAttributes</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	OnASCRegistered.<span class="built_in">Broadcast</span>(AbilitySystemComponent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="步骤2：回调中修改Blackboard"><a href="#步骤2：回调中修改Blackboard" class="headerlink" title="步骤2：回调中修改Blackboard"></a>步骤2：回调中修改Blackboard</h3><p>根据Tag变化更新Blackboard的眩晕状态：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ACustomEnemy::StunTagChanged</span><span class="params">(<span class="type">const</span> FGameplayTag CallbackTag, int32 NewCount)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Super::<span class="built_in">StunTagChanged</span>(CallbackTag, NewCount);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (CustomAIController &amp;&amp; CustomAIController-&gt;<span class="built_in">GetBlackboardComponent</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		CustomAIController-&gt;<span class="built_in">GetBlackboardComponent</span>()-&gt;<span class="built_in">SetValueAsBool</span>(<span class="built_in">FName</span>(<span class="string">&quot;Stunned&quot;</span>) , bIsStunned);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>敌人（AI）：修改Blackboard让BT感知眩晕状态，调整行为（如停止攻击）；</li>
<li>玩家：无需修改Blackboard，仅停止移动即可，输入阻断通过AttributeSet（AS）添加BlockTag实现：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ACustomBaseCharacter::StunTagChanged</span><span class="params">(<span class="type">const</span> FGameplayTag CallbackTag, int32 NewCount)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	bIsStunned = NewCount &gt; <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">GetCharacterMovement</span>()-&gt;MaxWalkSpeed = bIsStunned ? <span class="number">0.f</span> : BaseWalkSpeed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="触发Tag变化的底层逻辑"><a href="#触发Tag变化的底层逻辑" class="headerlink" title="触发Tag变化的底层逻辑"></a>触发Tag变化的底层逻辑</h3><p>Debuff施加时，在AttributeSet中为目标ASC添加对应Tag，触发上述回调：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UCustomAttributeSet::HandleDebuff</span><span class="params">(<span class="type">const</span> FEffectProperties&amp; Props)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">const</span> FCustomGameplayTags GameplayTags = FCustomGameplayTags::<span class="built_in">Get</span>();</span><br><span class="line"></span><br><span class="line">    FGameplayEffectContextHandle EffectContext = Props.SourceASC-&gt;<span class="built_in">MakeEffectContext</span>();</span><br><span class="line">    UGameplayEffect* Effect = <span class="built_in">NewObject</span>&lt;UGameplayEffect&gt;(<span class="built_in">GetTransientPackage</span>() , <span class="built_in">FName</span>(DebuffName));</span><br><span class="line">	</span><br><span class="line">	<span class="type">const</span> FGameplayTag DebuffTag = GameplayTags.DamageTypesToDebuffs[DamageType];</span><br><span class="line">	FInheritedTagContainer TagContainer = <span class="built_in">FInheritedTagContainer</span>();</span><br><span class="line">	UTargetTagsGameplayEffectComponent&amp; Component = Effect-&gt;<span class="built_in">FindOrAddComponent</span>&lt;UTargetTagsGameplayEffectComponent&gt;();</span><br><span class="line">	TagContainer.Added.<span class="built_in">AddTag</span>(DebuffTag);</span><br><span class="line">	Component.<span class="built_in">SetAndApplyTargetTagChanges</span>(TagContainer);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (FGameplayEffectSpec* MutableSpec = <span class="keyword">new</span> <span class="built_in">FGameplayEffectSpec</span>(Effect , EffectContext , <span class="number">1.f</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		Props.TargetASC-&gt;<span class="built_in">ApplyGameplayEffectSpecToSelf</span>(*MutableSpec);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>SystemDesigns</category>
        <category>AI</category>
      </categories>
      <tags>
        <tag>BehaviorTree</tag>
        <tag>Blackboard</tag>
      </tags>
  </entry>
  <entry>
    <title>BehaviorTree Task</title>
    <url>/ue5-blog/2025/12/15/SystemDesigns/AI/BTTask/</url>
    <content><![CDATA[<h1 id="核心总结"><a href="#核心总结" class="headerlink" title="核心总结"></a>核心总结</h1><p>BTTask（BehaviorTree Task）是行为树（BehaviorTree）的核心执行单元，承担“指令落地”的核心职责：行为树仅负责AI状态逻辑的流转（如从“休息”切换为“进攻”），而具体的执行逻辑（如选定攻击目标、释放技能、移动走位）均封装在BTTask中，既保证行为树结构简洁，又实现执行逻辑的复用。</p>
<span id="more"></span>

<h1 id="为什么要用BTTask"><a href="#为什么要用BTTask" class="headerlink" title="为什么要用BTTask"></a>为什么要用BTTask</h1><p>行为树的核心价值是通过节点组合实现AI状态的可视化流转，但其本身不负责具体业务逻辑的处理——例如行为树仅判定“当前应进攻”，但“向谁进攻、用哪个技能进攻、如何移动到攻击位置”等细节，需由BTTask封装实现。</p>
<p>使用BTTask的核心优势：</p>
<ol>
<li>简化行为树结构：行为树仅保留状态决策逻辑，无需嵌套复杂执行代码，可读性与维护性更高；</li>
<li>逻辑复用：同一类执行逻辑（如“选定攻击目标”“释放远程技能”）可封装为通用BTTask，在不同行为树&#x2F;AI角色中复用；</li>
<li>调试便捷：执行逻辑与状态决策解耦，可单独调试BTTask的逻辑，定位问题更高效。</li>
</ol>
<h1 id="BTTask的使用"><a href="#BTTask的使用" class="headerlink" title="BTTask的使用"></a>BTTask的使用</h1><h2 id="1-BTTask的定义"><a href="#1-BTTask的定义" class="headerlink" title="1. BTTask的定义"></a>1. BTTask的定义</h2><p>BTTask的最终执行逻辑通常落地在蓝图中（便于调试表现、快速调整参数），C++端仅做基础封装与函数声明；蓝图类一般基于<code>BTTaskBlueprintBase</code>，或自定义的C++基类（继承自<code>BTTaskBlueprintBase</code>）。</p>
<h3 id="自定义C-基类的核心函数"><a href="#自定义C-基类的核心函数" class="headerlink" title="自定义C++基类的核心函数"></a>自定义C++基类的核心函数</h3><p>若基于自定义C++类实现BTTask，建议显式重写<code>ExecuteTask</code>函数（即使仅调用父类实现），便于清晰追溯函数调用关系：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> EBTNodeResult::Type <span class="title">ExecuteTask</span><span class="params">(UBehaviorTreeComponent&amp; OwnerComp, uint8* NodeMemory)</span> <span class="keyword">override</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="ExecuteTask的底层调用逻辑"><a href="#ExecuteTask的底层调用逻辑" class="headerlink" title="ExecuteTask的底层调用逻辑"></a>ExecuteTask的底层调用逻辑</h3><p><code>ExecuteTask</code>是BTTask的入口函数，但并非蓝图可直接重写的接口——父类<code>UBTTask_BlueprintBase</code>的<code>ExecuteTask</code>会完成前置检查，并将逻辑转发至蓝图可实现的接口：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">EBTNodeResult::Type <span class="title">UBTTask_BlueprintBase::ExecuteTask</span><span class="params">(UBehaviorTreeComponent&amp; OwnerComp, uint8* NodeMemory)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 检查任务是否有执行/ Tick 逻辑，无则直接返回失败</span></span><br><span class="line">	CurrentCallResult = (ReceiveExecuteImplementations != <span class="number">0</span> || ReceiveTickImplementations != <span class="number">0</span>) ? EBTNodeResult::InProgress : EBTNodeResult::Failed;</span><br><span class="line">	bIsAborting = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ReceiveExecuteImplementations != FBTNodeBPImplementationHelper::NoImplementation)</span><br><span class="line">	&#123;</span><br><span class="line">		bStoreFinishResult = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 优先调用AI专属接口 ReceiveExecuteAI</span></span><br><span class="line">		<span class="keyword">if</span> (AIOwner != <span class="literal">nullptr</span> &amp;&amp; (ReceiveExecuteImplementations &amp; FBTNodeBPImplementationHelper::AISpecific))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">ReceiveExecuteAI</span>(AIOwner, AIOwner-&gt;<span class="built_in">GetPawn</span>());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 通用接口 ReceiveExecute</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (ReceiveExecuteImplementations &amp; FBTNodeBPImplementationHelper::Generic)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">ReceiveExecute</span>(ActorOwner);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		bStoreFinishResult = <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> CurrentCallResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述逻辑中，<code>ReceiveExecuteAI</code>（AI角色专属）和<code>ReceiveExecute</code>（通用Actor）是蓝图可重写的核心接口，也是BTTask实际执行逻辑的载体。</p>
<h2 id="2-逻辑处理（蓝图端）"><a href="#2-逻辑处理（蓝图端）" class="headerlink" title="2. 逻辑处理（蓝图端）"></a>2. 逻辑处理（蓝图端）</h2><p>针对AI控制的角色，蓝图中需将核心逻辑写在<code>EventReceiveExecuteAI</code>中（该事件对应C++的<code>ReceiveExecuteAI</code>），事件引脚可直接获取<code>AIOwner</code>（AI控制器）和<code>ControlledPawn</code>（AI控制的角色Pawn），满足绝大多数AI逻辑需求。</p>
<h3 id="核心逻辑场景1：选定攻击目标"><a href="#核心逻辑场景1：选定攻击目标" class="headerlink" title="核心逻辑场景1：选定攻击目标"></a>核心逻辑场景1：选定攻击目标</h3><p>攻击目标通常存储在行为树绑定的BlackBoard（黑板）中，BTTask中获取黑板数据的关键技巧：</p>
<ol>
<li>在BTTask蓝图中自定义变量，类型选择<code>BlackBoardKeySelector</code>，并勾选变量旁的“眼睛标志”（使其在行为树中可见）；</li>
<li>在行为树中使用该BTTask时，将<code>BlackBoardKeySelector</code>关联到当前行为树绑定的BlackBoard中的目标Key；</li>
<li>通过<code>GetBlackBoardValueAsXXX</code>（如<code>GetBlackBoardValueAsActor</code>）将黑板Key转换为目标类型（如攻击目标Actor）。</li>
</ol>
<h3 id="核心逻辑场景2：选择并释放技能"><a href="#核心逻辑场景2：选择并释放技能" class="headerlink" title="核心逻辑场景2：选择并释放技能"></a>核心逻辑场景2：选择并释放技能</h3><p>若AI有多个技能可选，可在BTTask中完成技能筛选逻辑后，调用<code>TryActivateAbilitiesByTag</code>释放技能，核心步骤：</p>
<ol>
<li>通过<code>ControlledPawn</code>获取ASC（AbilitySystemComponent）——<code>TryActivateAbilitiesByTag</code>是ASC的成员函数；</li>
<li>准备技能对应的GameplayTag：需先通过<code>MakeGameplayTagContainerFromTag</code>将单个Tag转换为TagContainer（<code>TryActivateAbilitiesByTag</code>要求传入TagContainer）；</li>
<li>调用<code>TryActivateAbilitiesByTag</code>，传入TagContainer触发对应技能。</li>
</ol>
<h3 id="实用辅助函数（提升AI行为多样性）"><a href="#实用辅助函数（提升AI行为多样性）" class="headerlink" title="实用辅助函数（提升AI行为多样性）"></a>实用辅助函数（提升AI行为多样性）</h3><p>BTTask中可结合导航系统实现更灵活的AI行为，典型函数：</p>
<ul>
<li><code>GetRandomLocationinNavigableRadius</code>：在指定半径内获取可导航的随机位置（需场景中放置NavVolumes），支持指定原点、半径，自动避开障碍物；<br>应用场景：让AI随机走位输出，避免原地站桩；或实现“绕背攻击”——通过当前角色与目标的位置，计算目标背后的区域作为随机位置范围，让AI移动至该区域后攻击。</li>
</ul>
<h3 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h3><p>BTTask执行完成后，需通过<code>FinishExecute</code>函数返回执行结果（成功&#x2F;失败），行为树会根据结果执行后续节点逻辑（如失败则切换为“寻找目标”节点，成功则进入“冷却等待”节点）。</p>
]]></content>
      <categories>
        <category>SystemDesigns</category>
        <category>AI</category>
      </categories>
      <tags>
        <tag>BehaviorTree</tag>
        <tag>BTTask</tag>
      </tags>
  </entry>
  <entry>
    <title>游戏开发中的锁：以FScopedAbilityListLock为例</title>
    <url>/ue5-blog/2025/12/09/ProgrammingSkills/Lock/</url>
    <content><![CDATA[<h1 id="核心总结"><a href="#核心总结" class="headerlink" title="核心总结"></a>核心总结</h1><p>锁的作用是保护<strong>临界资源</strong>避免并发读写冲突，<code>FScopedAbilityListLock</code>是针对GAS中ActivatableAbilities的轻量级封装锁，只要遍历<code>GetActivatableAbilities()</code>,就需要申请锁进行保护。</p>
<span id="more"></span>

<h1 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UAbilitySystemComponent::ClearAbilityOfSlot</span><span class="params">(<span class="type">const</span> FGameplayTag&amp; Slot)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">FScopedAbilityListLock <span class="title">ActiveScopLock</span><span class="params">(*<span class="keyword">this</span>)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (FGameplayAbilitySpec&amp; Spec : <span class="built_in">GetActivatableAbilities</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">AbilityHasSlot</span>(&amp;Spec , Slot))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">ClearSlot</span>(&amp;Spec);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h1><p><code>GetActivatableAbilities()</code> 返回的技能列表在游戏运行中会被高频修改（如技能锁定、添加、冷却禁用等），若读取列表时被其他代码路径修改，会导致迭代器失效、程序崩溃，因此需通过锁保护该临界资源。</p>
<p>这一设计与操作系统中的互斥锁思想一致，但存在两点关键差异：</p>
<ol>
<li>此处使用的是“作用域锁”，会随作用域结束（如函数执行完毕）自动析构解锁，无需手动调用<code>Unlock()</code>；</li>
<li>列表遍历操作耗时极短，无“线程等待资源”场景，因此锁的底层采用自旋锁实现——让线程短暂自旋等待锁释放，而非执行休眠&#x2F;唤醒操作，兼顾效率与安全性。</li>
</ol>
]]></content>
      <categories>
        <category>ProgrammingSkills</category>
      </categories>
      <tags>
        <tag>Lock</tag>
      </tags>
  </entry>
  <entry>
    <title>GameplayAbility (GA)</title>
    <url>/ue5-blog//2025/12/11/GAS-GA/</url>
    <content><![CDATA[<h1 id="核心总结"><a href="#核心总结" class="headerlink" title="核心总结"></a>核心总结</h1><p>GameplayAbility（GA）是 GAS 框架中封装技能逻辑的核心单元，其运行依赖「GameplayAbilitySpec（技能规格）」与「GameplayAbilityInstance（技能实例）」的分工协作：Spec 负责技能的长期管理与配置（如装配位置、是否锁定等），Instance 负责技能单次激活的实际执行（如施法、伤害、特效）。<br>GA 的实现兼顾蓝图的灵活性（流程可视化、参数快速调整）与 C++ 的性能优势（通用逻辑封装），并通过内置的冷却&#x2F;消耗体系、Tag 状态管理，标准化技能的核心行为。</p>
<span id="more"></span>

<h1 id="Gameplay-Ability-Spec-与-Gameplay-Ability-Instance"><a href="#Gameplay-Ability-Spec-与-Gameplay-Ability-Instance" class="headerlink" title="Gameplay Ability Spec 与 Gameplay Ability Instance"></a>Gameplay Ability Spec 与 Gameplay Ability Instance</h1><p>在 GAS 框架中，Spec 与 Instance 是支撑 GA 运行的两大核心对象，二者分工明确，共同实现技能的“管理”与“执行”分离。</p>
<h2 id="核心概念区分"><a href="#核心概念区分" class="headerlink" title="核心概念区分"></a>核心概念区分</h2><h3 id="1-Gameplay-Ability-Spec：技能的“管理槽位”"><a href="#1-Gameplay-Ability-Spec：技能的“管理槽位”" class="headerlink" title="1. Gameplay Ability Spec：技能的“管理槽位”"></a>1. Gameplay Ability Spec：技能的“管理槽位”</h3><p>Spec 是 ASC（AbilitySystemComponent）对技能的核心管理对象，可类比为角色的“技能槽位”：</p>
<ul>
<li>核心职责：存储技能的基础配置（等级、冷却时长、资源消耗数值、释放所需 GameplayTag），管控技能的可用状态（是否可释放、是否冷却中、是否满足释放条件）；</li>
<li>生命周期：与“技能授予”绑定——ASC 授予技能时创建 Spec，移除技能时销毁 Spec，长期存在于 ASC 的技能列表中，不随技能释放&#x2F;结束而变化。</li>
</ul>
<h3 id="2-Gameplay-Ability-Instance：技能的“执行实例”"><a href="#2-Gameplay-Ability-Instance：技能的“执行实例”" class="headerlink" title="2. Gameplay Ability Instance：技能的“执行实例”"></a>2. Gameplay Ability Instance：技能的“执行实例”</h3><p>Instance 是 GA 的单次运行实例，可类比为“角色释放一次火球术的具体行为”：</p>
<ul>
<li>核心职责：执行技能的具体逻辑（播放动画、生成目标数据、施加伤害、播放视听特效），仅聚焦单次技能的生命周期；</li>
<li>生命周期：与“技能激活”绑定——每次激活技能（如点击释放），ASC 基于 Spec 创建 Instance；技能执行完毕（或被打断）后，Instance 立即销毁，多次释放同一技能会生成多个独立 Instance。</li>
</ul>
<h2 id="关键关系与特性"><a href="#关键关系与特性" class="headerlink" title="关键关系与特性"></a>关键关系与特性</h2><ol>
<li>一对多关联：一个 Spec（技能槽）可对应多个 Instance（多次释放）——例如火球术的 Spec 长期存在，每次点击释放都会基于该 Spec 生成新的 Instance，也可对同一 Instance 执行激活、暂停、打断等操作；</li>
<li>交互逻辑分工：<ul>
<li>Spec 面向 ASC：所有技能管理操作（修改等级、重置冷却、判断释放权限）均通过 ASC 作用于 Spec；</li>
<li>Instance 面向游戏世界：仅负责与场景&#x2F;角色的交互逻辑（生成特效、检测碰撞、施加 GE），无需感知 ASC 层面的管理规则。</li>
</ul>
</li>
</ol>
<h1 id="GA-的实现"><a href="#GA-的实现" class="headerlink" title="GA 的实现"></a>GA 的实现</h1><p>GA 的最终逻辑通常在蓝图中完成，核心原因是蓝图的可视化特性更适配技能开发的迭代需求，同时结合 C++ 封装高性能&#x2F;通用逻辑，形成“蓝图做流程、C++ 做底层”的分工模式：</p>
<h3 id="1-蓝图实现的核心优势"><a href="#1-蓝图实现的核心优势" class="headerlink" title="1. 蓝图实现的核心优势"></a>1. 蓝图实现的核心优势</h3><ul>
<li>流程可视化：清晰呈现技能从激活到结束的完整逻辑（如动画播放→目标获取→伤害施加→特效播放），便于调试与迭代；</li>
<li>参数灵活调整：技能等级、伤害数值、冷却时长等参数可直接在蓝图 ClassDefaults 中修改，无需重新编译代码。</li>
</ul>
<h3 id="2-GA-蓝图的核心执行步骤"><a href="#2-GA-蓝图的核心执行步骤" class="headerlink" title="2. GA 蓝图的核心执行步骤"></a>2. GA 蓝图的核心执行步骤</h3><p>技能逻辑通常包含四大核心环节，各环节可复用 GAS 生态组件：</p>
<ul>
<li>播放技能动画：绑定并播放角色施法蒙太奇，可通过 GameplayEvent 触发动画关键帧逻辑（如火球生成）；</li>
<li>获取目标数据：通过 AbilityTask（如 TargetDataUnderMouse）异步获取鼠标指向的目标，解耦通用数据获取逻辑；</li>
<li>施加伤害&#x2F;属性修改：制作并应用 GameplayEffect（GE），实现伤害、回血等属性数值变化；</li>
<li>播放视听效果：调用 GameplayCue（GC）实现粒子、音效、镜头震动等技能表现。</li>
</ul>
<h3 id="3-C-封装的场景"><a href="#3-C-封装的场景" class="headerlink" title="3. C++ 封装的场景"></a>3. C++ 封装的场景</h3><p>为保证性能和逻辑复用性，以下逻辑建议封装在 C++ 端：</p>
<ul>
<li>性能敏感逻辑：如多火球生成位置的批量计算、高频碰撞检测；</li>
<li>通用工具逻辑：如技能描述文本的格式化、跨技能复用的目标筛选规则；</li>
<li>底层数据交互：如技能与 UI 数据的绑定、网络同步的核心逻辑。</li>
</ul>
<h1 id="GA-的实例化"><a href="#GA-的实例化" class="headerlink" title="GA 的实例化"></a>GA 的实例化</h1><p>在 GA 的 ClassDefaults 中，「Instancing Policy（实例化策略）」决定了 Instance 的创建规则，需根据技能类型选择：</p>
<ul>
<li>Instance per Actor（推荐）：每个技能拥有者（Actor）仅创建一个 Instance，复用性高、性能开销低，适配绝大多数技能（如普攻、单体技能）；</li>
<li>Instance per Execution：每次激活技能都创建新 Instance，适配需同时运行多个实例的技能（如持续施法的范围技能）；</li>
<li>Non Instanced：不创建 Instance，仅通过 Spec 管理，适配无执行逻辑的被动技能。</li>
</ul>
<h3 id="关键注意点"><a href="#关键注意点" class="headerlink" title="关键注意点"></a>关键注意点</h3><p>技能执行完毕后<strong>必须手动调用 <code>EndAbility</code></strong>：若未调用，Instance 不会销毁，会导致技能槽被占用，无法再次激活该技能。需确保所有逻辑分支（如施法完成、被打断、目标丢失）最终都执行 <code>EndAbility</code>。</p>
<h1 id="Cooldown（冷却）和-Cost（消耗）"><a href="#Cooldown（冷却）和-Cost（消耗）" class="headerlink" title="Cooldown（冷却）和 Cost（消耗）"></a>Cooldown（冷却）和 Cost（消耗）</h1><p>GAS 已封装冷却与资源消耗的核心逻辑，无需手动实现，仅需配置对应的 GE 并关联到 GA 即可：</p>
<h3 id="配置步骤"><a href="#配置步骤" class="headerlink" title="配置步骤"></a>配置步骤</h3><ol>
<li>制作 GE_Cost（资源消耗）：<ul>
<li>类型：Instant（瞬时生效）；</li>
<li>配置 Modifier：修改资源属性（如法力值、怒气值），设置扣减数值（如每次释放消耗 20 法力）。</li>
</ul>
</li>
<li>制作 GE_Cooldown（冷却）：<ul>
<li>类型：Duration（持续生效）；</li>
<li>配置 Modifier：无需修改属性，仅设置持续时长（冷却时间）；</li>
<li>赋予 GrantedTags：添加冷却标识 Tag（如 GameplayCue.Cooldown.FireBolt），供 UI 识别并显示冷却进度。</li>
</ul>
</li>
<li>关联到 GA：在 GA 的 ClassDefaults 中，将 GE_Cost 和 GE_Cooldown 分别绑定到「Cost Gameplay Effects」和「Cooldown Gameplay Effects」。</li>
<li>提交消耗与冷却：在 GA 的 <code>EventActivateAbility</code> 后立即调用 <code>CommitAbility</code>——该函数会自动应用 GE_Cost 和 GE_Cooldown，若资源不足（如法力不够）或处于冷却中，会直接阻止技能激活。</li>
</ol>
<h1 id="Tags-管理"><a href="#Tags-管理" class="headerlink" title="Tags 管理"></a>Tags 管理</h1><p>GA 提供多维度的 Tag 配置能力，可灵活控制技能的激活、状态与交互逻辑：</p>
<table>
<thead>
<tr>
<th>Tag 类型</th>
<th>核心作用</th>
</tr>
</thead>
<tbody><tr>
<td>AssetTags</td>
<td>GA 自身的固定标识 Tag，不可动态修改，用于技能分类（如 Skill.Fire、Skill.Passive）；</td>
</tr>
<tr>
<td>Activation Owned Tags</td>
<td>技能激活时自动添加的 Tag，如添加「Input_Block」Tag 禁用玩家输入，避免同时释放多个技能；</td>
</tr>
<tr>
<td>Activation Blocked Tags</td>
<td>技能激活的阻断 Tag，如添加「State.Stun」Tag，角色眩晕时无法激活该技能；</td>
</tr>
<tr>
<td>Block Abilities With Tags</td>
<td>主动阻断其他技能的 Tag，如释放无敌技能时，阻断所有攻击技能的激活；</td>
</tr>
</tbody></table>
<h3 id="动态-Tag-管理（Spec-层面）"><a href="#动态-Tag-管理（Spec-层面）" class="headerlink" title="动态 Tag 管理（Spec 层面）"></a>动态 Tag 管理（Spec 层面）</h3><p>AbilitySpec 也支持动态 Tag 管理，核心用法是通过 <code>AbilitySpec.GetDynamicSpecSourceTags()</code> 获取&#x2F;修改动态 Tag，适配临时状态变化：</p>
<ul>
<li>场景1：装备脱落后，移除「Skill.Enabled.Sword」Tag，临时禁用剑术技能；</li>
<li>场景2：角色进入狂暴状态，添加「Skill.Buff.DamageUp」Tag，提升技能伤害。</li>
</ul>
<p>动态 Tag 仅作用于 Spec 生命周期，技能移除后自动失效，无需手动清理。</p>
]]></content>
      <categories>
        <category>SystemDesigns</category>
        <category>GAS</category>
      </categories>
      <tags>
        <tag>GAS</tag>
        <tag>GA</tag>
        <tag>GameplayAbilitySpec</tag>
      </tags>
  </entry>
  <entry>
    <title>AbilitySystemComponent (ASC)</title>
    <url>/ue5-blog/2025/12/12/SystemDesigns/GAS/AbilitySystemComponent/</url>
    <content><![CDATA[<h1 id="核心总结"><a href="#核心总结" class="headerlink" title="核心总结"></a>核心总结</h1><p>AbilitySystemComponent（ASC）是GAS框架的核心中枢，作为挂载在Actor&#x2F;Character上的“逻辑容器”，承接对象所有GAS相关能力与交互。GAS的核心逻辑（属性变更、效果施加、技能执行）均围绕ASC展开，所有交互遵循“ASC发起→ASC接收”的模式，是连接GE、GA、AttributeSet的核心桥梁。</p>
<span id="more"></span>

<h1 id="ASC-是什么"><a href="#ASC-是什么" class="headerlink" title="ASC 是什么"></a>ASC 是什么</h1><p>从GAS的核心逻辑视角，ASC是承载对象GAS能力的“逻辑核心”（Actor&#x2F;Character仅作为宿主，GAS层面无需关注其原生逻辑）——可将GAS需处理的所有对象，抽象为一个个独立的ASC实例。</p>
<p>每个ASC独立管理如下核心内容，构成GAS交互的基础：</p>
<h2 id="1-游戏效果（GameplayEffect，GE）：世界对ASC的作用载体"><a href="#1-游戏效果（GameplayEffect，GE）：世界对ASC的作用载体" class="headerlink" title="1. 游戏效果（GameplayEffect，GE）：世界对ASC的作用载体"></a>1. 游戏效果（GameplayEffect，GE）：世界对ASC的作用载体</h2><p>游戏世界中所有事件对当前ASC产生的影响，均通过挂载在该ASC上的GE实现；处理ASC对外部作用的反馈，核心是围绕GE的挂载、移除与响应展开。</p>
<h2 id="2-游戏技能（GameplayAbility，GA）：ASC对世界的作用载体"><a href="#2-游戏技能（GameplayAbility，GA）：ASC对世界的作用载体" class="headerlink" title="2. 游戏技能（GameplayAbility，GA）：ASC对世界的作用载体"></a>2. 游戏技能（GameplayAbility，GA）：ASC对世界的作用载体</h2><p>ASC对游戏世界产生的所有影响（如播放角色动画、生成带伤害GE的子弹），均依赖其拥有的GA实现。需注意：ASC管理的并非GA实例，而是Gameplay Ability Spec（技能规格）；关于Spec与Instance的区别见<a href="/ue5-blog/2025/12/11/GAS-GA/">此处</a>。</p>
<h2 id="3-补充：属性（Attribute）的管理"><a href="#3-补充：属性（Attribute）的管理" class="headerlink" title="3. 补充：属性（Attribute）的管理"></a>3. 补充：属性（Attribute）的管理</h2><p>属性用于描述对象的核心状态（如血量、蓝量、力量），虽可直接由ASC管理，但为逻辑解耦，通常单独通过AttributeSet封装；特殊属性（如玩家XP、技能点、属性点）可存储在PlayerState中，由ASC关联访问。</p>
<h2 id="ASC的核心交互逻辑"><a href="#ASC的核心交互逻辑" class="headerlink" title="ASC的核心交互逻辑"></a>ASC的核心交互逻辑</h2><p>GAS框架下所有交互均遵循“ASC发起→ASC接收”：</p>
<ol>
<li>发起方ASC通过自身拥有的GA触发对外作用；</li>
<li>GA执行过程中产生的各类影响（如伤害、视觉效果等），最终以GE的形式施加到目标ASC；</li>
<li>目标ASC接收GE后，修改自身Attribute，并触发配套的世界交互（如血量降低同步更新UI、触发死亡特效）。</li>
</ol>
<h1 id="ASC类提供的核心功能"><a href="#ASC类提供的核心功能" class="headerlink" title="ASC类提供的核心功能"></a>ASC类提供的核心功能</h1><h2 id="1-响应GE挂载：处理自身被施加GE后的逻辑"><a href="#1-响应GE挂载：处理自身被施加GE后的逻辑" class="headerlink" title="1. 响应GE挂载：处理自身被施加GE后的逻辑"></a>1. 响应GE挂载：处理自身被施加GE后的逻辑</h2><p>通过绑定ASC内置的<code>OnGameplayEffectAppliedDelegateToSelf</code>委托回调，可监听并处理GE施加到自身的逻辑。需注意：该委托仅在Server端生效（GE的核心生效逻辑均在Server执行），Client端需通过Server广播同步UI等视觉&#x2F;交互变化。</p>
<p>该委托回调会传入两个核心参数：<code>FGameplayEffectSpec</code>（GE的配置规格）、<code>FActiveGameplayEffectHandle</code>（GE实例的句柄），用于精准识别并处理对应的GE。</p>
<h2 id="2-管理GA：核心是管理Gameplay-Ability-Spec"><a href="#2-管理GA：核心是管理Gameplay-Ability-Spec" class="headerlink" title="2. 管理GA：核心是管理Gameplay Ability Spec"></a>2. 管理GA：核心是管理Gameplay Ability Spec</h2><p>ASC不直接与GA实例交互，所有GA相关操作均围绕Spec展开，核心能力包括：</p>
<h3 id="（1）Tag与Spec的关联管理"><a href="#（1）Tag与Spec的关联管理" class="headerlink" title="（1）Tag与Spec的关联管理"></a>（1）Tag与Spec的关联管理</h3><p>提供一系列工具函数，实现GameplayTag（Ability&#x2F;Status&#x2F;Input类标签）与Spec的绑定、查询与校验，例如：</p>
<ul>
<li><code>GetInputTagFromSpec</code>：从Spec中提取绑定的输入Tag；</li>
<li><code>AbilityHasSlot</code>：校验Spec是否绑定了指定技能槽位；</li>
<li><code>AssignSlotToAbility</code>：为Spec分配技能槽位。</li>
</ul>
<p>关键注意点：</p>
<ul>
<li>Spec的动态标签（如Status、Input Tag）：通过<code>Spec.GetDynamicSourceTags()</code>获取&#x2F;管理；</li>
<li>Spec的固定标签（如AbilityTag）：通过<code>Spec.Ability.Get()-&gt;GetAssetTags()</code>获取&#x2F;管理；</li>
<li>遍历已授予（granted）的技能Spec：调用<code>GetActivatableAbilities()</code>，返回值为Spec列表；<strong>遍历激活技能时必须加锁</strong>（如<code>FScopedAbilityListLock</code>），避免多线程冲突。</li>
</ul>
<h3 id="（2）授予新技能（Spec）"><a href="#（2）授予新技能（Spec）" class="headerlink" title="（2）授予新技能（Spec）"></a>（2）授予新技能（Spec）</h3><p>ASC的“技能槽”不仅包含UI可见技能，还涵盖所有已授予的技能；授予逻辑仅针对Spec，而非GA实例，核心步骤：</p>
<ol>
<li>创建新的Gameplay Ability Spec；</li>
<li>为Spec填充配置（如绑定Tag、设置等级、配置冷却）；</li>
<li>调用<code>GiveAbility(Spec)</code>完成授予（按需激活：<code>GiveAbilityAndActivateOnce(Spec)</code>会直接实例化并执行GA）；</li>
<li>向UI广播技能授予事件，同步界面展示，按需进行。</li>
</ol>
<h3 id="（3）处理技能输入响应"><a href="#（3）处理技能输入响应" class="headerlink" title="（3）处理技能输入响应"></a>（3）处理技能输入响应</h3><p>这是GA实例化（激活）的核心逻辑，ASC通过<code>AbilityInputTagPressed/Held/Released</code>等函数响应输入：</p>
<ul>
<li>职责边界：ASC仅负责触发GA的实例化&#x2F;激活，GA的结束逻辑由其自身控制；</li>
<li>输入习惯适配：通常在<code>AbilityInputTagHeld</code>中处理激活逻辑（绑定<code>ETriggerEvent::Triggered</code>，按下期间每帧触发），支持长按连续释放技能（需结合冷却&#x2F;激活状态判断）；</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UCustomAbilitySystemComponent::AbilityInputTagHeld</span><span class="params">(<span class="type">const</span> FGameplayTag&amp; InputTag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!InputTag.<span class="built_in">IsValid</span>()) <span class="keyword">return</span>;</span><br><span class="line">	<span class="function">FScopedAbilityListLock <span class="title">ActiveScopeLock</span><span class="params">(*<span class="keyword">this</span>)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (FGameplayAbilitySpec&amp; AbilitySpec : <span class="built_in">GetActivatableAbilities</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (AbilitySpec.<span class="built_in">GetDynamicSpecSourceTags</span>().<span class="built_in">HasTagExact</span>(InputTag))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">AbilitySpecInputPressed</span>(AbilitySpec);</span><br><span class="line">			<span class="keyword">if</span> (!AbilitySpec.<span class="built_in">IsActive</span>())</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">TryActivateAbility</span>(AbilitySpec.Handle);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>网络同步：输入事件发生在Client端，需同步到Server端以保证效果一致：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (AbilitySpec.<span class="built_in">IsActive</span>())</span><br><span class="line">&#123;</span><br><span class="line">    TArray&lt;UGameplayAbility*&gt; Instances = AbilitySpec.<span class="built_in">GetAbilityInstances</span>();</span><br><span class="line">    <span class="type">const</span> FGameplayAbilityActivationInfo&amp; ActivationInfo = Instances.<span class="built_in">Last</span>()-&gt;<span class="built_in">GetCurrentActivationInfoRef</span>();</span><br><span class="line">    FPredictionKey OriginalPredictionKey = ActivationInfo.<span class="built_in">GetActivationPredictionKey</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">InvokeReplicatedEvent</span>(EAbilityGenericReplicatedEvent::InputPressed , AbilitySpec.Handle , OriginalPredictionKey);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-处理属性变化"><a href="#3-处理属性变化" class="headerlink" title="3. 处理属性变化"></a>3. 处理属性变化</h2><p>属性变化的核心逻辑通常封装在AttributeSet中，ASC仅处理与技能强关联的属性变更场景：</p>
<ul>
<li>典型场景：角色等级提升解锁&#x2F;升级技能（需ASC执行技能授予&#x2F;更新Spec配置）；</li>
<li>实现方式：ASC通过<code>GetAvatarActor()</code>获取宿主对象，关联AttributeSet或PlayerState读取&#x2F;修改属性；</li>
<li>扩展方案：可通过GameplayEvent转发属性变化事件（详情见<a href="/ue5-blog/2025/12/12/GAS-GameplayEvent/">此处</a>查看）。</li>
</ul>
<h1 id="网络复制"><a href="#网络复制" class="headerlink" title="网络复制"></a>网络复制</h1><h2 id="Server与Client的职责"><a href="#Server与Client的职责" class="headerlink" title="Server与Client的职责"></a>Server与Client的职责</h2><p>为适配多人游戏，需明确ASC相关逻辑在Server&#x2F;Client的分工：</p>
<ul>
<li>Server端：执行核心逻辑（属性修改、技能授予、GE施加），保证数据权威；</li>
<li>Client端：仅处理UI同步、视觉反馈等非核心逻辑。</li>
</ul>
<p>设计范式：拆分“Server执行+Client广播”两套函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UCustomAbilitySystemComponent::ServerEquipAbility_Implementation</span><span class="params">(<span class="type">const</span> FGameplayTag&amp; AbilityTag,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                                    <span class="type">const</span> FGameplayTag&amp; Slot)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (FGameplayAbilitySpec* AbilitySpec = <span class="built_in">GetSpecFromAbilityTag</span>(AbilityTag))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// Server端修改Spec的核心逻辑</span></span><br><span class="line"></span><br><span class="line">		<span class="built_in">ClientEquipAbility</span>(AbilityTag , GameplayTags.Abilities_Status_Equipped , Slot , PrevSlot);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UCustomAbilitySystemComponent::ClientEquipAbility_Implementation</span><span class="params">(<span class="type">const</span> FGameplayTag&amp; AbilityTag, <span class="type">const</span> FGameplayTag&amp; Status,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                                    <span class="type">const</span> FGameplayTag&amp; Slot, <span class="type">const</span> FGameplayTag&amp; PreviousSlot)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	AbilityEquipped.<span class="built_in">Broadcast</span>(AbilityTag , Status , Slot , PreviousSlot);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">AbilitySpec.<span class="built_in">GetDynamicSpecSourceTags</span>().<span class="built_in">AddTag</span>(GameplayTags.Abilities_Status_Eligible);</span><br><span class="line"><span class="built_in">MarkAbilitySpecDirty</span>(AbilitySpec);</span><br><span class="line"><span class="comment">// 同步 “Spec 配置数据”，传递 Spec 的完整状态，用于保证配置一致。</span></span><br></pre></td></tr></table></figure>
<p>当手动修改了 AbilitySpec 的成员变量后（如设置目标、调整冷却），调用 MarkAbilitySpecDirty 可以立即生效这些更改，避免延迟或不同步状况。</p>
]]></content>
      <categories>
        <category>SystemDesigns</category>
        <category>GAS</category>
      </categories>
      <tags>
        <tag>GAS</tag>
        <tag>ASC</tag>
      </tags>
  </entry>
  <entry>
    <title>AttributeSet (AS)</title>
    <url>/ue5-blog//2025/12/12/GAS-AS/</url>
    <content><![CDATA[<h1 id="核心总结"><a href="#核心总结" class="headerlink" title="核心总结"></a>核心总结</h1><p>AttributeSet（AS）是GAS框架中统一管理角色属性的核心类，承担“属性存储+属性变化处理”两大核心职责：按属性特性划分存储策略（通用属性存AS、玩家特有属性存PlayerState），通过“普通属性+元属性”分层处理简单&#x2F;复杂属性修改逻辑，最终依托重写核心函数完成属性变化的标准化处理。</p>
<span id="more"></span>

<h1 id="定义属性"><a href="#定义属性" class="headerlink" title="定义属性"></a>定义属性</h1><h2 id="核心说明"><a href="#核心说明" class="headerlink" title="核心说明"></a>核心说明</h2><p>AS的属性存储与生命周期按角色类型和属性用途区分：</p>
<ol>
<li><strong>通用属性</strong>（血量、蓝量、力量等）：存放于AS中，适配所有角色（玩家&#x2F;敌人）；</li>
<li><strong>玩家特有属性</strong>（XP、属性点、技能点等）：存放于PlayerState（PS）中（敌人无此类属性）；</li>
<li><strong>AS挂载策略</strong>：<ul>
<li>玩家AS：挂载在PS中，死亡后可继承属性（满足存档&#x2F;持久化需求）；</li>
<li>敌人AS：挂载在角色类中，随角色创建实例化、销毁后自动释放。</li>
</ul>
</li>
</ol>
<h2 id="普通属性"><a href="#普通属性" class="headerlink" title="普通属性"></a>普通属性</h2><p>普通属性是角色长期持有的核心属性（如血量、力量），需网络复制保证多端数据一致，定义流程如下：</p>
<h3 id="1-封装属性访问器"><a href="#1-封装属性访问器" class="headerlink" title="1. 封装属性访问器"></a>1. 封装属性访问器</h3><p>通过自定义宏快速生成属性的Getter&#x2F;Setter&#x2F;Initter，避免重复编写访问逻辑：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ATTRIBUTE_ACCESSORS(ClassName, PropertyName) \</span></span><br><span class="line"><span class="meta">	GAMEPLAYATTRIBUTE_PROPERTY_GETTER(ClassName, PropertyName) \</span></span><br><span class="line"><span class="meta">	GAMEPLAYATTRIBUTE_VALUE_GETTER(PropertyName) \</span></span><br><span class="line"><span class="meta">	GAMEPLAYATTRIBUTE_VALUE_SETTER(PropertyName) \</span></span><br><span class="line"><span class="meta">	GAMEPLAYATTRIBUTE_VALUE_INITTER(PropertyName)</span></span><br></pre></td></tr></table></figure>

<h3 id="2-定义Tag-属性映射模板"><a href="#2-定义Tag-属性映射模板" class="headerlink" title="2. 定义Tag-属性映射模板"></a>2. 定义Tag-属性映射模板</h3><p>模板用于构建GameplayTag与属性的映射表，每个AS实例持有该映射，支持通过Tag快速定位属性：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">template&lt;class T&gt;</span><br><span class="line">using TStaticFuncPtr = TBaseStaticDelegateInstance&lt;T , FDefaultDelegateUserPolicy&gt;::FFuncPtr;</span><br></pre></td></tr></table></figure>

<h3 id="3-AS类核心定义（含网络复制）"><a href="#3-AS类核心定义（含网络复制）" class="headerlink" title="3. AS类核心定义（含网络复制）"></a>3. AS类核心定义（含网络复制）</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GAS_Custom_API</span> UCustomAttributeSet : <span class="keyword">public</span> UAttributeSet</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">GENERATED_BODY</span>()</span><br><span class="line">	</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 构造函数：初始化Tag与属性的映射关系</span></span><br><span class="line">	<span class="built_in">UCustomAttributeSet</span>();</span><br><span class="line">	<span class="comment">// Tag-属性映射表：通过Tag快速获取属性，避免硬编码</span></span><br><span class="line">	TMap&lt;FGameplayTag , TStaticFuncPtr&lt;<span class="built_in">FGameplayAttribute</span>()&gt;&gt; TagToAttribute;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写：注册需网络复制的属性</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">GetLifetimeReplicatedProps</span><span class="params">(TArray&lt;<span class="keyword">class</span> FLifetimeProperty&gt;&amp; OutLifetimeProps)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生命值属性：GAS标准数据类型，指定同步回调</span></span><br><span class="line">    <span class="built_in">UPROPERTY</span>(BlueprintReadOnly , ReplicatedUsing = OnRep_Health , Category = <span class="string">&quot;Vital Attributes&quot;</span>)</span><br><span class="line">	FGameplayAttributeData Health;</span><br><span class="line">	<span class="comment">// 生命值同步回调：Server属性变化后触发Client逻辑</span></span><br><span class="line">	<span class="built_in">UFUNCTION</span>()</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">OnRep_Health</span><span class="params">(<span class="type">const</span> FGameplayAttributeData&amp; OldHealth)</span> <span class="type">const</span></span>;</span><br><span class="line">	<span class="comment">// 生成生命值访问器（复用自定义宏）</span></span><br><span class="line">	<span class="built_in">ATTRIBUTE_ACCESSORS</span>(UCustomAttributeSet , Health);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数：绑定Tag与属性的映射</span></span><br><span class="line">UCustomAttributeSet::<span class="built_in">UCustomAttributeSet</span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">const</span> FCustomGameplayTags&amp; GameplayTags = FCustomGameplayTags::<span class="built_in">Get</span>();</span><br><span class="line">	TagToAttribute.<span class="built_in">Add</span>(GameplayTags.Attributes_Primary_Health , GetHealthAttribute);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册网络复制规则</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UCustomAttributeSet::GetLifetimeReplicatedProps</span><span class="params">(TArray&lt;<span class="keyword">class</span> FLifetimeProperty&gt;&amp; OutLifetimeProps)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Super::<span class="built_in">GetLifetimeReplicatedProps</span>(OutLifetimeProps);</span><br><span class="line">	<span class="comment">// COND_None：属性变化即同步；REPNOTIFY_Always：同步必触发回调</span></span><br><span class="line">	<span class="built_in">DOREPLIFETIME_CONDITION_NOTIFY</span>(UCustomAttributeSet , Health , COND_None , REPNOTIFY_Always);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 属性同步回调：处理Client端属性变化逻辑</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UCustomAttributeSet::OnRep_Health</span><span class="params">(<span class="type">const</span> FGameplayAttributeData&amp; OldHealth)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// GAS内置宏：触发属性变化全局回调（如UI更新、死亡判定）</span></span><br><span class="line">	<span class="built_in">GAMEPLAYATTRIBUTE_REPNOTIFY</span>(UCustomAttributeSet , Health , OldHealth);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="元属性（Meta-Attribute）"><a href="#元属性（Meta-Attribute）" class="headerlink" title="元属性（Meta Attribute）"></a>元属性（Meta Attribute）</h2><p>元属性是临时属性，仅用于复杂属性变化的过渡计算，无需网络复制（仅Server端处理）：</p>
<h3 id="1-元属性的必要性"><a href="#1-元属性的必要性" class="headerlink" title="1. 元属性的必要性"></a>1. 元属性的必要性</h3><p>GE对属性的作用常包含复杂逻辑（如伤害附带击退、Debuff），无法直接修改普通属性完成。通过元属性（如IncomingDamage）作为“过渡载体”：</p>
<ul>
<li>GE先计算最终效果值，修改元属性；</li>
<li>AS监听元属性变化，完成最终属性修改+附加效果（击退、Debuff）。</li>
</ul>
<h3 id="2-元属性定义方式"><a href="#2-元属性定义方式" class="headerlink" title="2. 元属性定义方式"></a>2. 元属性定义方式</h3><p>仅需声明属性（无网络复制），复用访问器宏即可：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UPROPERTY</span>(BlueprintReadOnly , Category = <span class="string">&quot;Meta Attributes&quot;</span>)</span><br><span class="line">FGameplayAttributeData IncomingDamage;</span><br><span class="line"><span class="built_in">ATTRIBUTE_ACCESSORS</span>(UCustomAttributeSet , IncomingDamage);</span><br></pre></td></tr></table></figure>

<h1 id="处理属性变化"><a href="#处理属性变化" class="headerlink" title="处理属性变化"></a>处理属性变化</h1><h2 id="基本方法"><a href="#基本方法" class="headerlink" title="基本方法"></a>基本方法</h2><p>核心是重写<code>PostGameplayEffectExecute</code>函数，按属性类型处理修改逻辑：简单属性仅做合法性校验，复杂属性调用自定义处理函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UCustomAttributeSet::PostGameplayEffectExecute</span><span class="params">(<span class="type">const</span> FGameplayEffectModCallbackData&amp; Data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Super::<span class="built_in">PostGameplayEffectExecute</span>(Data);</span><br><span class="line"></span><br><span class="line">	FEffectProperties Props;</span><br><span class="line">	<span class="built_in">SetEffectProperties</span>(Data , Props);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 角色已死亡则跳过属性处理</span></span><br><span class="line">	<span class="keyword">if</span> (Props.TargetCharacter-&gt;<span class="built_in">Implements</span>&lt;UCombatInterface&gt;() &amp;&amp; ICombatInterface::<span class="built_in">Execute_IsDead</span>(Props.TargetCharacter)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 简单属性：法力值范围校验</span></span><br><span class="line">	<span class="keyword">if</span> (Data.EvaluatedData.Attribute == <span class="built_in">GetManaAttribute</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">SetMana</span>(FMath::<span class="built_in">Clamp</span>(<span class="built_in">GetMana</span>() , <span class="number">0.f</span> , <span class="built_in">GetMaxMana</span>()));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 复杂属性：调用自定义伤害处理逻辑</span></span><br><span class="line">	<span class="keyword">if</span> (Data.EvaluatedData.Attribute == <span class="built_in">GetIncomingDamageAttribute</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">HandleIncomingDamage</span>(Props);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="属性变化后处理"><a href="#属性变化后处理" class="headerlink" title="属性变化后处理"></a>属性变化后处理</h3><p>重写<code>PostAttributeChange</code>可在属性最终修改后执行附加逻辑，例：满血状态下最大血量提升时自动补满当前血量（否则UI上看起来血量反而下降）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UCustomAttributeSet::PostAttributeChange</span><span class="params">(<span class="type">const</span> FGameplayAttribute&amp; Attribute, <span class="type">float</span> OldValue, <span class="type">float</span> NewValue)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Super::<span class="built_in">PostAttributeChange</span>(Attribute, OldValue, NewValue);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (Attribute == <span class="built_in">GetMaxHealthAttribute</span>() &amp;&amp; bTopOffHealth)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">SetHealth</span>(<span class="built_in">GetMaxHealth</span>());</span><br><span class="line">		bTopOffHealth = <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="自定义数据结构"><a href="#自定义数据结构" class="headerlink" title="自定义数据结构"></a>自定义数据结构</h2><p>从GE回调数据中提取核心信息封装为结构体，便于复用和代码整洁：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">USTRUCT</span>()</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">FEffectProperties</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line">	<span class="built_in">FEffectProperties</span>()&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// GE上下文句柄：存储施法者、目标、伤害类型等信息</span></span><br><span class="line">	FGameplayEffectContextHandle EffectContextHandle;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 源端（施法者）数据</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>()</span><br><span class="line">	UAbilitySystemComponent* SourceASC = <span class="literal">nullptr</span>;</span><br><span class="line">	<span class="built_in">UPROPERTY</span>()</span><br><span class="line">	AActor* SourceAvatarActor = <span class="literal">nullptr</span>;</span><br><span class="line">	<span class="built_in">UPROPERTY</span>()</span><br><span class="line">	AController* SourceController =	<span class="literal">nullptr</span>;</span><br><span class="line">	<span class="built_in">UPROPERTY</span>()</span><br><span class="line">	ACharacter* SourceCharacter = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 目标端（受击者）数据</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>()</span><br><span class="line">	UAbilitySystemComponent* TargetASC = <span class="literal">nullptr</span>;</span><br><span class="line">	<span class="built_in">UPROPERTY</span>()</span><br><span class="line">	AActor* TargetAvatarActor = <span class="literal">nullptr</span>;</span><br><span class="line">	<span class="built_in">UPROPERTY</span>()</span><br><span class="line">	AController* TargetController =	<span class="literal">nullptr</span>;</span><br><span class="line">	<span class="built_in">UPROPERTY</span>()</span><br><span class="line">	ACharacter* TargetCharacter = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 填充结构体数据：从GE回调中提取源/目标信息</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UCustomAttributeSet::SetEffectProperties</span><span class="params">(<span class="type">const</span> FGameplayEffectModCallbackData&amp; Data, FEffectProperties&amp; Props)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Props.EffectContextHandle = Data.EffectSpec.<span class="built_in">GetContext</span>();</span><br><span class="line">	Props.SourceASC = Props.EffectContextHandle.<span class="built_in">GetOriginalInstigatorAbilitySystemComponent</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 填充源端数据</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">IsValid</span>(Props.SourceASC) &amp;&amp; Props.SourceASC-&gt;AbilityActorInfo.<span class="built_in">IsValid</span>() &amp;&amp; Props.SourceASC-&gt;AbilityActorInfo-&gt;AvatarActor.<span class="built_in">IsValid</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		Props.SourceAvatarActor = Props.SourceASC-&gt;AbilityActorInfo-&gt;AvatarActor.<span class="built_in">Get</span>();</span><br><span class="line">		Props.SourceController = Props.SourceASC-&gt;AbilityActorInfo-&gt;PlayerController.<span class="built_in">Get</span>();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (Props.SourceController == <span class="literal">nullptr</span> &amp;&amp; Props.SourceAvatarActor != <span class="literal">nullptr</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (APawn* Pawn = <span class="built_in">Cast</span>&lt;APawn&gt;(Props.SourceAvatarActor))</span><br><span class="line">			&#123;</span><br><span class="line">				Props.SourceController = Pawn-&gt;<span class="built_in">GetController</span>();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (Props.SourceController)</span><br><span class="line">		&#123;</span><br><span class="line">			Props.SourceCharacter = <span class="built_in">Cast</span>&lt;ACharacter&gt;(Props.SourceController-&gt;<span class="built_in">GetPawn</span>());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 填充目标端数据</span></span><br><span class="line">	<span class="keyword">if</span> (Data.Target.AbilityActorInfo.<span class="built_in">IsValid</span>() &amp;&amp; Data.Target.AbilityActorInfo-&gt;AvatarActor.<span class="built_in">IsValid</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		Props.TargetAvatarActor = Data.Target.AbilityActorInfo-&gt;AvatarActor.<span class="built_in">Get</span>();</span><br><span class="line">		Props.TargetController = Data.Target.AbilityActorInfo-&gt;PlayerController.<span class="built_in">Get</span>();</span><br><span class="line">		Props.TargetCharacter = <span class="built_in">Cast</span>&lt;ACharacter&gt;(Props.TargetAvatarActor);</span><br><span class="line">		Props.TargetASC = UAbilitySystemBlueprintLibrary::<span class="built_in">GetAbilitySystemComponent</span>(Props.TargetAvatarActor);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="解耦操作"><a href="#解耦操作" class="headerlink" title="解耦操作"></a>解耦操作</h2><p>AS仅负责属性变化的分发，具体业务逻辑（如伤害、击退）解耦到FunctionLibrary中，保证AS职责单一：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UCustomAttributeSet::HandleIncomingDamage</span><span class="params">(<span class="type">const</span> FEffectProperties&amp; Props)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">const</span> <span class="type">float</span> LocalIncomingDamage = <span class="built_in">GetIncomingDamage</span>();</span><br><span class="line">	<span class="built_in">SetIncomingDamage</span>(<span class="number">0.f</span>); <span class="comment">// 重置元属性</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (LocalIncomingDamage &gt; <span class="number">0.f</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 1. 计算最终血量并校验范围</span></span><br><span class="line">		<span class="type">const</span> <span class="type">float</span> NewHealth = <span class="built_in">GetHealth</span>() - LocalIncomingDamage;</span><br><span class="line">		<span class="built_in">SetHealth</span>(FMath::<span class="built_in">Clamp</span>(NewHealth , <span class="number">0.f</span> , <span class="built_in">GetMaxHealth</span>()));</span><br><span class="line"></span><br><span class="line">		<span class="type">const</span> <span class="type">bool</span> bFatal = (NewHealth &lt;= <span class="number">0.f</span>);</span><br><span class="line">		<span class="keyword">if</span> (!bFatal)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// 2. 非致命伤害：触发受击反应（GA）</span></span><br><span class="line">			<span class="keyword">if</span> (Props.TargetCharacter-&gt;<span class="built_in">Implements</span>&lt;UCombatInterface&gt;() &amp;&amp; !ICombatInterface::<span class="built_in">Execute_IsBeingShocked</span>(Props.TargetCharacter))</span><br><span class="line">			&#123;</span><br><span class="line">				FGameplayTagContainer TagContainer;</span><br><span class="line">				TagContainer.<span class="built_in">AddTag</span>(FCustomGameplayTags::<span class="built_in">Get</span>().Effects_HitReact);</span><br><span class="line">				Props.TargetASC-&gt;<span class="built_in">TryActivateAbilitiesByTag</span>(TagContainer);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 3. 触发击退效果</span></span><br><span class="line">			<span class="type">const</span> FVector KnockbackForce = UCustomAbilitySystemLibrary::<span class="built_in">GetKnockbackForce</span>(Props.EffectContextHandle);</span><br><span class="line">			<span class="keyword">if</span> (!KnockbackForce.<span class="built_in">IsNearlyZero</span>(<span class="number">1.f</span>))</span><br><span class="line">			&#123;</span><br><span class="line">				Props.TargetCharacter-&gt;<span class="built_in">LaunchCharacter</span>(KnockbackForce , <span class="literal">true</span> , <span class="literal">true</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// 4. 致命伤害：触发死亡逻辑</span></span><br><span class="line">			ICombatInterface* CombatInterface = <span class="built_in">Cast</span>&lt;ICombatInterface&gt;(Props.TargetAvatarActor);</span><br><span class="line">			<span class="keyword">if</span> (CombatInterface)</span><br><span class="line">			&#123;</span><br><span class="line">				CombatInterface-&gt;<span class="built_in">Die</span>(UCustomAbilitySystemLibrary::<span class="built_in">GetDeathImpulse</span>(Props.EffectContextHandle));</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 5. 击杀奖励：发放经验</span></span><br><span class="line">			<span class="built_in">SendXPEvent</span>(Props);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 6. 显示伤害飘字（区分格挡/暴击）</span></span><br><span class="line">		<span class="type">const</span> <span class="type">bool</span> bBlockedHit = UCustomAbilitySystemLibrary::<span class="built_in">IsBlockedHit</span>(Props.EffectContextHandle);</span><br><span class="line">		<span class="type">const</span> <span class="type">bool</span> bCriticalHit = UCustomAbilitySystemLibrary::<span class="built_in">IsCriticalHit</span>(Props.EffectContextHandle);</span><br><span class="line">		<span class="built_in">ShowFloatingText</span>(Props , LocalIncomingDamage , bBlockedHit , bCriticalHit);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 7. 触发Debuff效果</span></span><br><span class="line">		<span class="keyword">if</span> (UCustomAbilitySystemLibrary::<span class="built_in">IsSuccessfulDebuff</span>(Props.EffectContextHandle))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">HandleDebuff</span>(Props);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注：HandleDebuff需结合自定义GE实现，详情见<a href="/ue5-blog/2025/12/12/GAS-GE">此处</a>。</p>
]]></content>
      <categories>
        <category>SystemDesigns</category>
        <category>GAS</category>
      </categories>
      <tags>
        <tag>GAS</tag>
        <tag>AS</tag>
      </tags>
  </entry>
  <entry>
    <title>Environment Query System (EQS)</title>
    <url>/ue5-blog/2025/12/15/SystemDesigns/AI/EQS/</url>
    <content><![CDATA[<h1 id="核心总结"><a href="#核心总结" class="headerlink" title="核心总结"></a>核心总结</h1><p>Environment Query System（EQS）是UE为AI设计的环境感知与位置查询系统，核心作用是让AI根据自定义条件（如视野可见、距离远近）筛选环境中的最优位置，解决AI“环境适配决策”问题（如远程AI避开障碍物找可攻击位置），使AI行为更贴合场景逻辑。</p>
<span id="more"></span>

<h1 id="EQS的核心功能"><a href="#EQS的核心功能" class="headerlink" title="EQS的核心功能"></a>EQS的核心功能</h1><p>提升AI“智能性”的关键是让其具备环境感知能力，EQS正是解决这一需求的核心工具：<br>典型场景：远程攻击型AI若走到规划位置后，发现攻击路径被障碍物阻挡，攻击会无效；通过EQS可在该位置执行一次环境查询，核心逻辑为：</p>
<ol>
<li>在AI周围生成一批候选位置；</li>
<li>过滤掉不满足条件的位置（如攻击路径被遮挡、超出射程）；</li>
<li>选择离原位置最近的有效位置让AI移动。<br>UE内置的EQS体系已封装上述核心逻辑，可快速实现环境查询。</li>
</ol>
<h1 id="EQS的使用（以远程AI找可攻击位置为例）"><a href="#EQS的使用（以远程AI找可攻击位置为例）" class="headerlink" title="EQS的使用（以远程AI找可攻击位置为例）"></a>EQS的使用（以远程AI找可攻击位置为例）</h1><h2 id="步骤1：创建EQS蓝图类并关联行为树"><a href="#步骤1：创建EQS蓝图类并关联行为树" class="headerlink" title="步骤1：创建EQS蓝图类并关联行为树"></a>步骤1：创建EQS蓝图类并关联行为树</h2><ol>
<li>新建继承自Environment Query的蓝图类，自定义查询规则；</li>
<li>在行为树（BT）中添加<code>RunEQSQuery</code>节点，选择该自定义EQS蓝图类作为查询模板。</li>
</ol>
<h2 id="步骤2：配置位置生成器"><a href="#步骤2：配置位置生成器" class="headerlink" title="步骤2：配置位置生成器"></a>步骤2：配置位置生成器</h2><p>在自定义EQS蓝图中，先选择位置生成器（定义候选位置范围），常用类型：</p>
<ul>
<li>Pathing Grid：基于导航网格生成候选位置；</li>
<li>Circle：以AI为圆心，按半径生成圆形范围内的候选位置；<br>根据场景调整生成器参数，确定所有待筛选的候选位置。</li>
</ul>
<h2 id="步骤3：添加测试规则（筛选-排序）"><a href="#步骤3：添加测试规则（筛选-排序）" class="headerlink" title="步骤3：添加测试规则（筛选+排序）"></a>步骤3：添加测试规则（筛选+排序）</h2><p>在位置生成器下添加Test节点，分两步实现“筛选有效位置+排序选最优”：</p>
<h3 id="测试1：筛选可攻击（可见）的位置"><a href="#测试1：筛选可攻击（可见）的位置" class="headerlink" title="测试1：筛选可攻击（可见）的位置"></a>测试1：筛选可攻击（可见）的位置</h3><ul>
<li>选择Trace类型测试，模式设为Filter Only（仅过滤不满足条件的位置）；</li>
<li>选择检测通道（通常为Visibility，也可自定义），用于判断攻击路径是否被障碍物阻挡；</li>
<li>自定义Context（追踪目标）：默认Context为EQS发起者（AI自身），需新建继承自<code>EnvQueryContextBlueprintBase</code>的蓝图类，重写<code>Provide Actors Set</code>&#x2F;<code>Provide Locations Set</code>&#x2F;<code>Provide Single Actor</code>&#x2F;<code>Provide Single Location</code>其中一个函数，获取攻击目标（可通过<code>Get All Actors Of Class</code>获取指定类型Actor，注意：该函数在同类型对象较多时性能开销较大）。</li>
</ul>
<h3 id="测试2：排序获取最近位置"><a href="#测试2：排序获取最近位置" class="headerlink" title="测试2：排序获取最近位置"></a>测试2：排序获取最近位置</h3><ul>
<li>选择Distance测试，模式设为Score Only（仅打分排序）；</li>
<li>Distance To选择EnvQueryContext_Querier（EQS发起者，即AI自身），确保优先选择离AI当前位置最近的有效位置；</li>
<li>调整Scoring Factor为-1（倒序打分），让距离越近的位置得分越高。</li>
</ul>
<h2 id="步骤4：行为树中调用EQS"><a href="#步骤4：行为树中调用EQS" class="headerlink" title="步骤4：行为树中调用EQS"></a>步骤4：行为树中调用EQS</h2><p>在BT的<code>RunEQSQuery</code>节点中配置：</p>
<ul>
<li>RunMode选择Single Best Item（仅返回得分最高的最优位置）；</li>
<li>绑定Blackboard中的位置类Key，将查询得到的最优位置写入该Key，用于更新AI的移动目标。</li>
</ul>
<h1 id="疑难解决：自身Mesh遮挡导致当前位置被过滤"><a href="#疑难解决：自身Mesh遮挡导致当前位置被过滤" class="headerlink" title="疑难解决：自身Mesh遮挡导致当前位置被过滤"></a>疑难解决：自身Mesh遮挡导致当前位置被过滤</h1><p>问题：AI自身Mesh会遮挡Visibility通道，导致“原地不动”的候选位置被判定为无效，AI无故走位。<br>解决方案：</p>
<ol>
<li>位置生成器中设置Vertical Offset（垂直偏移量），让候选位置在Z轴有小幅偏移，避开自身Mesh遮挡；</li>
<li>新增“到目标距离”打分维度：添加Distance测试并设置较小的分数权重，使相同距离下，AI优先向目标方向移动——即便当前位置被过滤，AI也是向目标走一小步，并没有逻辑上的怪异，避免无意义的横向走位，保证行为自然。</li>
</ol>
]]></content>
      <categories>
        <category>SystemDesigns</category>
        <category>AI</category>
      </categories>
      <tags>
        <tag>EQS</tag>
      </tags>
  </entry>
  <entry>
    <title>GameplayEffect (GE)</title>
    <url>/ue5-blog//2025/12/12/GAS-GE/</url>
    <content><![CDATA[<h1 id="核心总结"><a href="#核心总结" class="headerlink" title="核心总结"></a>核心总结</h1><p>GameplayEffect（GE）是GAS框架中实现属性修改、传递附加效果信息的核心载体，其核心逻辑围绕“数值计算+信息传递+效果生效”展开：</p>
<ol>
<li><strong>核心功能</strong>：一方面通过硬编码、SetByCaller、Execution Class、MMC等不同复杂度的方式计算属性修改值（如伤害值）；另一方面通过自定义Context或Tag传递暴击、格挡、击退、Debuff等附加效果信息，最终在AttributeSet（AS）中完成这些附加效果的落地。</li>
<li><strong>实战核心流程（伤害类GE）</strong>：先将攻击方参数封装到<code>FDamageEffectParams</code>结构体，再基于该结构体填充自定义Context、构建GameplayEffectSpec（通过SetByCaller传递动态数值），接着通过Execution Class捕获源&#x2F;目标双方属性（如防御、抗性）完成复杂伤害计算（含范围伤害、Debuff概率判定），最后将GE挂载到目标ASC；Debuff作为伤害GE的附加效果，会在AS中检测到Context标记后动态创建专用GE并生效。</li>
<li><strong>关键技术要点</strong>：自定义Context需支持网络复制以跨端传递附加信息；Execution Class用于复杂数值计算（可捕获攻防双方属性），MMC作为其简化版适用于简单属性计算；GE的生效方式（瞬时&#x2F;持续&#x2F;堆叠）、Tag挂载等配置需根据场景定制，确保效果符合设计需求。</li>
</ol>
<span id="more"></span>

<h1 id="GE-的作用"><a href="#GE-的作用" class="headerlink" title="GE 的作用"></a>GE 的作用</h1><p>GE 的核心作用是对属性进行修改，同时传递属性修改附加效果的相关信息。<br>举例来说，造成伤害可视为一个典型的 GE 应用场景：其核心目标是计算出 IncomingDamage（元属性）的数值，同时将附加效果（是否格挡、是否暴击、是否击退、是否触发 Debuff 等）以上下文形式传递出去，最终让这些效果逐一生效。<br>附加效果的落地执行主要在 AS 中完成，详情见<a href="/ue5-blog/2025/12/12/GAS-AS/">此处</a>。站在 GE 的视角，核心是把需要传递的信息填充到 Context 中；若要实现击退、格挡、暴击、范围伤害等定制化效果，则需要自定义 Context 来承载这些信息。<br>除 Context 外，Tag 也是承载信息的重要方式，因此掌握向 GE 中添加 Tag 信息的方法同样关键。</p>
<p>另一个核心要点是数值计算——即确定 GE 最终修改属性的具体数值。以伤害计算为例：</p>
<ul>
<li>简单场景：直接硬编码数值、从 CurveTable 读取数值，或基于已有 Attribute 计算；</li>
<li>灵活场景：通过 Set by Caller Magnitude 动态传递数值；</li>
<li>复杂场景：需动态捕获目标防御值等数据时，要借助 Execution Class 实现。</li>
</ul>
<p>此外，GE 的作用方式也需提前定义，比如是瞬时作用还是持续作用、持续作用的周期、是否允许堆叠等，这些都要在制作 GE 时配置完成。</p>
<p>下文以“带有 Debuff 效果，且需兼顾 CriticalHit、Block、Knockback、RadialDamage 的伤害 GE”为例，逐步拆解伤害产生的完整流程。</p>
<h1 id="实战解析-Damage"><a href="#实战解析-Damage" class="headerlink" title="实战解析 Damage"></a>实战解析 Damage</h1><h2 id="1-封装伤害参数（FDamageEffectParams）"><a href="#1-封装伤害参数（FDamageEffectParams）" class="headerlink" title="1. 封装伤害参数（FDamageEffectParams）"></a>1. 封装伤害参数（FDamageEffectParams）</h2><p>所有能造成伤害的 GA 均继承自 GA_Damage，其核心作用是整合攻击方的参数并打包传递，主要实现两个功能：</p>
<ol>
<li>允许在具体技能 GA（如 GA_FireBolt）的 ClassDefaults 中编辑参数；</li>
<li>将 ClassDefaults 中配置的参数封装到 <code>FDamageEffectParams</code> 结构体中传递。</li>
</ol>
<p>该自定义结构体可包含如下内容：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">USTRUCT</span>(BlueprintType)</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">FDamageEffectParams</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line">	<span class="built_in">FDamageEffectParams</span>()&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(BlueprintReadWrite)</span><br><span class="line">	TObjectPtr&lt;UObject&gt; WorldContextObject = <span class="literal">nullptr</span>;</span><br><span class="line">	<span class="built_in">UPROPERTY</span>(BlueprintReadWrite)</span><br><span class="line">	TSubclassOf&lt;UGameplayEffect&gt; DamageGEClass = <span class="literal">nullptr</span>;</span><br><span class="line">	<span class="built_in">UPROPERTY</span>(BlueprintReadWrite)</span><br><span class="line">	TObjectPtr&lt;UAbilitySystemComponent&gt; SourceASC;</span><br><span class="line">	<span class="built_in">UPROPERTY</span>(BlueprintReadWrite)</span><br><span class="line">	TObjectPtr&lt;UAbilitySystemComponent&gt; TargetASC;</span><br><span class="line">	<span class="built_in">UPROPERTY</span>(BlueprintReadWrite)</span><br><span class="line">	FGameplayTag DamageType = <span class="built_in">FGameplayTag</span>();</span><br><span class="line">	<span class="built_in">UPROPERTY</span>(BlueprintReadWrite)</span><br><span class="line">	<span class="type">float</span> BaseDamage = <span class="number">0.f</span>;</span><br><span class="line">	<span class="built_in">UPROPERTY</span>(BlueprintReadWrite)</span><br><span class="line">	<span class="type">float</span> AbilityLevel = <span class="number">1.f</span>;</span><br><span class="line">	<span class="built_in">UPROPERTY</span>(BlueprintReadWrite)</span><br><span class="line">	<span class="type">float</span> DebuffChance = <span class="number">0.f</span>;</span><br><span class="line">	<span class="built_in">UPROPERTY</span>(BlueprintReadWrite)</span><br><span class="line">	<span class="type">float</span> DebuffDamage = <span class="number">0.f</span>;</span><br><span class="line">	<span class="built_in">UPROPERTY</span>(BlueprintReadWrite)</span><br><span class="line">	<span class="type">float</span> DebuffFrequency = <span class="number">0.f</span>;</span><br><span class="line">	<span class="built_in">UPROPERTY</span>(BlueprintReadWrite)</span><br><span class="line">	<span class="type">float</span> DebuffDuration = <span class="number">0.f</span>;</span><br><span class="line">	<span class="built_in">UPROPERTY</span>(BlueprintReadWrite)</span><br><span class="line">	<span class="type">float</span> DeathImpulseMagnitude = <span class="number">0.f</span>;</span><br><span class="line">	<span class="built_in">UPROPERTY</span>(BlueprintReadWrite)</span><br><span class="line">	FVector DeathImpulse = FVector::ZeroVector;</span><br><span class="line">	<span class="built_in">UPROPERTY</span>(BlueprintReadWrite)</span><br><span class="line">	<span class="type">float</span> KnockbackForceMagnitude = <span class="number">0.f</span>;</span><br><span class="line">	<span class="built_in">UPROPERTY</span>(BlueprintReadWrite)</span><br><span class="line">	<span class="type">float</span> KnockbackChance = <span class="number">0.f</span>;</span><br><span class="line">	<span class="built_in">UPROPERTY</span>(BlueprintReadWrite)</span><br><span class="line">	FVector KnockbackForce = FVector::ZeroVector;</span><br><span class="line">	<span class="built_in">UPROPERTY</span>(BlueprintReadWrite)</span><br><span class="line">	<span class="type">bool</span> bIsRadialDamage = <span class="literal">false</span>;</span><br><span class="line">	<span class="built_in">UPROPERTY</span>(BlueprintReadWrite)</span><br><span class="line">	<span class="type">float</span> RadialDamageInnerRadius = <span class="number">0.f</span>;</span><br><span class="line">	<span class="built_in">UPROPERTY</span>(BlueprintReadWrite)</span><br><span class="line">	<span class="type">float</span> RadialDamageOuterRadius = <span class="number">0.f</span>;</span><br><span class="line">	<span class="built_in">UPROPERTY</span>(BlueprintReadWrite)</span><br><span class="line">	FVector RadialDamageOrigin = FVector::ZeroVector;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">FDamageEffectParams <span class="title">UCustomDamageGameplayAbility::MakeDamageEffectParamsFromClassDefaults</span><span class="params">(AActor* TargetActor ,FVector InRadialDamageOrigin ,</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="type">bool</span> bOverrideKnockbackDirection ,FVector KnockbackDirectionOverride ,</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="type">bool</span> bOverrideDeathImpulse ,FVector DeathImpulseOverride ,</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="type">bool</span> bOverridePitch ,<span class="type">float</span> PitchOverride )</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	FDamageEffectParams Params;</span><br><span class="line"></span><br><span class="line">	Params.WorldContextObject = <span class="built_in">GetAvatarActorFromActorInfo</span>();</span><br><span class="line">	Params.DamageGEClass = DamageEffectClass;</span><br><span class="line">	Params.SourceASC = <span class="built_in">GetAbilitySystemComponentFromActorInfo</span>();</span><br><span class="line">	Params.TargetASC = UAbilitySystemBlueprintLibrary::<span class="built_in">GetAbilitySystemComponent</span>(TargetActor);</span><br><span class="line">	Params.DamageType = DamageType;</span><br><span class="line">	Params.BaseDamage = Damage.<span class="built_in">GetValueAtLevel</span>(<span class="built_in">GetAbilityLevel</span>());</span><br><span class="line">	Params.AbilityLevel = <span class="built_in">GetAbilityLevel</span>();</span><br><span class="line">	Params.DebuffChance = DebuffChance;</span><br><span class="line">	Params.DebuffDamage = DebuffDamage;</span><br><span class="line">	Params.DebuffDuration = DebuffDuration;</span><br><span class="line">	Params.DebuffFrequency = DebuffFrequency;</span><br><span class="line">	Params.DeathImpulseMagnitude = DeathImpulseMagnitude;</span><br><span class="line">	Params.KnockbackForceMagnitude = KnockbackForceMagnitude;</span><br><span class="line">	Params.KnockbackChance = KnockbackChance;</span><br><span class="line"></span><br><span class="line">	<span class="type">const</span> <span class="type">bool</span> bKnockback = FMath::<span class="built_in">RandRange</span>(<span class="number">1</span> , <span class="number">100</span>) &lt; Params.KnockbackChance;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">IsValid</span>(TargetActor))</span><br><span class="line">	&#123;</span><br><span class="line">		FRotator Rotation = (TargetActor-&gt;<span class="built_in">GetActorLocation</span>() - <span class="built_in">GetAvatarActorFromActorInfo</span>()-&gt;<span class="built_in">GetActorLocation</span>()).<span class="built_in">Rotation</span>();</span><br><span class="line">		Rotation.Pitch = <span class="number">45.f</span>;</span><br><span class="line">		<span class="keyword">if</span> (bOverridePitch)</span><br><span class="line">		&#123;</span><br><span class="line">			Rotation.Pitch = PitchOverride;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">const</span> FVector ToTarget = Rotation.<span class="built_in">Vector</span>();</span><br><span class="line">		<span class="keyword">if</span> (!bOverrideKnockbackDirection)</span><br><span class="line">		&#123;</span><br><span class="line">			Params.DeathImpulse = ToTarget * Params.DeathImpulseMagnitude;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!bOverrideDeathImpulse &amp;&amp; bKnockback)</span><br><span class="line">		&#123;</span><br><span class="line">			Params.KnockbackForce = ToTarget * Params.KnockbackForceMagnitude;	</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (bOverrideKnockbackDirection &amp;&amp; bKnockback)</span><br><span class="line">	&#123;</span><br><span class="line">		KnockbackDirectionOverride.<span class="built_in">Normalize</span>();</span><br><span class="line">		Params.KnockbackForce = KnockbackForceMagnitude * KnockbackDirectionOverride;</span><br><span class="line">		<span class="keyword">if</span> (bOverridePitch)</span><br><span class="line">		&#123;</span><br><span class="line">			FRotator KnockbackRotation = KnockbackDirectionOverride.<span class="built_in">Rotation</span>();</span><br><span class="line">			KnockbackRotation.Pitch = PitchOverride;</span><br><span class="line">			Params.KnockbackForce = KnockbackForceMagnitude * KnockbackRotation.<span class="built_in">Vector</span>();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (bOverrideDeathImpulse)</span><br><span class="line">	&#123;</span><br><span class="line">		DeathImpulseOverride.<span class="built_in">Normalize</span>();</span><br><span class="line">		Params.DeathImpulse = DeathImpulseMagnitude * DeathImpulseOverride;</span><br><span class="line">		<span class="keyword">if</span> (bOverridePitch)</span><br><span class="line">		&#123;</span><br><span class="line">			FRotator DeathImpulseRotation = DeathImpulseOverride.<span class="built_in">Rotation</span>();</span><br><span class="line">			DeathImpulseRotation.Pitch = PitchOverride;</span><br><span class="line">			Params.DeathImpulse = DeathImpulseMagnitude * DeathImpulseRotation.<span class="built_in">Vector</span>();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (bIsRadialDamage)</span><br><span class="line">	&#123;</span><br><span class="line">		Params.bIsRadialDamage = bIsRadialDamage;</span><br><span class="line">		Params.RadialDamageInnerRadius = RadialDamageInnerRadius;</span><br><span class="line">		Params.RadialDamageOuterRadius = RadialDamageOuterRadius;</span><br><span class="line">		Params.RadialDamageOrigin = InRadialDamageOrigin;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> Params;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的细节：<br>我们在 GA 中提前填写范围伤害中心、击退方向等信息，是因为 GA 中可直接获取发起者（GA 拥有者）和目标（鼠标追踪的 Actor，获取方式见<a href="">这里</a>），基于二者位置计算这些数据即可满足大部分场景需求。若需更精准的效果（如击退方向为击中瞬间的朝向），可在后续流程中覆盖 <code>FDamageEffectParams</code> 中的参数。<br>此外，该结构体仅存储攻击方数据，无法获取受击方的防御、抗性等信息。</p>
<h2 id="2-构建-GE-实例（通用函数）"><a href="#2-构建-GE-实例（通用函数）" class="headerlink" title="2. 构建 GE 实例（通用函数）"></a>2. 构建 GE 实例（通用函数）</h2><p>基于 <code>FDamageEffectParams</code> 制作 GE 实例的函数是通用逻辑，存放于 FunctionLibrary 中：</p>
<ul>
<li>近战伤害：可直接在 GA 中调用该函数；</li>
<li>远程伤害：需等到子弹击中目标时调用（覆盖 <code>FDamageEffectParams</code> 参数）。</li>
</ul>
<p>函数实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">FGameplayEffectContextHandle <span class="title">UCustomAbilitySystemLibrary::ApplyDamageEffect</span><span class="params">(<span class="type">const</span> FDamageEffectParams&amp; DamageEffectParams)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">const</span> FCustomGameplayTags GameplayTags = FCustomGameplayTags::<span class="built_in">Get</span>();</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 填写GameplayEffectContext</span></span><br><span class="line">	<span class="type">const</span> AActor* SourceAvatarActor = DamageEffectParams.SourceASC-&gt;<span class="built_in">GetAvatarActor</span>();</span><br><span class="line">	FGameplayEffectContextHandle EffectContextHandle = DamageEffectParams.SourceASC-&gt;<span class="built_in">MakeEffectContext</span>();</span><br><span class="line">	EffectContextHandle.<span class="built_in">AddSourceObject</span>(SourceAvatarActor);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">SetDeathImpulse</span>(EffectContextHandle , DamageEffectParams.DeathImpulse);</span><br><span class="line">	<span class="built_in">SetKnockbackForce</span>(EffectContextHandle , DamageEffectParams.KnockbackForce);</span><br><span class="line">	<span class="built_in">SetIsRadialDamage</span>(EffectContextHandle , DamageEffectParams.bIsRadialDamage);</span><br><span class="line">	<span class="built_in">SetRadialDamageInnerRadius</span>(EffectContextHandle , DamageEffectParams.RadialDamageInnerRadius);</span><br><span class="line">	<span class="built_in">SetRadialDamageOuterRadius</span>(EffectContextHandle , DamageEffectParams.RadialDamageOuterRadius);</span><br><span class="line">	<span class="built_in">SetRadialDamageOrigin</span>(EffectContextHandle , DamageEffectParams.RadialDamageOrigin);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 制作GameplayEffectSpec</span></span><br><span class="line">	FGameplayEffectSpecHandle SpecHandle = DamageEffectParams.SourceASC-&gt;<span class="built_in">MakeOutgoingSpec</span>(DamageEffectParams.DamageGEClass , DamageEffectParams.AbilityLevel , EffectContextHandle);</span><br><span class="line"></span><br><span class="line">	UAbilitySystemBlueprintLibrary::<span class="built_in">AssignTagSetByCallerMagnitude</span>(SpecHandle , DamageEffectParams.DamageType , DamageEffectParams.BaseDamage);</span><br><span class="line">	UAbilitySystemBlueprintLibrary::<span class="built_in">AssignTagSetByCallerMagnitude</span>(SpecHandle , GameplayTags.Debuff_Chance , DamageEffectParams.DebuffChance);</span><br><span class="line">	UAbilitySystemBlueprintLibrary::<span class="built_in">AssignTagSetByCallerMagnitude</span>(SpecHandle , GameplayTags.Debuff_Damage , DamageEffectParams.DebuffDamage);</span><br><span class="line">	UAbilitySystemBlueprintLibrary::<span class="built_in">AssignTagSetByCallerMagnitude</span>(SpecHandle , GameplayTags.Debuff_Duration , DamageEffectParams.DebuffDuration);</span><br><span class="line">	UAbilitySystemBlueprintLibrary::<span class="built_in">AssignTagSetByCallerMagnitude</span>(SpecHandle , GameplayTags.Debuff_Frequency , DamageEffectParams.DebuffFrequency);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 应用GameplayEffect到目标</span></span><br><span class="line">	DamageEffectParams.TargetASC-&gt;<span class="built_in">ApplyGameplayEffectSpecToSelf</span>(*SpecHandle.Data);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> EffectContextHandle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数核心分为三步：</p>
<ol>
<li>填写 GameplayEffectContext；</li>
<li>制作 GameplayEffectSpec；</li>
<li>应用 GameplayEffect 到目标。</li>
</ol>
<p>补充说明：代码中操作的 Handle 类型对象是 UE 的弱引用设计，关于 Handle 的更多内容可参考<a href="/ue5-blog/2025/12/10/ProgrammingSkills-Pointer/">此处</a>。</p>
<h3 id="填写-GameplayEffectContext"><a href="#填写-GameplayEffectContext" class="headerlink" title="填写 GameplayEffectContext"></a>填写 GameplayEffectContext</h3><p>步骤如下：</p>
<ol>
<li>调用 <code>MakeEffectContext</code> 创建新上下文，通过 <code>AddSourceObject</code> 填入 GE 发起者（易遗漏，编译时会报错提醒）；</li>
<li>自定义上下文需类型转换，因此 Set 类函数均包含 Cast 操作：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UCustomAbilitySystemLibrary::SetDeathImpulse</span><span class="params">(FGameplayEffectContextHandle&amp; EffectContextHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="type">const</span> FVector&amp; InDeathImpulse)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (FCustomGameplayEffectContext* CustomContext = <span class="built_in">static_cast</span>&lt;FCustomGameplayEffectContext*&gt;(EffectContextHandle.<span class="built_in">Get</span>()))</span><br><span class="line">	&#123;</span><br><span class="line">		CustomContext-&gt;<span class="built_in">SetDeathImpulse</span>(InDeathImpulse);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>自定义上下文需支持网络复制，为参数配置 Setter&#x2F;Getter 保证安全易用：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">USTRUCT</span>(BlueprintType)</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">FCustomGameplayEffectContext</span> : <span class="keyword">public</span> FGameplayEffectContext</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">IsBlockedHit</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> bIsBlockedHit;&#125;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">IsCriticalHit</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> bIsCriticalHit;&#125;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">IsSuccessfulDebuff</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> bIsSuccessfulDebuff;&#125;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">IsRadialDamage</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> bIsRadialDamage;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">float</span> <span class="title">GetDebuffDamage</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> DebuffDamage;&#125;</span><br><span class="line">	<span class="function"><span class="type">float</span> <span class="title">GetDebuffFrequency</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> DebuffFrequency;&#125;</span><br><span class="line">	<span class="function"><span class="type">float</span> <span class="title">GetDebuffDuration</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> DebuffDuration;&#125;</span><br><span class="line">	<span class="function"><span class="type">float</span> <span class="title">GetRadialDamageInnerRadius</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> RadialDamageInnerRadius;&#125;</span><br><span class="line">	<span class="function"><span class="type">float</span> <span class="title">GetRadialDamageOuterRadius</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> RadialDamageOuterRadius;&#125;</span><br><span class="line">	<span class="function">TSharedPtr&lt;FGameplayTag&gt; <span class="title">GetDamageType</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> DamageType;&#125;</span><br><span class="line">	<span class="function">FVector <span class="title">GetDeathImpulse</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> DeathImpulse;&#125;</span><br><span class="line">	<span class="function">FVector <span class="title">GetKnockbackForce</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> KnockbackForce;&#125;</span><br><span class="line">	<span class="function">FVector <span class="title">GetRadialDamageOrigin</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> RadialDamageOrigin;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">SetBlockedHit</span><span class="params">(<span class="type">bool</span> bInIsBlockedHit)</span> </span>&#123;bIsBlockedHit = bInIsBlockedHit;&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">SetCriticalHit</span><span class="params">(<span class="type">bool</span> bInIsCriticalHit)</span> </span>&#123;bIsCriticalHit = bInIsCriticalHit;&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">SetSuccessfulDebuff</span><span class="params">(<span class="type">bool</span> bInIsSuccessfulDebuff)</span></span>&#123; bIsSuccessfulDebuff = bInIsSuccessfulDebuff;&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">SetRadialDamage</span><span class="params">(<span class="type">bool</span> bInIsRadialDamage)</span></span>&#123;bIsRadialDamage = bInIsRadialDamage;&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">SetDebuffDamage</span><span class="params">(<span class="type">float</span> InDebuffDamage)</span> </span>&#123; DebuffDamage = InDebuffDamage;&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">SetDebuffDuration</span><span class="params">(<span class="type">float</span> InDebuffDuration)</span> </span>&#123; DebuffDuration = InDebuffDuration;&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">SetDebuffFrequency</span><span class="params">(<span class="type">float</span> InDebuffFrequency)</span></span>&#123; DebuffFrequency = InDebuffFrequency;&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">SetRadialDamageInnerRadius</span><span class="params">(<span class="type">float</span> InInnerRadius)</span></span>&#123;RadialDamageInnerRadius = InInnerRadius;&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">SetRadialDamageOuterRadius</span><span class="params">(<span class="type">float</span> InOuterRadius)</span></span>&#123;RadialDamageOuterRadius = InOuterRadius;&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">SetDamageType</span><span class="params">(TSharedPtr&lt;FGameplayTag&gt; InDamageType)</span> </span>&#123; DamageType = InDamageType; &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">SetDeathImpulse</span><span class="params">(<span class="type">const</span> FVector&amp; InImpulse)</span> </span>&#123; DeathImpulse = InImpulse; &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">SetKnockbackForce</span><span class="params">(<span class="type">const</span> FVector&amp; InForce)</span> </span>&#123; KnockbackForce = InForce; &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">SetRadialDamageOrigin</span><span class="params">(<span class="type">const</span> FVector&amp; InOrigin)</span> </span>&#123; RadialDamageOrigin = InOrigin; &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> UScriptStruct* <span class="title">GetScriptStruct</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">StaticStruct</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> FCustomGameplayEffectContext* <span class="title">Duplicate</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		FCustomGameplayEffectContext* NewContext = <span class="keyword">new</span> <span class="built_in">FCustomGameplayEffectContext</span>();</span><br><span class="line">		*NewContext = *<span class="keyword">this</span>;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">GetHitResult</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			NewContext-&gt;<span class="built_in">AddHitResult</span>(*<span class="built_in">GetHitResult</span>(), <span class="literal">true</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> NewContext;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">NetSerialize</span><span class="params">(FArchive&amp; Ar, <span class="keyword">class</span> UPackageMap* Map, <span class="type">bool</span>&amp; bOutSuccess)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="built_in">UPROPERTY</span>()</span><br><span class="line">	<span class="type">bool</span> bIsBlockedHit = <span class="literal">false</span>;</span><br><span class="line">	<span class="built_in">UPROPERTY</span>()</span><br><span class="line">	<span class="type">bool</span> bIsCriticalHit = <span class="literal">false</span>;</span><br><span class="line">	<span class="built_in">UPROPERTY</span>()</span><br><span class="line">	<span class="type">bool</span> bIsSuccessfulDebuff = <span class="literal">false</span>;</span><br><span class="line">	<span class="built_in">UPROPERTY</span>()</span><br><span class="line">	<span class="type">float</span> DebuffDamage = <span class="number">0.f</span>;</span><br><span class="line">	<span class="built_in">UPROPERTY</span>()</span><br><span class="line">	<span class="type">float</span> DebuffFrequency = <span class="number">0.f</span>;</span><br><span class="line">	<span class="built_in">UPROPERTY</span>()</span><br><span class="line">	<span class="type">float</span> DebuffDuration = <span class="number">0.f</span>;</span><br><span class="line">	TSharedPtr&lt;FGameplayTag&gt; DamageType;</span><br><span class="line">	<span class="built_in">UPROPERTY</span>()</span><br><span class="line">	FVector DeathImpulse = FVector::ZeroVector;</span><br><span class="line">	<span class="built_in">UPROPERTY</span>()</span><br><span class="line">	FVector KnockbackForce = FVector::ZeroVector;</span><br><span class="line">	<span class="built_in">UPROPERTY</span>()</span><br><span class="line">	<span class="type">bool</span> bIsRadialDamage = <span class="literal">false</span>;</span><br><span class="line">	<span class="built_in">UPROPERTY</span>()</span><br><span class="line">	<span class="type">float</span> RadialDamageInnerRadius = <span class="number">0.f</span>;</span><br><span class="line">	<span class="built_in">UPROPERTY</span>()</span><br><span class="line">	<span class="type">float</span> RadialDamageOuterRadius = <span class="number">0.f</span>;</span><br><span class="line">	<span class="built_in">UPROPERTY</span>()</span><br><span class="line">	FVector RadialDamageOrigin = FVector::ZeroVector;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TStructOpsTypeTraits</span>&lt;FCustomGameplayEffectContext&gt; : <span class="keyword">public</span> TStructOpsTypeTraitsBase2&lt;FCustomGameplayEffectContext&gt;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">enum</span></span><br><span class="line">	&#123;</span><br><span class="line">		WithNetSerializer = <span class="literal">true</span>,</span><br><span class="line">		WithCopy = <span class="literal">true</span></span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>使用自定义Context还需要完成如下步骤：</p>
<ul>
<li><ol>
<li>创建自定义Globals类，并重写函数<code>AllocGameplayEffectContext</code></li>
</ol>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GAS_Custom_API</span> UCustomAbilitySystemGlobals : <span class="keyword">public</span> UAbilitySystemGlobals</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> FGameplayEffectContext* <span class="title">AllocGameplayEffectContext</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">	</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">FGameplayEffectContext* <span class="title">UCustomAbilitySystemGlobals::AllocGameplayEffectContext</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">FCustomGameplayEffectContext</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><ol start="2">
<li>更改配置，使用自定义Context<br>修改Config&#x2F;DefaultGame.ini文件，添加如下内容：</li>
</ol>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[/Script/GameplayAbilities.AbilitySystemGlobals]</span><br><span class="line">+AbilitySystemGlobalsClassName=&quot;Script/ProjectName.CustomeAbilitySystemGlobals&quot;</span><br></pre></td></tr></table></figure>

<h3 id="制作-GameplayEffectSpec"><a href="#制作-GameplayEffectSpec" class="headerlink" title="制作 GameplayEffectSpec"></a>制作 GameplayEffectSpec</h3><p>调用 <code>MakeOutgoingSpec</code> 制作 Spec，需传入 GE 模板类、等级和上下文信息。Spec 是控制 GE 实例化的核心，应用 Spec 即表示将 GE 实例挂载到目标 ASC 上。</p>
<p>核心问题是确定 GE 修改的属性数值（如伤害值）：</p>
<ol>
<li>数据传递：攻击方攻击力已封装在 EffectParams 中，但未传入 Context（Context 主要传递 GE 后续影响，攻击力仅影响 GE 最终修改的属性值）；</li>
<li>Debuff 数据处理：虽自定义 Context 包含 Debuff 数据，但暂不传递，原因是：<ul>
<li>Debuff 是概率事件，未触发时无需序列化，可优化性能；</li>
<li>Debuff 需结合受击方抗性计算，此时仅能获取攻击方数据，传递时机过早。</li>
</ul>
</li>
</ol>
<p>因此需通过 SetByCaller 将 EffectParams 数据传入 EffectSpec——Spec 内部维护 Tag 到数值的映射表，存取方式如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 绑定数据到Tag</span></span><br><span class="line">UAbilitySystemBlueprintLibrary::<span class="built_in">AssignTagSetByCallerMagnitude</span>(SpecHandle , DamageEffectParams.DamageType , DamageEffectParams.BaseDamage);</span><br><span class="line"><span class="comment">// 从Tag读取数据（后两个参数：未找到标签是否警告、未找到时返回值）</span></span><br><span class="line"><span class="type">const</span> <span class="type">float</span> TypeDamage = Spec.<span class="built_in">GetSetByCallerMagnitude</span>(DamageType , <span class="literal">false</span> , <span class="number">-1.f</span>);</span><br></pre></td></tr></table></figure>

<p>其中 DamageType 标签用于区分攻击类型（如火攻、雷攻）。</p>
<h3 id="应用-GameplayEffect-到目标"><a href="#应用-GameplayEffect-到目标" class="headerlink" title="应用 GameplayEffect 到目标"></a>应用 GameplayEffect 到目标</h3><p>代码中调用 <code>TargetASC-&gt;ApplyGameplayEffectSpecToSelf</code> 看似直接应用 GE，但核心的伤害计算封装在底层——GE 最终挂载在目标 ASC 上，EffectSpec 已包含上下文和 SetByCaller 数据，足以支撑计算。</p>
<p>GE 模板类（如 GE_Damage）需定义以下核心要素：</p>
<ol>
<li>Duration Policy：分为 Instant（瞬时）、Infinite（永久）、Duration（持续），暂不考虑持续伤害（归为 Debuff 处理）；</li>
<li>Modifier：简单数值计算（硬编码&#x2F;ScalableFloat），Debuff 的 GE 会用到；</li>
<li>Execution：复杂数值计算（捕获属性、定制化逻辑），需在蓝图中添加继承自 <code>UGameplayEffectExecutionCalculation</code> 的自定义类型；</li>
<li>Component：挂载 Tag，Debuff 的 GE 会用到；</li>
<li>Stacking：叠加策略，简化场景下选 None 即可。</li>
</ol>
<h4 id="Exec-Damage-定制化计算"><a href="#Exec-Damage-定制化计算" class="headerlink" title="Exec_Damage 定制化计算"></a>Exec_Damage 定制化计算</h4><p>核心是重写 <code>Execute_Implementation</code> 函数，步骤如下：</p>
<h5 id="步骤1：定义并注册属性捕获规则"><a href="#步骤1：定义并注册属性捕获规则" class="headerlink" title="步骤1：定义并注册属性捕获规则"></a>步骤1：定义并注册属性捕获规则</h5><p>通过静态函数封装规则避免重复注册，规则格式：<code>DEFINE_ATTRIBUTE_CAPTUREDEF(AS类 , 属性名 , 捕获源（Source/Target） , 是否快照)</code>。是否快照一般选 false，防止参数变化影响计算。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">CustomDamageStatics</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">DECLARE_ATTRIBUTE_CAPTUREDEF</span>(Armor);</span><br><span class="line">	<span class="built_in">DECLARE_ATTRIBUTE_CAPTUREDEF</span>(ArmorPenetration);</span><br><span class="line">	<span class="built_in">DECLARE_ATTRIBUTE_CAPTUREDEF</span>(BlockChance);</span><br><span class="line">	<span class="built_in">DECLARE_ATTRIBUTE_CAPTUREDEF</span>(CriticalHitChance);</span><br><span class="line">	<span class="built_in">DECLARE_ATTRIBUTE_CAPTUREDEF</span>(CriticalHitDamage);</span><br><span class="line">	<span class="built_in">DECLARE_ATTRIBUTE_CAPTUREDEF</span>(CriticalHitResistance);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">DECLARE_ATTRIBUTE_CAPTUREDEF</span>(FireResistance);</span><br><span class="line">	<span class="built_in">DECLARE_ATTRIBUTE_CAPTUREDEF</span>(LightningResistance);</span><br><span class="line">	<span class="built_in">DECLARE_ATTRIBUTE_CAPTUREDEF</span>(ArcaneResistance);</span><br><span class="line">	<span class="built_in">DECLARE_ATTRIBUTE_CAPTUREDEF</span>(PhysicalResistance);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">CustomDamageStatics</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">DEFINE_ATTRIBUTE_CAPTUREDEF</span>(UCustomAttributeSet , Armor , Target , <span class="literal">false</span>);</span><br><span class="line">		<span class="built_in">DEFINE_ATTRIBUTE_CAPTUREDEF</span>(UCustomAttributeSet , ArmorPenetration , Source , <span class="literal">false</span>);</span><br><span class="line">		<span class="built_in">DEFINE_ATTRIBUTE_CAPTUREDEF</span>(UCustomAttributeSet , BlockChance , Target , <span class="literal">false</span>);</span><br><span class="line">		<span class="built_in">DEFINE_ATTRIBUTE_CAPTUREDEF</span>(UCustomAttributeSet , CriticalHitChance , Source , <span class="literal">false</span>);</span><br><span class="line">		<span class="built_in">DEFINE_ATTRIBUTE_CAPTUREDEF</span>(UCustomAttributeSet , CriticalHitDamage , Source , <span class="literal">false</span>);</span><br><span class="line">		<span class="built_in">DEFINE_ATTRIBUTE_CAPTUREDEF</span>(UCustomAttributeSet , CriticalHitResistance , Target , <span class="literal">false</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="built_in">DEFINE_ATTRIBUTE_CAPTUREDEF</span>(UCustomAttributeSet , FireResistance , Target , <span class="literal">false</span>);</span><br><span class="line">		<span class="built_in">DEFINE_ATTRIBUTE_CAPTUREDEF</span>(UCustomAttributeSet , LightningResistance , Target , <span class="literal">false</span>);</span><br><span class="line">		<span class="built_in">DEFINE_ATTRIBUTE_CAPTUREDEF</span>(UCustomAttributeSet , ArcaneResistance , Target , <span class="literal">false</span>);</span><br><span class="line">		<span class="built_in">DEFINE_ATTRIBUTE_CAPTUREDEF</span>(UCustomAttributeSet , PhysicalResistance , Target , <span class="literal">false</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">const</span> CustomDamageStatics&amp; <span class="title">DamageStatics</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">static</span> CustomDamageStatics  DStatics;</span><br><span class="line">	<span class="keyword">return</span> DStatics;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="步骤2：注册捕获规则"><a href="#步骤2：注册捕获规则" class="headerlink" title="步骤2：注册捕获规则"></a>步骤2：注册捕获规则</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">UExecCalc_Damage::<span class="built_in">UExecCalc_Damage</span>()</span><br><span class="line">&#123;</span><br><span class="line">	RelevantAttributesToCapture.<span class="built_in">Add</span>(<span class="built_in">DamageStatics</span>().ArmorDef);</span><br><span class="line">	RelevantAttributesToCapture.<span class="built_in">Add</span>(<span class="built_in">DamageStatics</span>().ArmorPenetrationDef);</span><br><span class="line">	RelevantAttributesToCapture.<span class="built_in">Add</span>(<span class="built_in">DamageStatics</span>().BlockChanceDef);</span><br><span class="line">	RelevantAttributesToCapture.<span class="built_in">Add</span>(<span class="built_in">DamageStatics</span>().CriticalHitChanceDef);</span><br><span class="line">	RelevantAttributesToCapture.<span class="built_in">Add</span>(<span class="built_in">DamageStatics</span>().CriticalHitDamageDef);</span><br><span class="line">	RelevantAttributesToCapture.<span class="built_in">Add</span>(<span class="built_in">DamageStatics</span>().CriticalHitResistanceDef);</span><br><span class="line">	</span><br><span class="line">	RelevantAttributesToCapture.<span class="built_in">Add</span>(<span class="built_in">DamageStatics</span>().FireResistanceDef);</span><br><span class="line">	RelevantAttributesToCapture.<span class="built_in">Add</span>(<span class="built_in">DamageStatics</span>().LightningResistanceDef);</span><br><span class="line">	RelevantAttributesToCapture.<span class="built_in">Add</span>(<span class="built_in">DamageStatics</span>().ArcaneResistanceDef);</span><br><span class="line">	RelevantAttributesToCapture.<span class="built_in">Add</span>(<span class="built_in">DamageStatics</span>().PhysicalResistanceDef);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="步骤3：使用捕获属性计算伤害"><a href="#步骤3：使用捕获属性计算伤害" class="headerlink" title="步骤3：使用捕获属性计算伤害"></a>步骤3：使用捕获属性计算伤害</h5><p>先准备 EvaluateParams 和 Context，再调用 <code>AttemptCalculateCapturedAttributeMagnitude</code> 获取属性值，同时将是否暴击等信息写入 Context（引用传递可直接修改）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> FGameplayEffectSpec&amp; Spec = ExecutionParams.<span class="built_in">GetOwningSpec</span>();</span><br><span class="line">FGameplayEffectContextHandle EffectContextHandle = Spec.<span class="built_in">GetContext</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> FGameplayTagContainer* SourceTags = Spec.CapturedSourceTags.<span class="built_in">GetAggregatedTags</span>();</span><br><span class="line"><span class="type">const</span> FGameplayTagContainer* TargetTags = Spec.CapturedTargetTags.<span class="built_in">GetAggregatedTags</span>();</span><br><span class="line">FAggregatorEvaluateParameters EvaluateParameters;</span><br><span class="line">EvaluateParameters.SourceTags = SourceTags;</span><br><span class="line">EvaluateParameters.TargetTags = TargetTags;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> TargetBlockChance = <span class="number">0.f</span>;</span><br><span class="line">ExecutionParams.<span class="built_in">AttemptCalculateCapturedAttributeMagnitude</span>(<span class="built_in">DamageStatics</span>().BlockChanceDef , EvaluateParameters , TargetBlockChance);</span><br><span class="line">TargetBlockChance = FMath::<span class="built_in">Max</span>&lt;<span class="type">float</span>&gt;(TargetBlockChance, <span class="number">0.f</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">bool</span> bBlocked = FMath::<span class="built_in">RandRange</span>(<span class="number">1</span> , <span class="number">100</span>) &lt; TargetBlockChance;</span><br><span class="line">UCustomAbilitySystemLibrary::<span class="built_in">SetIsBlockedHit</span>(EffectContextHandle , bBlocked);</span><br><span class="line"></span><br><span class="line">Damage = bBlocked ? Damage / <span class="number">2.f</span> : Damage;</span><br></pre></td></tr></table></figure>

<h4 id="RadialDamage-范围伤害实现"><a href="#RadialDamage-范围伤害实现" class="headerlink" title="RadialDamage 范围伤害实现"></a>RadialDamage 范围伤害实现</h4><p>实现步骤：</p>
<ol>
<li>计算完抗性减免后的伤害值 DamageTypeValue；</li>
<li>调用 <code>UGameplayStatics::ApplyRadialDamageWithFalloff</code> 计算范围伤害；</li>
<li>该函数会触发角色类 <code>TakeDamage</code>，需在 <code>TakeDamage</code> 中广播伤害值，再绑定回调获取并覆盖 DamageTypeValue。</li>
</ol>
<p>逻辑需注意：先绑定回调再广播，才能正确捕获数值：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (UCustomAbilitySystemLibrary::<span class="built_in">IsRadialDamage</span>(EffectContextHandle))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (ICombatInterface* CombatInterface = <span class="built_in">Cast</span>&lt;ICombatInterface&gt;(TargetAvatar))</span><br><span class="line">    &#123;</span><br><span class="line">        CombatInterface-&gt;<span class="built_in">GetOnDamageDelegate</span>().<span class="built_in">AddLambda</span>(</span><br><span class="line">            [&amp;](<span class="type">float</span> DamageAmount)</span><br><span class="line">            &#123;</span><br><span class="line">                DamageTypeValue = DamageAmount;</span><br><span class="line">            &#125;</span><br><span class="line">            );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    UGameplayStatics::<span class="built_in">ApplyRadialDamageWithFalloff</span>(</span><br><span class="line">        TargetAvatar ,</span><br><span class="line">        DamageTypeValue ,</span><br><span class="line">        <span class="number">0.f</span> ,</span><br><span class="line">        UCustomAbilitySystemLibrary::<span class="built_in">GetRadialDamageOrigin</span>(EffectContextHandle) ,</span><br><span class="line">        UCustomAbilitySystemLibrary::<span class="built_in">GetRadialDamageInnerRadius</span>(EffectContextHandle) ,</span><br><span class="line">        UCustomAbilitySystemLibrary::<span class="built_in">GetRadialDamageOuterRadius</span>(EffectContextHandle) ,</span><br><span class="line">        <span class="number">1.f</span> ,</span><br><span class="line">        UDamageType::<span class="built_in">StaticClass</span>() ,</span><br><span class="line">        <span class="built_in">TArray</span>&lt;AActor*&gt;() ,</span><br><span class="line">        SourceAvatar ,</span><br><span class="line">        <span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>补充说明：该方式逻辑稍绕，但无需关注范围伤害细节；也可基于 Context 中的范围伤害原点、目标位置自定义算法实现。</p>
<h4 id="Debuff-处理"><a href="#Debuff-处理" class="headerlink" title="Debuff 处理"></a>Debuff 处理</h4><p>Debuff 是伤害 GE 的附加作用，核心是填充 Context（在 Execution 中计算是因为需结合受击方抗性，而非仅用攻击方数据）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">float</span> TypeDamage = Spec.<span class="built_in">GetSetByCallerMagnitude</span>(DamageType , <span class="literal">false</span> , <span class="number">-1.f</span>);</span><br><span class="line"><span class="keyword">if</span> (TypeDamage &gt; <span class="number">-1.f</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">float</span> SourceDebuffChance = Spec.<span class="built_in">GetSetByCallerMagnitude</span>(GameplayTags.Debuff_Chance , <span class="literal">false</span> , <span class="number">-1.f</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> TargetDebuffResistance = <span class="number">0.f</span>;</span><br><span class="line">    <span class="type">const</span> FGameplayTag&amp; ResistanceTag = GameplayTags.DamageTypesToResistances[DamageType];</span><br><span class="line">    ExecutionParams.<span class="built_in">AttemptCalculateCapturedAttributeMagnitude</span>(InTagsToDefs[ResistanceTag] , EvaluateParameters , TargetDebuffResistance);</span><br><span class="line">    <span class="type">const</span> <span class="type">float</span> EffectiveDebuffChance = SourceDebuffChance * (<span class="number">100.f</span> - TargetDebuffResistance) / <span class="number">100.f</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span> bDebuff = FMath::<span class="built_in">RandRange</span>(<span class="number">1</span> , <span class="number">100</span>) &lt; EffectiveDebuffChance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bDebuff)</span><br><span class="line">    &#123;</span><br><span class="line">        FGameplayEffectContextHandle ContextHandle = Spec.<span class="built_in">GetContext</span>();</span><br><span class="line"></span><br><span class="line">        UCustomAbilitySystemLibrary::<span class="built_in">SetIsSuccessfulDebuff</span>(ContextHandle , <span class="literal">true</span>);</span><br><span class="line">        UCustomAbilitySystemLibrary::<span class="built_in">SetDamageType</span>(ContextHandle , DamageType);</span><br><span class="line"></span><br><span class="line">        <span class="type">const</span> <span class="type">float</span> DebuffDamage = Spec.<span class="built_in">GetSetByCallerMagnitude</span>(GameplayTags.Debuff_Damage , <span class="literal">false</span> , <span class="number">-1.f</span>);</span><br><span class="line">        <span class="type">const</span> <span class="type">float</span> DebuffDuration = Spec.<span class="built_in">GetSetByCallerMagnitude</span>(GameplayTags.Debuff_Duration, <span class="literal">false</span> , <span class="number">-1.f</span>);</span><br><span class="line">        <span class="type">const</span> <span class="type">float</span> DebuffFrequency = Spec.<span class="built_in">GetSetByCallerMagnitude</span>(GameplayTags.Debuff_Frequency , <span class="literal">false</span> , <span class="number">-1.f</span>);</span><br><span class="line"></span><br><span class="line">        UCustomAbilitySystemLibrary::<span class="built_in">SetDebuffDamage</span>(ContextHandle , DebuffDamage);</span><br><span class="line">        UCustomAbilitySystemLibrary::<span class="built_in">SetDebuffDuration</span>(ContextHandle , DebuffDuration);</span><br><span class="line">        UCustomAbilitySystemLibrary::<span class="built_in">SetDebuffFrequency</span>(ContextHandle , DebuffFrequency);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：DamageType 是预定义的伤害类型 Tag，若 <code>AssignTagSetByCallerMagnitude</code> 未注册对应 Tag，读取会返回 -1.f。</p>
<h1 id="Debuff的生效"><a href="#Debuff的生效" class="headerlink" title="Debuff的生效"></a>Debuff的生效</h1><p>GE_Damage 最终传递到目标 AS（修改元属性 IncomingDamage，原因见<a href="/ue5-blog/2025/12/12/GAS-AS/">此处</a>），传递的不仅是属性数值，还有完整的 GE Context——AS 会基于 Context 处理 Debuff 等附加效果。</p>
<p>AS 中检测到 Context 标记 <code>IsSuccessfulDebuff</code> 为 true 时，调用 <code>HandleDebuff</code> 处理：Debuff 本质是新的 GE（无需复用 GE_Damage，避免冗余的击退、暴击逻辑），需动态创建并挂载到目标 ASC。</p>
<p>具体步骤：</p>
<ol>
<li>制作 Context，填入 <code>AddSourceObject</code>；</li>
<li>新建 GE 实例：<code>NewObject&lt;UGameplayEffect&gt;(GetTransientPackage() , FName(DebuffName))</code>（Outer 参数用 <code>GetTransientPackage()</code>）；</li>
<li>配置 Duration Policy（使用 Context 传递的数值，数据已整理到 Props 结构体，见<a href="/ue5-blog/2025/12/12/GAS-AS/">此处</a>）；</li>
<li>添加 Tag（示例：眩晕 Debuff 屏蔽玩家输入）；</li>
<li>设置堆叠规则（限制叠加重数）；</li>
<li>添加 Modifier（用简单的 FScalableFloat 类型）；</li>
<li>应用新建的 GE。</li>
</ol>
<p>代码实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UCustomAttributeSet::HandleDebuff</span><span class="params">(<span class="type">const</span> FEffectProperties&amp; Props)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">const</span> FCustomGameplayTags GameplayTags = FCustomGameplayTags::<span class="built_in">Get</span>();</span><br><span class="line">	</span><br><span class="line">	FGameplayEffectContextHandle EffectContext = Props.SourceASC-&gt;<span class="built_in">MakeEffectContext</span>();</span><br><span class="line">	EffectContext.<span class="built_in">AddSourceObject</span>(Props.SourceAvatarActor);</span><br><span class="line"></span><br><span class="line">	<span class="type">const</span> FGameplayTag DamageType = UCustomAbilitySystemLibrary::<span class="built_in">GetDamageType</span>(Props.EffectContextHandle);</span><br><span class="line">	<span class="type">const</span> <span class="type">float</span> DebuffDamage = UCustomAbilitySystemLibrary::<span class="built_in">GetDebuffDamage</span>(Props.EffectContextHandle);</span><br><span class="line">	<span class="type">const</span> <span class="type">float</span> DebuffDuration = UCustomAbilitySystemLibrary::<span class="built_in">GetDebuffDuration</span>(Props.EffectContextHandle);</span><br><span class="line">	<span class="type">const</span> <span class="type">float</span> DebuffFrequency = UCustomAbilitySystemLibrary::<span class="built_in">GetDebuffFrequency</span>(Props.EffectContextHandle);</span><br><span class="line">	</span><br><span class="line">	FString DebuffName = FString::<span class="built_in">Printf</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;DynamicDebuff_%s&quot;</span>) , *DamageType.<span class="built_in">ToString</span>() );</span><br><span class="line">	UGameplayEffect* Effect = <span class="built_in">NewObject</span>&lt;UGameplayEffect&gt;(<span class="built_in">GetTransientPackage</span>() , <span class="built_in">FName</span>(DebuffName));</span><br><span class="line"></span><br><span class="line">	Effect-&gt;DurationPolicy = EGameplayEffectDurationType::HasDuration;</span><br><span class="line">	Effect-&gt;Period = DebuffFrequency;</span><br><span class="line">	Effect-&gt;DurationMagnitude = <span class="built_in">FScalableFloat</span>(DebuffDuration);</span><br><span class="line"></span><br><span class="line">	<span class="type">const</span> FGameplayTag DebuffTag = GameplayTags.DamageTypesToDebuffs[DamageType];</span><br><span class="line">	FInheritedTagContainer TagContainer = <span class="built_in">FInheritedTagContainer</span>();</span><br><span class="line">	UTargetTagsGameplayEffectComponent&amp; Component = Effect-&gt;<span class="built_in">FindOrAddComponent</span>&lt;UTargetTagsGameplayEffectComponent&gt;();</span><br><span class="line">	TagContainer.Added.<span class="built_in">AddTag</span>(DebuffTag);</span><br><span class="line">	<span class="keyword">if</span> (DebuffTag.<span class="built_in">MatchesTagExact</span>(GameplayTags.Debuff_Stun))</span><br><span class="line">	&#123;</span><br><span class="line">		TagContainer.Added.<span class="built_in">AddTag</span>(GameplayTags.Player_Block_InputHeld);</span><br><span class="line">		TagContainer.Added.<span class="built_in">AddTag</span>(GameplayTags.Player_Block_CursorTrace);</span><br><span class="line">		TagContainer.Added.<span class="built_in">AddTag</span>(GameplayTags.Player_Block_InputPressed);</span><br><span class="line">		TagContainer.Added.<span class="built_in">AddTag</span>(GameplayTags.Player_Block_InputReleased);</span><br><span class="line">	&#125;</span><br><span class="line">	Component.<span class="built_in">SetAndApplyTargetTagChanges</span>(TagContainer);</span><br><span class="line"></span><br><span class="line">	Effect-&gt;StackingType = EGameplayEffectStackingType::AggregateBySource;</span><br><span class="line">	Effect-&gt;StackLimitCount = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="type">const</span> int32 Index = Effect-&gt;Modifiers.<span class="built_in">Num</span>();</span><br><span class="line">	Effect-&gt;Modifiers.<span class="built_in">Add</span>(<span class="built_in">FGameplayModifierInfo</span>());</span><br><span class="line">	FGameplayModifierInfo&amp; ModifierInfo = Effect-&gt;Modifiers[Index];</span><br><span class="line"></span><br><span class="line">	ModifierInfo.ModifierMagnitude = <span class="built_in">FScalableFloat</span>(DebuffDamage);</span><br><span class="line">	ModifierInfo.ModifierOp = EGameplayModOp::Additive;</span><br><span class="line">	ModifierInfo.Attribute = UCustomAttributeSet::<span class="built_in">GetIncomingDamageAttribute</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (FGameplayEffectSpec* MutableSpec = <span class="keyword">new</span> <span class="built_in">FGameplayEffectSpec</span>(Effect , EffectContext , <span class="number">1.f</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		FCustomGameplayEffectContext* CustomContext = <span class="built_in">static_cast</span>&lt;FCustomGameplayEffectContext*&gt;(MutableSpec-&gt;<span class="built_in">GetContext</span>().<span class="built_in">Get</span>());</span><br><span class="line">		TSharedPtr&lt;FGameplayTag&gt; DebuffDamageType = <span class="built_in">MakeShareable</span>(<span class="keyword">new</span> <span class="built_in">FGameplayTag</span>(DamageType));</span><br><span class="line">		CustomContext-&gt;<span class="built_in">SetDamageType</span>(DebuffDamageType);</span><br><span class="line">		Props.TargetASC-&gt;<span class="built_in">ApplyGameplayEffectSpecToSelf</span>(*MutableSpec);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="ModMagCalc-MMC"><a href="#ModMagCalc-MMC" class="headerlink" title="ModMagCalc (MMC)"></a>ModMagCalc (MMC)</h1><p>补充一种 GE 数值计算方式：在 Modifier 中选择 MMC 并自定义类型，是 Execution 的弱化版，仅需完成以下步骤：</p>
<ol>
<li>定义捕获属性，在构造函数中注册；</li>
<li>重写 <code>CalculateBaseMagnitude_Implementation</code> 返回计算结果；</li>
<li>计算前准备 EvaluateParams，调用 <code>GetCapturedAttributeMagnitude</code> 获取属性值；</li>
<li>基于获取的数据完成计算并返回。</li>
</ol>
<p>声明与实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GAS_Custom_API</span> UMMC_MaxHealth : <span class="keyword">public</span> UGameplayModMagnitudeCalculation</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">GENERATED_BODY</span>()</span><br><span class="line">	</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">UMMC_MaxHealth</span>();</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">float</span> <span class="title">CalculateBaseMagnitude_Implementation</span><span class="params">(<span class="type">const</span> FGameplayEffectSpec&amp; Spec)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	FGameplayEffectAttributeCaptureDefinition VigorDef;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">UMMC_MaxHealth::<span class="built_in">UMMC_MaxHealth</span>()</span><br><span class="line">&#123;</span><br><span class="line">	VigorDef.AttributeToCapture = UCustomAttributeSet::<span class="built_in">GetVigorAttribute</span>();</span><br><span class="line">	VigorDef.AttributeSource = EGameplayEffectAttributeCaptureSource::Target;</span><br><span class="line">	VigorDef.bSnapshot = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	RelevantAttributesToCapture.<span class="built_in">Add</span>(VigorDef);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">UMMC_MaxHealth::CalculateBaseMagnitude_Implementation</span><span class="params">(<span class="type">const</span> FGameplayEffectSpec&amp; Spec)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">	<span class="type">const</span> FGameplayTagContainer* SourceTags = Spec.CapturedSourceTags.<span class="built_in">GetAggregatedTags</span>();</span><br><span class="line">	<span class="type">const</span> FGameplayTagContainer* TargetTags = Spec.CapturedTargetTags.<span class="built_in">GetAggregatedTags</span>();</span><br><span class="line">	FAggregatorEvaluateParameters EvaluateParameters;</span><br><span class="line">	EvaluateParameters.SourceTags = SourceTags;</span><br><span class="line">	EvaluateParameters.TargetTags = TargetTags;</span><br><span class="line"></span><br><span class="line">	<span class="type">float</span> Vigor = <span class="number">0.f</span>;</span><br><span class="line">	<span class="built_in">GetCapturedAttributeMagnitude</span>(VigorDef , Spec , EvaluateParameters , Vigor);</span><br><span class="line">	Vigor = FMath::<span class="built_in">Max</span>&lt;<span class="type">float</span>&gt;(Vigor , <span class="number">0.f</span>);</span><br><span class="line"></span><br><span class="line">	int32 PlayerLevel = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (Spec.<span class="built_in">GetContext</span>().<span class="built_in">GetSourceObject</span>()-&gt;<span class="built_in">Implements</span>&lt;UCombatInterface&gt;())</span><br><span class="line">	&#123;</span><br><span class="line">		PlayerLevel = ICombatInterface::<span class="built_in">Execute_GetPlayerLevel</span>(Spec.<span class="built_in">GetContext</span>().<span class="built_in">GetSourceObject</span>());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">80.f</span> + <span class="number">2.5f</span> * Vigor + <span class="number">10.f</span> * PlayerLevel;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>SystemDesigns</category>
        <category>GAS</category>
      </categories>
      <tags>
        <tag>GAS</tag>
        <tag>GE</tag>
      </tags>
  </entry>
  <entry>
    <title>AbilityTask</title>
    <url>/ue5-blog/2025/12/14/SystemDesigns/GAS/AbilityTask/</url>
    <content><![CDATA[<h1 id="核心总结"><a href="#核心总结" class="headerlink" title="核心总结"></a>核心总结</h1><p>AbilityTask 是 GAS 框架中解耦 GameplayAbility（GA）可复用异步逻辑的核心组件，主打“异步数据获取+跨端数据传输+网络同步”，可将鼠标击中对象获取、异步动画回调等通用逻辑封装为独立任务，提升 GA 代码复用性与逻辑整洁度。</p>
<span id="more"></span>

<h1 id="AbilityTask-的作用"><a href="#AbilityTask-的作用" class="headerlink" title="AbilityTask 的作用"></a>AbilityTask 的作用</h1><p>在 GA 开发中，鼠标击中对象获取、异步事件监听等通用数据获取逻辑，需解耦为独立模块以复用，AbilityTask 为此设计，核心流程包含三步：</p>
<ol>
<li>执行异步任务，获取目标数据；</li>
<li>将数据回调传递给调用该任务的 GA；</li>
<li>完成客户端与服务端的网络同步。</li>
</ol>
<p>以下以「获取鼠标指向目标数据（TargetDataUnderMouse）」为例，拆解 AbilityTask 的完整实现流程。</p>
<h1 id="TargetDataUnderMouse-任务实现"><a href="#TargetDataUnderMouse-任务实现" class="headerlink" title="TargetDataUnderMouse 任务实现"></a>TargetDataUnderMouse 任务实现</h1><h2 id="1-蓝图可调用设计"><a href="#1-蓝图可调用设计" class="headerlink" title="1. 蓝图可调用设计"></a>1. 蓝图可调用设计</h2><p>GA 的核心逻辑通常在蓝图中实现，因此自定义 AbilityTask 需适配蓝图调用，关键是定义动态多播委托与蓝图可调用的创建函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam</span>(FMouseTargetDataSignature, <span class="type">const</span> FGameplayAbilityTargetDataHandle&amp;, DataHandle);</span><br><span class="line"></span><br><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GAS_Custom_API</span> UTargetDataUnderMouse : <span class="keyword">public</span> UAbilityTask</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintCallable , Category = <span class="string">&quot;Ability|Tasks&quot;</span> , meta = (DisplayName = <span class="string">&quot;TargetDataUnderMouse&quot;</span> , HidePin = <span class="string">&quot;OwningAbility&quot;</span> , DefaultToSelf = <span class="string">&quot;OwningAbility&quot;</span> , BlueprintInternalUseOnly = <span class="string">&quot;true&quot;</span>) )</span><br><span class="line">	<span class="function"><span class="type">static</span> UTargetDataUnderMouse* <span class="title">CreateTargetDataUnderMouse</span><span class="params">(UGameplayAbility* OwningAbility)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(BlueprintAssignable)</span><br><span class="line">	FMouseTargetDataSignature ValidData;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>蓝图中可通过「TargetDataUnderMouse」节点创建任务，该节点包含「ValidData」执行线与「DataHandle」数据输出：</p>
<ul>
<li>节点右上角的时钟标识表明其为异步任务，后续逻辑需绑定至「ValidData」执行线触发；</li>
<li>异步特性意味着节点后接的函数不会立即执行，需等待数据获取完成。<br><img src="/ue5-blog/2025/12/14/SystemDesigns/GAS/AbilityTask/image.png" alt="alt text"></li>
</ul>
<h2 id="2-任务核心实现"><a href="#2-任务核心实现" class="headerlink" title="2. 任务核心实现"></a>2. 任务核心实现</h2><p>自定义 AbilityTask 需重写 Activate 函数（创建任务后自动调用），核心完成“客户端获取数据、服务端同步数据、回调传递给GA”三大逻辑：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">UTargetDataUnderMouse* <span class="title">UTargetDataUnderMouse::CreateTargetDataUnderMouse</span><span class="params">(UGameplayAbility* OwningAbility)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	UTargetDataUnderMouse* MyObj = <span class="built_in">NewAbilityTask</span>&lt;UTargetDataUnderMouse&gt;(OwningAbility);</span><br><span class="line">	<span class="keyword">return</span> MyObj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UTargetDataUnderMouse::Activate</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 本地控制：直接获取鼠标数据；非本地控制：等待客户端同步数据</span></span><br><span class="line">	<span class="type">const</span> <span class="type">bool</span> bIsLocallyControlled = Ability-&gt;<span class="built_in">GetCurrentActorInfo</span>()-&gt;<span class="built_in">IsLocallyControlled</span>();</span><br><span class="line">	<span class="keyword">if</span> (bIsLocallyControlled)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">SendMouseCursorData</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">const</span> FGameplayAbilitySpecHandle SpecHandle = <span class="built_in">GetAbilitySpecHandle</span>();</span><br><span class="line">		<span class="type">const</span> FPredictionKey PredictionKey = <span class="built_in">GetActivationPredictionKey</span>();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 绑定客户端数据同步的回调</span></span><br><span class="line">		AbilitySystemComponent.<span class="built_in">Get</span>()-&gt;<span class="built_in">AbilityTargetDataSetDelegate</span>(SpecHandle , PredictionKey).<span class="built_in">AddUObject</span>(<span class="keyword">this</span> , &amp;UTargetDataUnderMouse::OnTargetDataReplicatedCallback);</span><br><span class="line"></span><br><span class="line">		<span class="type">const</span> <span class="type">bool</span> bCalledDelegate = AbilitySystemComponent.<span class="built_in">Get</span>()-&gt;<span class="built_in">CallReplicatedTargetDataDelegatesIfSet</span>(SpecHandle , PredictionKey);</span><br><span class="line">		<span class="keyword">if</span> (!bCalledDelegate)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">SetWaitingOnRemotePlayerData</span>();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UTargetDataUnderMouse::SendMouseCursorData</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">FScopedPredictionWindow <span class="title">ScopedPredictionWindow</span><span class="params">(AbilitySystemComponent.Get())</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 1. 获取鼠标指向的命中结果</span></span><br><span class="line">	APlayerController* PC = Ability-&gt;<span class="built_in">GetCurrentActorInfo</span>()-&gt;PlayerController.<span class="built_in">Get</span>();</span><br><span class="line">	FHitResult CursorHitResult;</span><br><span class="line">	PC-&gt;<span class="built_in">GetHitResultUnderCursor</span>(ECC_Target , <span class="literal">false</span> , CursorHitResult);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2. 封装命中数据并同步至服务端</span></span><br><span class="line">	FGameplayAbilityTargetDataHandle DataHandle;</span><br><span class="line">	FGameplayAbilityTargetData_SingleTargetHit* Data = <span class="keyword">new</span> <span class="built_in">FGameplayAbilityTargetData_SingleTargetHit</span>();</span><br><span class="line">	Data-&gt;HitResult = CursorHitResult;</span><br><span class="line">	DataHandle.<span class="built_in">Add</span>(Data);</span><br><span class="line"></span><br><span class="line">	AbilitySystemComponent-&gt;<span class="built_in">ServerSetReplicatedTargetData</span>(</span><br><span class="line">		<span class="built_in">GetAbilitySpecHandle</span>() ,</span><br><span class="line">		<span class="built_in">GetActivationPredictionKey</span>() ,</span><br><span class="line">		DataHandle ,</span><br><span class="line">		<span class="built_in">FGameplayTag</span>() ,</span><br><span class="line">		AbilitySystemComponent-&gt;ScopedPredictionKey);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 3. 回调传递数据给GA</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">ShouldBroadcastAbilityTaskDelegates</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		ValidData.<span class="built_in">Broadcast</span>(DataHandle);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UTargetDataUnderMouse::OnTargetDataReplicatedCallback</span><span class="params">(<span class="type">const</span> FGameplayAbilityTargetDataHandle&amp; DataHandle, FGameplayTag ActivationTag)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 1. 消费同步数据，避免重复处理</span></span><br><span class="line">	AbilitySystemComponent-&gt;<span class="built_in">ConsumeClientReplicatedTargetData</span>(<span class="built_in">GetAbilitySpecHandle</span>() , <span class="built_in">GetActivationPredictionKey</span>());</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2. 回调传递同步后的数据给GA</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">ShouldBroadcastAbilityTaskDelegates</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		ValidData.<span class="built_in">Broadcast</span>(DataHandle);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>SystemDesigns</category>
        <category>GAS</category>
      </categories>
      <tags>
        <tag>AbilityTask</tag>
      </tags>
  </entry>
  <entry>
    <title>GameplayTag</title>
    <url>/ue5-blog/2025/12/14/SystemDesigns/GAS/GameplayTag/</url>
    <content><![CDATA[<h1 id="核心总结"><a href="#核心总结" class="headerlink" title="核心总结"></a>核心总结</h1><p>GameplayTag 是 GAS 框架的核心全局标识工具，通过轻量化的标签体系实现“数值映射、信息传递、资产区分、状态&#x2F;类型标记”等核心功能，其核心价值在于全局共识性——当对象间需基于统一标识完成交互时，GameplayTag 是最优选择。</p>
<span id="more"></span>

<h1 id="Tag-的作用"><a href="#Tag-的作用" class="headerlink" title="Tag 的作用"></a>Tag 的作用</h1><p>GAS 框架中 GameplayTag 应用场景灵活且广泛，核心作用可归纳为：</p>
<ol>
<li>数值映射标识：作为变量名标记需修改的属性，如 Set By Caller 机制通过 Tag 关联待修改的属性数值；</li>
<li>信息传递验证：如 Anim Notify 中通过 GameplayEvent 传递 Tag，标识动画蒙太奇（Montage）的特定播放阶段；</li>
<li>资产索引区分：为同类资产（如技能动画）打 Tag，通过 Tag 快速索引目标资产；</li>
<li>状态标记：标记技能&#x2F;角色的状态（如技能锁定、装备中），用于状态校验与逻辑分支判断；</li>
<li>类型标识：区分不同类别（如主动&#x2F;被动技能、火攻&#x2F;雷攻伤害类型），替代枚举实现更灵活的类型管理。</li>
</ol>
<p>GameplayTag 的核心优势是全局通用性，只要两个对象需基于“全局共识的标识”完成交互，即可优先使用 Tag。</p>
<h1 id="Tag-的创建"><a href="#Tag-的创建" class="headerlink" title="Tag 的创建"></a>Tag 的创建</h1><h2 id="蓝图创建"><a href="#蓝图创建" class="headerlink" title="蓝图创建"></a>蓝图创建</h2><p>进入「Project Settings → GameplayTag」可可视化管理蓝图层面的 Tag：</p>
<ul>
<li>操作便捷，适合快速定义蓝图专属 Tag；</li>
<li>局限性：仅能在蓝图中使用，C++ 代码无法访问。</li>
</ul>
<h2 id="C-端-Native-Tag"><a href="#C-端-Native-Tag" class="headerlink" title="C++ 端 Native Tag"></a>C++ 端 Native Tag</h2><p>通过单例模式注册 Native Tag（单例实现详见<a href="/ue5-blog/2025/12/10/ProgrammingSkills/Singleton">这里</a>），需将 Tag 注册到自定义 AssetManager 并配置生效：</p>
<h3 id="1-自定义-AssetManager-注册-Tag"><a href="#1-自定义-AssetManager-注册-Tag" class="headerlink" title="1. 自定义 AssetManager 注册 Tag"></a>1. 自定义 AssetManager 注册 Tag</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GAS_Custom_API</span> UCustomAssetManager : <span class="keyword">public</span> UAssetManager</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">static</span> UCustomAssetManager&amp; <span class="title">Get</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">StartInitialLoading</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">UCustomAssetManager&amp; <span class="title">UCustomAssetManager::Get</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">check</span>(GEngine);</span><br><span class="line"></span><br><span class="line">	UCustomAssetManager* CustomAssetManager = <span class="built_in">Cast</span>&lt;UCustomAssetManager&gt;(GEngine-&gt;AssetManager);</span><br><span class="line">	<span class="keyword">return</span> * CustomAssetManager;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UCustomAssetManager::StartInitialLoading</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Super::<span class="built_in">StartInitialLoading</span>();</span><br><span class="line"></span><br><span class="line">	FCustomGameplayTags::<span class="built_in">InitializeNativeGameplayTags</span>();</span><br><span class="line">	<span class="comment">// 初始化 GAS 全局数据</span></span><br><span class="line">	UAbilitySystemGlobals::<span class="built_in">Get</span>().<span class="built_in">InitGlobalData</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-修改项目配置文件"><a href="#2-修改项目配置文件" class="headerlink" title="2. 修改项目配置文件"></a>2. 修改项目配置文件</h3><p>打开「Config&#x2F;DefaultEngine.ini」，找到「[&#x2F;Script&#x2F;Engine.Engine]」节点，添加如下配置指定自定义 AssetManager：<br>AssetManagerClassName&#x3D;&#x2F;Script&#x2F;ProjectName.CustomAssetManager</p>
]]></content>
      <categories>
        <category>SystemDesigns</category>
        <category>GAS</category>
      </categories>
      <tags>
        <tag>GAS</tag>
        <tag>GameplayTag</tag>
      </tags>
  </entry>
  <entry>
    <title>GameplayEvent</title>
    <url>/ue5-blog//2025/12/12/GAS-GameplayEvent/</url>
    <content><![CDATA[<h1 id="核心总结"><a href="#核心总结" class="headerlink" title="核心总结"></a>核心总结</h1><p>GameplayEvent 是 GAS 框架中类委托（Delegate）的消息传递机制，核心作用是实现对象间的事件通知与数据传递：通过自定义事件标签发送包含数据的事件，Actor 所拥有的 GameplayAbility（GA）可通过 <code>WaitGameplayEvent</code> 监听并响应事件，相比普通委托，它是定制化的消息管道，专用于 GAS 体系内的事件交互。</p>
<span id="more"></span>

<h1 id="GameplayEvent-的作用"><a href="#GameplayEvent-的作用" class="headerlink" title="GameplayEvent 的作用"></a>GameplayEvent 的作用</h1><p>GameplayEvent 功能上与委托（Delegate）相似，核心用于<strong>对象间的事件通知与数据传递</strong>：当一个对象需要触发另一个对象执行特定逻辑时，可发送带有自定义标签的 GameplayEvent，并在事件中承载数据供接收方处理。</p>
<p>其与普通委托的核心区别在于：GameplayEvent 是 GAS 体系下的定制化消息管道，事件会发送至目标 Actor，该 Actor 挂载的 GA 可通过 <code>WaitGameplayEvent</code> 节点&#x2F;函数监听并捕获对应事件，适配 GAS 框架的能力体系设计。</p>
<h1 id="GameplayEvent-的使用"><a href="#GameplayEvent-的使用" class="headerlink" title="GameplayEvent 的使用"></a>GameplayEvent 的使用</h1><p>以下通过两个典型场景，说明 GameplayEvent 的发送、接收及数据传递方式：</p>
<h2 id="场景1：来自动画的通知（无数据传递）"><a href="#场景1：来自动画的通知（无数据传递）" class="headerlink" title="场景1：来自动画的通知（无数据传递）"></a>场景1：来自动画的通知（无数据传递）</h2><p>以火球技能（GA_FireBolt）为例，需求是“角色动画播放到指定帧时，生成并释放火球”，核心流程如下：</p>
<ol>
<li><strong>插入动画通知</strong>：在火球技能对应的动画蒙太奇（Montage）中，在目标时间点插入 Anim_Notify，绑定事件标签 <code>Event.Montage.FireBolt</code>；</li>
<li><strong>发送 GameplayEvent</strong>：在该 Anim_Notify 的逻辑中，向角色 Actor 发送带有 <code>Event.Montage.FireBolt</code> 标签的 GameplayEvent（无额外数据）；<br><img src="/ue5-blog/2025/12/12/GAS-GameplayEvent/GameplayEvent_1.png" alt="alt text"></li>
<li><strong>监听并响应事件</strong>：在 GA_FireBolt 中播放动画蒙太奇的同时，启用 <code>WaitGameplayEvent</code> 监听 <code>Event.Montage.FireBolt</code> 标签；一旦捕获到该事件，即判定动画播放至指定时机，执行火球生成与释放逻辑。<br><img src="/ue5-blog/2025/12/12/GAS-GameplayEvent/GameplayEvent_2.png" alt="alt text"></li>
</ol>
<h2 id="场景2：使用属性点增加属性（带数据传递）"><a href="#场景2：使用属性点增加属性（带数据传递）" class="headerlink" title="场景2：使用属性点增加属性（带数据传递）"></a>场景2：使用属性点增加属性（带数据传递）</h2><p>需求是“消耗1个属性点，提升指定属性数值”，需实现<strong>带数据的事件发送</strong>与<strong>持续监听的事件接收</strong>，核心分为发送、接收两步：</p>
<h3 id="步骤1：发送-GameplayEvent（带Payload数据）"><a href="#步骤1：发送-GameplayEvent（带Payload数据）" class="headerlink" title="步骤1：发送 GameplayEvent（带Payload数据）"></a>步骤1：发送 GameplayEvent（带Payload数据）</h3><p>与无数据传递的场景不同，需将“提升的属性标签”“提升数值”封装到 <code>FGameplayEventData</code>（Payload）中，再发送事件：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UCustomAbilitySystemComponent::ServerUpgradeAttribute_Implementation</span><span class="params">(<span class="type">const</span> FGameplayTag&amp; AttributeTag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	FGameplayEventData Payload;</span><br><span class="line">	Payload.EventTag = AttributeTag;</span><br><span class="line">	Payload.EventMagnitude = <span class="number">1.f</span>;</span><br><span class="line"></span><br><span class="line">	UAbilitySystemBlueprintLibrary::<span class="built_in">SendGameplayEventToActor</span>(<span class="built_in">GetAvatarActor</span>() , AttributeTag , Payload);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">GetAvatarActor</span>()-&gt;<span class="built_in">Implements</span>&lt;UPlayerInterface&gt;())</span><br><span class="line">	&#123;</span><br><span class="line">		IPlayerInterface::<span class="built_in">Execute_AddToAttributePoints</span>(<span class="built_in">GetAvatarActor</span>() , <span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="步骤2：接收-GameplayEvent（持续监听）"><a href="#步骤2：接收-GameplayEvent（持续监听）" class="headerlink" title="步骤2：接收 GameplayEvent（持续监听）"></a>步骤2：接收 GameplayEvent（持续监听）</h3><p>GameplayEvent 的接收端固定为 GA，需为玩家角色配置一个全程激活的 GA（如 GA_ListenForEvent），核心逻辑：</p>
<ol>
<li>持续通过 <code>WaitGameplayEvent</code> 监听属性提升相关事件，捕获“待修改属性标签”“提升数值”；</li>
<li>基于通用 GE 模板类（GE_ListenForEvent）制作 GE 实例，修改目标属性数值。</li>
</ol>
<h4 id="GE-模板类（GE-ListenForEvent）设计"><a href="#GE-模板类（GE-ListenForEvent）设计" class="headerlink" title="GE 模板类（GE_ListenForEvent）设计"></a>GE 模板类（GE_ListenForEvent）设计</h4><p>为减少 GE 资源开销，仅创建一个通用 GE 模板类，包含所有可提升属性的 Modifier，通过 Set By Caller 传递数值：</p>
<ul>
<li>为每个可修改属性创建对应的 Modifier；</li>
<li>无需修改的属性传入 0 值，仅对目标属性传入有效数值。</li>
</ul>
<h4 id="设计说明"><a href="#设计说明" class="headerlink" title="设计说明"></a>设计说明</h4><p>优先在单个 GE 中包含多属性 Modifier，而非创建多个专用 GE：</p>
<ul>
<li>优势：GE 是包含 Context 的重量级资源，单个通用 GE 可大幅减少资源开销（本场景中 Context 无实际作用）；</li>
<li>劣势：每次构建 GE 需遍历所有 Modifier 并填充 Set By Caller 数值，但因可修改属性数量有限，性能损耗可忽略。</li>
</ul>
]]></content>
      <categories>
        <category>SystemDesigns</category>
        <category>GAS</category>
      </categories>
      <tags>
        <tag>GAS</tag>
        <tag>GameplayEvent</tag>
      </tags>
  </entry>
  <entry>
    <title>GameplayCue (GC)</title>
    <url>/ue5-blog/2025/12/14/SystemDesigns/GAS/GameplayCue/</url>
    <content><![CDATA[<h1 id="核心总结"><a href="#核心总结" class="headerlink" title="核心总结"></a>核心总结</h1><p>GameplayCue（GC）是 GAS 框架中实现技能视听效果的核心组件，专门承接 GA 中非数值逻辑的视听表现（如粒子、音效、镜头震动），核心优势为“解耦视听效果与属性计算逻辑”“自动支持网络同步”，并提供不同类型的 GC 适配瞬间&#x2F;持续等不同视听场景。</p>
<span id="more"></span>

<h1 id="为什么要用-GameplayCue"><a href="#为什么要用-GameplayCue" class="headerlink" title="为什么要用 GameplayCue"></a>为什么要用 GameplayCue</h1><p>GA（GameplayAbility）的核心功能分为两类：一是通过 GE 实现属性数值变化（如伤害、回血）；二是呈现技能配套的视听效果，后者通常由 GameplayCue 实现。</p>
<p>使用 GameplayCue 的核心优势：</p>
<ol>
<li>解耦视听表现与核心逻辑计算，便于单独调试、修改视听效果；</li>
<li>内置网络复制逻辑，无需手动处理多客户端视听同步。</li>
</ol>
<h1 id="GameplayCue-的常见用法"><a href="#GameplayCue-的常见用法" class="headerlink" title="GameplayCue 的常见用法"></a>GameplayCue 的常见用法</h1><h2 id="1-GCN-Burst"><a href="#1-GCN-Burst" class="headerlink" title="1. GCN Burst"></a>1. GCN Burst</h2><p>GCN Burst 是高集成度的 GC 类型，专为爆炸、冲击等瞬时视听效果设计，可直接在蓝图中配置 Burst Particles（爆炸粒子）、Burst Sounds（爆炸音效）、Burst Camera Shake（镜头震动）等资产，并绑定专属 Tag。</p>
<h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><p>在 GA 合适位置调用 <code>Execute GameplayCueWithParams On Owner</code> 函数，传递关键参数（通常仅需位置信息）即可触发：<br><img src="/ue5-blog/2025/12/14/SystemDesigns/GAS/GameplayCue/image.png" alt="alt text"></p>
<h3 id="关键注意点"><a href="#关键注意点" class="headerlink" title="关键注意点"></a>关键注意点</h3><ul>
<li>GC 并非通过类型引用匹配，而是通过 Tag 关联，同一 Tag 可绑定多个 GC，一次 Execute 会触发所有绑定该 Tag 的 GC 逻辑；</li>
<li>Tag 必须以 <code>GameplayCue.</code> 为前缀（如 <code>GameplayCue.FireBall</code>），所有类型 GC 均通过该规则匹配。</li>
</ul>
<h2 id="2-GameplayCue-Notify-Static"><a href="#2-GameplayCue-Notify-Static" class="headerlink" title="2. GameplayCue Notify Static"></a>2. GameplayCue Notify Static</h2><p>该类型 GC 同样用于瞬时视听效果，是更底层的实现类，相比 GCN Burst 自由度更高——GCN Burst 的粒子、音效等资产为硬编码配置，而 Static 可基于传入参数动态选择资产。</p>
<h3 id="典型场景（动态血液效果）"><a href="#典型场景（动态血液效果）" class="headerlink" title="典型场景（动态血液效果）"></a>典型场景（动态血液效果）</h3><p>需求：击中不同类型敌人时，显示对应颜色的血液粒子，实现步骤：</p>
<ol>
<li>将敌人类 Actor 作为参数传入 GC；</li>
<li>在敌人类&#x2F;相关接口中，实现“根据敌人类型匹配对应血液粒子系统”的函数；</li>
<li>重写 GC 的 <code>OnExecute</code> 函数，调用上述函数获取粒子系统并生成。</li>
</ol>
<h3 id="使用方式-1"><a href="#使用方式-1" class="headerlink" title="使用方式"></a>使用方式</h3><p>与 GCN Burst 一致，在 GA 中调用 <code>Execute GameplayCueWithParams On Owner</code> 并传递自定义参数即可；参数类型无限制，支持在 GC 中实现复杂逻辑。</p>
<h3 id="网络同步"><a href="#网络同步" class="headerlink" title="网络同步"></a>网络同步</h3><p>瞬时类 GC 的网络同步由框架自动封装，无需手动处理，确保多客户端看到的视听效果一致。</p>
<h2 id="3-GameplayCue-Notify-Actor"><a href="#3-GameplayCue-Notify-Actor" class="headerlink" title="3. GameplayCue Notify Actor"></a>3. GameplayCue Notify Actor</h2><p>该类型 GC 生成的对象以 Actor 形式存在，拥有独立生命周期，适用于持续型视听效果（如持续灼烧粒子、光环音效）。</p>
<h3 id="使用方式-2"><a href="#使用方式-2" class="headerlink" title="使用方式"></a>使用方式</h3><ul>
<li>启用 GC：调用 <code>AddGameplayCueOnActor</code> 函数，通过 Tag 匹配 GC 并传入自定义参数；</li>
<li>停用 GC：调用 <code>RemoveGameplayCueOnActor</code> 函数，需传入与启用时一致的 Tag 和参数（因此 GA 中需保存传入 GC 的参数）。</li>
</ul>
<h3 id="核心实现逻辑"><a href="#核心实现逻辑" class="headerlink" title="核心实现逻辑"></a>核心实现逻辑</h3><p>持续型 GC 的多客户端管理由 Server 主导：Server 判断客户端是否与该 GC 相关，仅向相关客户端同步视听效果，无关时停止同步。需重写两个核心函数：</p>
<ol>
<li><code>OnBecomeRelevant</code>：实现视听效果的生成逻辑（如创建粒子组件、播放循环音效）；</li>
<li><code>OnCeaseRelevant</code>：实现视听效果的停止逻辑（如销毁粒子组件、停止音效），需将生成的组件保存为变量，以便此处销毁。</li>
</ol>
<h3 id="优化技巧"><a href="#优化技巧" class="headerlink" title="优化技巧"></a>优化技巧</h3><p>销毁音效时直接删除组件会导致效果突兀，可调用 <code>FadeOut</code> 函数让音效渐变消失，提升体验。</p>
<h3 id="额外配置（多-GC-启用场景）"><a href="#额外配置（多-GC-启用场景）" class="headerlink" title="额外配置（多 GC 启用场景）"></a>额外配置（多 GC 启用场景）</h3><p>若需同时启用大量持续型 GC，需提升项目 RPC 容量，避免同步卡顿：<br>打开 <code>config/DefaultGame.ini</code>，修改如下配置（默认值为 3）：<br>[ConsoleVariables]<br>net.MaxRPCPerNetUpdate&#x3D;10</p>
]]></content>
      <categories>
        <category>SystemDesigns</category>
        <category>GAS</category>
      </categories>
      <tags>
        <tag>GAS</tag>
        <tag>GC</tag>
      </tags>
  </entry>
  <entry>
    <title>Auto Run</title>
    <url>/ue5-blog/2025/12/16/SystemDesigns/Input/AutoRun/</url>
    <content><![CDATA[<h1 id="核心总结"><a href="#核心总结" class="headerlink" title="核心总结"></a>核心总结</h1><p>AutoRun是基于鼠标交互的角色移动功能，包含“跟随移动（鼠标长按）”和“自动移动（鼠标点按）”两种核心形式：前者通过实时追踪鼠标位置实现角色随鼠标移动；后者结合导航系统、Spline组件实现带智能避障的自动寻路，同时支持点击位置粒子提示，兼顾交互体验与路径合理性。</p>
<span id="more"></span>

<h1 id="自动移动与跟随移动"><a href="#自动移动与跟随移动" class="headerlink" title="自动移动与跟随移动"></a>自动移动与跟随移动</h1><p>鼠标引导角色移动是游戏常见交互功能，核心分为两种实现形式，适配不同操作习惯：</p>
<h2 id="1-跟随移动（鼠标长按）"><a href="#1-跟随移动（鼠标长按）" class="headerlink" title="1. 跟随移动（鼠标长按）"></a>1. 跟随移动（鼠标长按）</h2><p>角色随鼠标实时移动，无需复杂寻路算法，核心是每帧获取鼠标位置并引导角色向该位置移动：</p>
<h3 id="核心实现思路"><a href="#核心实现思路" class="headerlink" title="核心实现思路"></a>核心实现思路</h3><ul>
<li>每帧追踪鼠标位置：利用APlayerController内置函数<code>GetHitResultUnderCursor</code>获取鼠标指向的世界位置；</li>
<li>鼠标左键长按时移动：通过<code>AddMovementInput</code>向鼠标位置方向添加移动输入，实现实时跟随。</li>
</ul>
<h3 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ACustomPlayerController::CursorTrace</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> ECollisionChannel TraceChannel = ECC_Visibility;</span><br><span class="line">	<span class="built_in">GetHitResultUnderCursor</span>(TraceChannel , <span class="literal">false</span> , CursorHitResult);</span><br><span class="line">	<span class="keyword">if</span> (!CursorHitResult.bBlockingHit) <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ACustomPlayerController::AbilityInputTagHeld</span><span class="params">(FGameplayTag InputTag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (CursorHitResult.bBlockingHit) CachedDestination = CursorHitResult.ImpactPoint;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (APawn* ControllerPawn = <span class="built_in">GetPawn</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">const</span> FVector WorldDirection = (CachedDestination - ControllerPawn-&gt;<span class="built_in">GetActorLocation</span>()).<span class="built_in">GetSafeNormal</span>();</span><br><span class="line">        ControllerPawn-&gt;<span class="built_in">AddMovementInput</span>(WorldDirection);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-自动移动（鼠标点按）"><a href="#2-自动移动（鼠标点按）" class="headerlink" title="2. 自动移动（鼠标点按）"></a>2. 自动移动（鼠标点按）</h2><p>点按鼠标后角色自动跑向点击位置（非敌人时），支持智能避障，点击位置生成粒子提示，核心依赖导航系统生成路径、Spline组件缓存路径点：</p>
<h3 id="核心实现要点"><a href="#核心实现要点" class="headerlink" title="核心实现要点"></a>核心实现要点</h3><h4 id="（1）路径保存：Spline组件缓存路径点"><a href="#（1）路径保存：Spline组件缓存路径点" class="headerlink" title="（1）路径保存：Spline组件缓存路径点"></a>（1）路径保存：Spline组件缓存路径点</h4><p>用户可能频繁点击更改目的地，通过Spline组件保存当前目的地的路径点，确保路径可动态更新。</p>
<h4 id="（2）移动逻辑：基于Spline组件逐帧移动"><a href="#（2）移动逻辑：基于Spline组件逐帧移动" class="headerlink" title="（2）移动逻辑：基于Spline组件逐帧移动"></a>（2）移动逻辑：基于Spline组件逐帧移动</h4><p>通过Spline组件内置函数获取角色当前位置对应的路径点方向，每帧向该方向移动：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> FVector LocationOnSpline = Spline-&gt;<span class="built_in">FindLocationClosestToWorldLocation</span>(ControlledPawn-&gt;<span class="built_in">GetActorLocation</span>() , ESplineCoordinateSpace::World);</span><br><span class="line"><span class="type">const</span> FVector Direction = Spline-&gt;<span class="built_in">FindDirectionClosestToWorldLocation</span>(LocationOnSpline , ESplineCoordinateSpace::World);</span><br><span class="line">ControlledPawn-&gt;<span class="built_in">AddMovementInput</span>(Direction);</span><br></pre></td></tr></table></figure>

<h4 id="（3）自动移动触发-停止规则"><a href="#（3）自动移动触发-停止规则" class="headerlink" title="（3）自动移动触发&#x2F;停止规则"></a>（3）自动移动触发&#x2F;停止规则</h4><ul>
<li>触发时机：鼠标松开时，若按下时长小于阈值（判定为“点按”）则开启自动移动；</li>
<li>停止时机：再次按下鼠标时，或角色到达目标位置（与目标距离小于阈值）时停止。</li>
</ul>
<h4 id="（4）操作类型区分：计时器判断长按-点按"><a href="#（4）操作类型区分：计时器判断长按-点按" class="headerlink" title="（4）操作类型区分：计时器判断长按&#x2F;点按"></a>（4）操作类型区分：计时器判断长按&#x2F;点按</h4><p>通过计时器<code>FollowTime</code>记录鼠标按下时长，松开时判断时长：小于阈值为“点按”（触发自动移动），大于阈值为“长按”（仅触发跟随移动）。</p>
<h3 id="完整实现代码"><a href="#完整实现代码" class="headerlink" title="完整实现代码"></a>完整实现代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ACustomPlayerController::<span class="built_in">ACustomPlayerController</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// PC需开启复制，确保Server/Client同步，防止作弊</span></span><br><span class="line">	bReplicates = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	Spline = <span class="built_in">CreateDefaultSubobject</span>&lt;USplineComponent&gt;(<span class="string">&quot;Spline&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ACustomPlayerController::PlayerTick</span><span class="params">(<span class="type">float</span> DeltaTime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Super::<span class="built_in">PlayerTick</span>(DeltaTime);</span><br><span class="line">	<span class="built_in">CursorTrace</span>(); <span class="comment">// 每帧追踪鼠标位置</span></span><br><span class="line">	<span class="built_in">AutoRun</span>();     <span class="comment">// 每帧执行自动移动逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ACustomPlayerController::AutoRun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!bAutoRunning) <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span> (APawn* ControlledPawn = <span class="built_in">GetPawn</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 获取角色在Spline上的位置及移动方向</span></span><br><span class="line">		<span class="type">const</span> FVector LocationOnSpline = Spline-&gt;<span class="built_in">FindLocationClosestToWorldLocation</span>(ControlledPawn-&gt;<span class="built_in">GetActorLocation</span>() , ESplineCoordinateSpace::World);</span><br><span class="line">		<span class="type">const</span> FVector Direction = Spline-&gt;<span class="built_in">FindDirectionClosestToWorldLocation</span>(LocationOnSpline , ESplineCoordinateSpace::World);</span><br><span class="line">		ControlledPawn-&gt;<span class="built_in">AddMovementInput</span>(Direction);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 到达目标位置后停止自动移动</span></span><br><span class="line">		<span class="type">const</span> <span class="type">float</span> DistanceToDestination = (LocationOnSpline - CachedDestination).<span class="built_in">Length</span>();</span><br><span class="line">		<span class="keyword">if</span> (DistanceToDestination &lt;= AutoRunAcceptanceRadius)</span><br><span class="line">		&#123;</span><br><span class="line">			bAutoRunning = <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ACustomPlayerController::AbilityInputTagPressed</span><span class="params">(FGameplayTag InputTag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (InputTag.<span class="built_in">MatchesTag</span>(FCustomGameplayTags::<span class="built_in">Get</span>().Input_LMB))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 再次按下鼠标，立即停止自动移动</span></span><br><span class="line">		bAutoRunning = <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ACustomPlayerController::AbilityInputTagHeld</span><span class="params">(FGameplayTag InputTag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 累计鼠标按下时长，区分长按/点按</span></span><br><span class="line">    FollowTime += <span class="built_in">GetWorld</span>()-&gt;<span class="built_in">GetDeltaSeconds</span>();</span><br><span class="line">    <span class="keyword">if</span> (CursorHitResult.bBlockingHit) CachedDestination = CursorHitResult.ImpactPoint;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 鼠标长按仅处理跟随移动，自动移动开关关闭</span></span><br><span class="line">    <span class="keyword">if</span> (APawn* ControllerPawn = <span class="built_in">GetPawn</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">const</span> FVector WorldDirection = (CachedDestination - ControllerPawn-&gt;<span class="built_in">GetActorLocation</span>()).<span class="built_in">GetSafeNormal</span>();</span><br><span class="line">        ControllerPawn-&gt;<span class="built_in">AddMovementInput</span>(WorldDirection);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ACustomPlayerController::AbilityInputTagReleased</span><span class="params">(FGameplayTag InputTag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    APawn* ControlledPawn = <span class="built_in">GetPawn</span>();</span><br><span class="line">    <span class="comment">// 按下时长小于阈值，判定为点按，触发自动移动</span></span><br><span class="line">    <span class="keyword">if</span> (FollowTime &lt;= ShortPressedThreshold &amp;&amp; ControlledPawn)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 点击位置生成粒子提示</span></span><br><span class="line">        UNiagaraFunctionLibrary::<span class="built_in">SpawnSystemAtLocation</span>(<span class="keyword">this</span> , ClickNiagaraSystem , CachedDestination);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 导航系统生成从角色位置到目标位置的路径</span></span><br><span class="line">        <span class="keyword">if</span> (UNavigationPath* NavPath = UNavigationSystemV1::<span class="built_in">FindPathToLocationSynchronously</span>(<span class="keyword">this</span> , ControlledPawn-&gt;<span class="built_in">GetActorLocation</span>() , CachedDestination))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 清空旧路径，缓存新路径点到Spline</span></span><br><span class="line">            Spline-&gt;<span class="built_in">ClearSplinePoints</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">const</span> FVector&amp; PointLoc : NavPath-&gt;PathPoints)</span><br><span class="line">            &#123;</span><br><span class="line">                Spline-&gt;<span class="built_in">AddSplinePoint</span>(PointLoc , ESplineCoordinateSpace::World);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 校验路径有效性，避免空路径导致崩溃</span></span><br><span class="line">            <span class="keyword">if</span> (NavPath-&gt;PathPoints.<span class="built_in">Num</span>() &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                CachedDestination = NavPath-&gt;PathPoints[NavPath-&gt;PathPoints.<span class="built_in">Num</span>() - <span class="number">1</span>];</span><br><span class="line">                bAutoRunning = <span class="literal">true</span>; <span class="comment">// 开启自动移动</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重置按下时长</span></span><br><span class="line">    FollowTime = <span class="number">0.f</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>SystemDesigns</category>
        <category>Input</category>
      </categories>
      <tags>
        <tag>AutoRun</tag>
      </tags>
  </entry>
  <entry>
    <title>数据驱动系统 (DataDriven)</title>
    <url>/ue5-blog/2025/12/15/SystemDesigns/DataDriven/Data/</url>
    <content><![CDATA[<h1 id="核心总结"><a href="#核心总结" class="headerlink" title="核心总结"></a>核心总结</h1><p>数据驱动系统是复杂游戏系统的核心支撑，通过CurveTable（曲线表）、DataAsset（数据资产）等工具实现游戏数据的集中统一管理，替代C++硬编码和分散的蓝图配置模式，大幅提升数据维护效率与系统扩展性。</p>
<span id="more"></span>

<h1 id="数据管理的核心思路"><a href="#数据管理的核心思路" class="headerlink" title="数据管理的核心思路"></a>数据管理的核心思路</h1><p>复杂游戏系统需大量数据填充（如技能数值、敌人属性、UI配置），若数据通过C++硬编码或分散在各蓝图类中修改，会导致维护成本高、调整效率低；数据驱动的核心目标是建立<strong>集中、统一的数据源</strong>，实现数据与逻辑解耦。</p>
<h2 id="1-Curve-Table"><a href="#1-Curve-Table" class="headerlink" title="1. Curve Table"></a>1. Curve Table</h2><p>CurveTable用于存储“随单一维度（如等级、时间）变化的数值曲线”，一个CurveTable可包含多条独立曲线，适配需可视化数值走势的场景：</p>
<ul>
<li>核心用法：蓝图中配置ScalableFloat时，可直接关联CurveTable中的指定曲线，实现数值随维度动态调整；</li>
<li>核心优势：<ol>
<li>可视化：曲线直观展示数值走势（如技能伤害随等级提升的增长幅度），便于调优；</li>
<li>集中管理：同类数据（如所有技能的伤害曲线）可汇总在一个CurveTable中，无需逐个打开技能蓝图修改，方便比对和批量调整。</li>
</ol>
</li>
</ul>
<h2 id="2-Data-Asset"><a href="#2-Data-Asset" class="headerlink" title="2. Data Asset"></a>2. Data Asset</h2><p>DataAsset适配“非曲线类数据&#x2F;资源”的管理（如敌人配置、技能附加信息），是比CurveTable更通用的数据集中管理方式：</p>
<h3 id="基础使用方法"><a href="#基础使用方法" class="headerlink" title="基础使用方法"></a>基础使用方法</h3><ol>
<li>C++端自定义继承自<code>DataAsset</code>的类（通常命名为XXXInfo），声明所需的结构体&#x2F;变量（如敌人类型、技能列表、奖励数值）；</li>
<li>新建该类的蓝图实例，在编辑器中填写数据，形成独立的DataAsset资源。</li>
</ol>
<h3 id="DataAsset的管理范围"><a href="#DataAsset的管理范围" class="headerlink" title="DataAsset的管理范围"></a>DataAsset的管理范围</h3><p>原则上，所有“无需与核心逻辑强耦合的配置类数据”都适合放入DataAsset集中管理，替代分散在各蓝图类中的配置方式：</p>
<ul>
<li>典型场景1：敌人配置（类型、拥有技能、死亡奖励）——无需在敌人类蓝图中逐个修改，统一在DA_EnemyInfo中配置，便于全局调整；</li>
<li>典型场景2：技能附加信息（UI显示图标、解锁等级、描述文本）——GA（GameplayAbility）仅需关注技能执行逻辑，附加信息汇总在DA_AbilityInfo中，降低逻辑与配置的耦合。</li>
</ul>
<h3 id="DataAsset的存放原则"><a href="#DataAsset的存放原则" class="headerlink" title="DataAsset的存放原则"></a>DataAsset的存放原则</h3><p>根据数据重要性区分存储位置，兼顾管理便捷性与安全性：</p>
<ol>
<li>非核心数据（如UI属性名称、显示数值映射）：可存放于WidgetController等客户端逻辑类中，不影响核心玩法；</li>
<li>核心数据（如敌人技能列表、技能解锁等级、数值阈值）：必须存放于<code>GameMode</code>中——GameMode仅存在于服务端，客户端无法访问，可有效避免玩家作弊，保证数据权威性。</li>
</ol>
]]></content>
      <categories>
        <category>SystemDesigns</category>
        <category>DataDriven</category>
      </categories>
      <tags>
        <tag>DataAsset</tag>
        <tag>DataTable</tag>
      </tags>
  </entry>
  <entry>
    <title>SpawnVolume and SpawnPoint</title>
    <url>/ue5-blog/2025/12/17/SystemDesigns/Levels/SpawnVolume/</url>
    <content><![CDATA[<h1 id="核心总结"><a href="#核心总结" class="headerlink" title="核心总结"></a>核心总结</h1><p>SpawnVolume（生成体积）与SpawnPoint（生成点）是关卡中动态生成敌人的核心组件：SpawnVolume通过盒体重叠检测触发敌人生成逻辑，结合存档功能避免已探索区域重复生成敌人；SpawnPoint精准定义敌人的生成位置、类型、等级等信息，二者配合实现关卡内敌人群体的可控生成。</p>
<span id="more"></span>

<h1 id="动态生成敌人（SpawnVolume-SpawnPoint）"><a href="#动态生成敌人（SpawnVolume-SpawnPoint）" class="headerlink" title="动态生成敌人（SpawnVolume + SpawnPoint）"></a>动态生成敌人（SpawnVolume + SpawnPoint）</h1><p>关卡设计中需实现“玩家进入指定区域触发敌人生成”的逻辑，核心依赖SpawnVolume（触发区域）和SpawnPoint（生成点位）两个组件分工协作：</p>
<h2 id="1-SpawnVolume（生成触发体积）"><a href="#1-SpawnVolume（生成触发体积）" class="headerlink" title="1. SpawnVolume（生成触发体积）"></a>1. SpawnVolume（生成触发体积）</h2><p>SpawnVolume是触发敌人生成的核心载体，核心功能包括：</p>
<ul>
<li>盒体碰撞检测：玩家与盒体重叠时，按关联SpawnPoint的配置生成敌人；</li>
<li>存档标记：记录区域是否已探索，加载关卡时避免重复生成敌人。</li>
</ul>
<h3 id="核心代码实现"><a href="#核心代码实现" class="headerlink" title="核心代码实现"></a>核心代码实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GAS_Custom_API</span> ACustomEnemySpawnVolume : <span class="keyword">public</span> AActor , <span class="keyword">public</span> ISaveInterface</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">GENERATED_BODY</span>()</span><br><span class="line">	</span><br><span class="line"><span class="keyword">public</span>:	</span><br><span class="line">	<span class="built_in">ACustomEnemySpawnVolume</span>();</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">LoadActor_Implementation</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// SaveGame标记：该变量会被存档系统保存</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(BlueprintReadOnly , SaveGame)</span><br><span class="line">	<span class="type">bool</span> bReached = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">BeginPlay</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">UFUNCTION</span>()</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">OnBoxOverlap</span><span class="params">(UPrimitiveComponent* OverlappedComponent , AActor* OtherActor , UPrimitiveComponent* OtherComp , int32 OtherBodyIndex , <span class="type">bool</span> bFromSweep ,<span class="type">const</span> FHitResult&amp; SweepResult)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// EditAnywhere：允许在关卡编辑器中编辑，关联生成点列表</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(EditAnywhere)</span><br><span class="line">	TArray&lt;ACustomEnemySpawnPoint*&gt; SpawnPoints;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">UPROPERTY</span>(VisibleAnywhere)</span><br><span class="line">	TObjectPtr&lt;UBoxComponent&gt; Box;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ACustomEnemySpawnVolume::<span class="built_in">ACustomEnemySpawnVolume</span>()</span><br><span class="line">&#123;</span><br><span class="line">	PrimaryActorTick.bCanEverTick = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	Box = <span class="built_in">CreateDefaultSubobject</span>&lt;UBoxComponent&gt;(<span class="string">&quot;Box&quot;</span>);</span><br><span class="line">	<span class="built_in">SetRootComponent</span>(Box);</span><br><span class="line">	<span class="comment">// 配置盒体碰撞：仅检测重叠，忽略其他碰撞响应</span></span><br><span class="line">	Box-&gt;<span class="built_in">SetCollisionEnabled</span>(ECollisionEnabled::QueryOnly);</span><br><span class="line">	Box-&gt;<span class="built_in">SetCollisionObjectType</span>(ECC_WorldStatic);</span><br><span class="line">	Box-&gt;<span class="built_in">SetCollisionResponseToAllChannels</span>(ECR_Ignore);</span><br><span class="line">	Box-&gt;<span class="built_in">SetCollisionResponseToChannel</span>(ECC_Pawn , ECR_Overlap);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ACustomEnemySpawnVolume::LoadActor_Implementation</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 已探索区域加载时直接销毁，避免重复生成</span></span><br><span class="line">	<span class="keyword">if</span> (bReached)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">Destroy</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ACustomEnemySpawnVolume::BeginPlay</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Super::<span class="built_in">BeginPlay</span>();</span><br><span class="line">	<span class="comment">// 绑定盒体重叠事件</span></span><br><span class="line">	Box-&gt;OnComponentBeginOverlap.<span class="built_in">AddDynamic</span>(<span class="keyword">this</span> , &amp;ACustomEnemySpawnVolume::OnBoxOverlap);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ACustomEnemySpawnVolume::OnBoxOverlap</span><span class="params">(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor,</span></span></span><br><span class="line"><span class="params"><span class="function">	UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, <span class="type">bool</span> bFromSweep, <span class="type">const</span> FHitResult&amp; SweepResult)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 仅对玩家触发生成逻辑</span></span><br><span class="line">	<span class="keyword">if</span> (!OtherActor-&gt;<span class="built_in">Implements</span>&lt;UPlayerInterface&gt;()) <span class="keyword">return</span>;</span><br><span class="line">	</span><br><span class="line">	bReached = <span class="literal">true</span>; <span class="comment">// 标记为已探索</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 遍历所有关联的生成点，执行敌人生成</span></span><br><span class="line">	<span class="keyword">for</span> (ACustomEnemySpawnPoint* Point : SpawnPoints)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">IsValid</span>(Point))</span><br><span class="line">		&#123;</span><br><span class="line">			Point-&gt;<span class="built_in">SpawnEnemy</span>();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 关闭盒体碰撞，避免重复触发</span></span><br><span class="line">	Box-&gt;<span class="built_in">SetCollisionEnabled</span>(ECollisionEnabled::NoCollision);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-SpawnPoint（生成点位）"><a href="#2-SpawnPoint（生成点位）" class="headerlink" title="2. SpawnPoint（生成点位）"></a>2. SpawnPoint（生成点位）</h2><p>SpawnPoint继承自ATargetPoint，核心作用是定义敌人生成的具体信息：位置、敌人类型、等级、职业等，生成时需为敌人绑定AIController确保AI逻辑生效。</p>
<h3 id="核心代码实现-1"><a href="#核心代码实现-1" class="headerlink" title="核心代码实现"></a>核心代码实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GAS_Custom_API</span> ACustomEnemySpawnPoint : <span class="keyword">public</span> ATargetPoint</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintCallable)</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">SpawnEnemy</span><span class="params">()</span></span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 可在编辑器配置：生成的敌人类型</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(EditAnywhere , BlueprintReadOnly , Category = <span class="string">&quot;Enemy Class&quot;</span>)</span><br><span class="line">	TSubclassOf&lt;ACustomEnemy&gt; EnemyClass;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 可在编辑器配置：敌人等级</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(EditAnywhere , BlueprintReadOnly , Category = <span class="string">&quot;Enemy Class&quot;</span>)</span><br><span class="line">	int32 EnemyLevel = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 可在编辑器配置：敌人职业类型</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(EditAnywhere , BlueprintReadOnly , Category = <span class="string">&quot;Enemy Class&quot;</span>)</span><br><span class="line">	ECharacterClass CharacterClass = ECharacterClass::Warrior;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ACustomEnemySpawnPoint::SpawnEnemy</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	FActorSpawnParameters SpawnParams;</span><br><span class="line">	<span class="comment">// 碰撞处理：尽可能调整位置，确保敌人必生成</span></span><br><span class="line">	SpawnParams.SpawnCollisionHandlingOverride = ESpawnActorCollisionHandlingMethod::AdjustIfPossibleButAlwaysSpawn;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 延迟生成敌人，先配置属性再完成生成</span></span><br><span class="line">	ACustomEnemy* Enemy = <span class="built_in">GetWorld</span>()-&gt;<span class="built_in">SpawnActorDeferred</span>&lt;ACustomEnemy&gt;(EnemyClass , <span class="built_in">GetActorTransform</span>());</span><br><span class="line">	Enemy-&gt;<span class="built_in">SetLevel</span>(EnemyLevel);</span><br><span class="line">	Enemy-&gt;<span class="built_in">SetCharacterClass</span>(CharacterClass);</span><br><span class="line">	Enemy-&gt;<span class="built_in">FinishSpawning</span>(<span class="built_in">GetActorTransform</span>());</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 生成默认控制器，在内部会调用PossedBy函数，通常在那里修改了控制器为AIController</span></span><br><span class="line">	Enemy-&gt;<span class="built_in">SpawnDefaultController</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>SystemDesigns</category>
        <category>Levels</category>
      </categories>
      <tags>
        <tag>SpawnVolume</tag>
        <tag>SpawnPoint</tag>
      </tags>
  </entry>
  <entry>
    <title>EnhancedInput</title>
    <url>/ue5-blog/2025/12/16/SystemDesigns/Input/EnhancedInput/</url>
    <content><![CDATA[<h1 id="核心总结"><a href="#核心总结" class="headerlink" title="核心总结"></a>核心总结</h1><p>EnhancedInput是UE官方的新一代输入框架，核心优势是<strong>解耦设备输入、输入行为、游戏逻辑</strong>，通过Input Mapping Context（IMC，输入映射上下文）、Input Action（IA，输入行为）、自定义回调函数三层结构，实现灵活的输入绑定与管理，适配多设备、多场景的输入需求。</p>
<span id="more"></span>

<h1 id="前置准备：开启EnhancedInput"><a href="#前置准备：开启EnhancedInput" class="headerlink" title="前置准备：开启EnhancedInput"></a>前置准备：开启EnhancedInput</h1><p>使用EnhancedInput需先在项目中启用并配置核心模块：</p>
<ol>
<li>在项目<code>Build.cs</code>中添加<code>EnhancedInput</code>模块依赖：<code>PublicDependencyModuleNames.Add(&quot;EnhancedInput&quot;);</code>；</li>
<li>在Project Settings → Input中，最下方将「Default Input Component Class」切换为「EnhancedInputCmponent」或者自定义增强输入组件，确保框架生效。</li>
</ol>
<h1 id="输入系统的设计"><a href="#输入系统的设计" class="headerlink" title="输入系统的设计"></a>输入系统的设计</h1><p>EnhancedInput的核心是将“设备物理输入”“抽象输入行为”“游戏逻辑回调”三者解耦，关键核心要素为IA、IMC，以及自定义的InputConfig（输入配置）：</p>
<h2 id="1-Input-Action-IA-：抽象输入行为载体"><a href="#1-Input-Action-IA-：抽象输入行为载体" class="headerlink" title="1. Input Action (IA)：抽象输入行为载体"></a>1. Input Action (IA)：抽象输入行为载体</h2><p>IA是EnhancedInput的核心抽象层，<strong>仅定义输入行为的类型，不绑定设备输入或游戏逻辑</strong>，可理解为“输入操作的标准化标识”：</p>
<ul>
<li>核心配置：仅需设置<code>Value Type</code>（输入值类型），决定输入行为的数值表达形式（即输入自由度）：<ul>
<li>Axis1D（默认）：映射为float值，常用于按键按下&#x2F;松开（当作bool使用）、单轴移动等；</li>
<li>Axis2D：映射为FVector2D，适配平面移动（如WSAD）、鼠标摇杆等二维输入；</li>
</ul>
</li>
<li>核心特性：IA是设备输入与游戏逻辑的“中间桥梁”，后续需分别与IMC（设备绑定）、InputComponent（逻辑绑定）关联。</li>
</ul>
<h2 id="2-Input-Mapping-Context-IMC-：设备输入与IA的绑定层"><a href="#2-Input-Mapping-Context-IMC-：设备输入与IA的绑定层" class="headerlink" title="2. Input Mapping Context (IMC)：设备输入与IA的绑定层"></a>2. Input Mapping Context (IMC)：设备输入与IA的绑定层</h2><p>IMC是EnhancedInput中<strong>绑定物理设备输入与IA</strong>的核心载体（专属EnhancedInput的核心配置），可灵活配置单&#x2F;多设备输入映射：</p>
<ul>
<li>基础绑定：普通输入（如技能释放、跳跃）可直接将设备按键（如鼠标左键、键盘E）绑定到对应IA；</li>
<li>复杂输入（二维移动）：需通过<code>Modifier</code>（修饰符）调整输入值，以WSAD绑定Axis2D类型IA为例：<ul>
<li>D键：无Modifier，映射为X轴正方向；</li>
<li>A键：添加Modifier「Negate」，映射为X轴负方向；</li>
<li>W键：添加Modifier「Swizzle Input Axis Value」，将X轴映射为Y轴正方向；</li>
<li>S键：添加Modifier「Negate + Swizzle Input Axis Value」，将X轴映射为Y轴负方向。</li>
</ul>
</li>
</ul>
<h2 id="3-InputConfig：输入配置的集中管理（自定义DataAsset）"><a href="#3-InputConfig：输入配置的集中管理（自定义DataAsset）" class="headerlink" title="3. InputConfig：输入配置的集中管理（自定义DataAsset）"></a>3. InputConfig：输入配置的集中管理（自定义DataAsset）</h2><p>InputConfig是基于<code>DataAsset</code>的自定义配置类，用于集中管理“IA与游戏内标识（GameplayTag）”的映射关系（适配GAS等系统的Tag化管理）：</p>
<ul>
<li>核心结构体定义（C++）：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">USTRUCT</span>(BlueprintType)</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">FCustomInputAction</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(EditDefaultsOnly)</span><br><span class="line">	<span class="type">const</span> <span class="keyword">class</span> <span class="title class_">UInputAction</span>* InputAction = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(EditDefaultsOnly)</span><br><span class="line">	FGameplayTag InputTag = <span class="built_in">FGameplayTag</span>();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>核心作用：将IA与技能槽位、输入状态等GameplayTag绑定，让游戏逻辑通过Tag识别输入行为（而非直接依赖IA），提升扩展性。</li>
</ul>
<h1 id="输入系统的具体设置"><a href="#输入系统的具体设置" class="headerlink" title="输入系统的具体设置"></a>输入系统的具体设置</h1><p>完成IA、IMC、InputConfig的定义后，需通过<code>UEnhancedInputComponent</code>（EnhancedInput专属输入组件）完成IA与游戏逻辑的绑定，核心管理载体为PlayerController（输入逻辑的核心入口）。</p>
<h2 id="1-基础绑定：通过UEnhancedInputComponent绑定简单输入"><a href="#1-基础绑定：通过UEnhancedInputComponent绑定简单输入" class="headerlink" title="1. 基础绑定：通过UEnhancedInputComponent绑定简单输入"></a>1. 基础绑定：通过UEnhancedInputComponent绑定简单输入</h2><p>PlayerController的<code>SetupInputComponent</code>是输入绑定的核心入口，需将IA与回调函数绑定（依赖EnhancedInput的<code>BindAction</code>方法）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ACustomPlayerController::SetupInputComponent</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Super::<span class="built_in">SetupInputComponent</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 强转为EnhancedInput专属组件（开启EnhancedInput后默认生成）</span></span><br><span class="line">	UEnhancedInputComponent* EnhancedInputComp = <span class="built_in">Cast</span>&lt;UEnhancedInputComponent&gt;(InputComponent);</span><br><span class="line">	<span class="built_in">check</span>(EnhancedInputComp);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 绑定移动输入（Triggered：按住持续触发）</span></span><br><span class="line">	EnhancedInputComp-&gt;<span class="built_in">BindAction</span>(MoveAction , ETriggerEvent::Triggered , <span class="keyword">this</span>, &amp;ACustomPlayerController::Move);</span><br><span class="line">	<span class="comment">// 绑定Shift按键（Started：按下触发；Completed：松开触发）</span></span><br><span class="line">	EnhancedInputComp-&gt;<span class="built_in">BindAction</span>(ShiftAction , ETriggerEvent::Started , <span class="keyword">this</span> , &amp;ACustomPlayerController::ShiftPressed);</span><br><span class="line">	EnhancedInputComp-&gt;<span class="built_in">BindAction</span>(ShiftAction , ETriggerEvent::Completed , <span class="keyword">this</span> , &amp;ACustomPlayerController::ShiftReleased);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="回调函数示例"><a href="#回调函数示例" class="headerlink" title="回调函数示例"></a>回调函数示例</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ACustomPlayerController::ShiftPressed</span><span class="params">()</span></span>&#123;bShiftKeyDown = <span class="literal">true</span>;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ACustomPlayerController::ShiftReleased</span><span class="params">()</span></span>&#123;bShiftKeyDown = <span class="literal">false</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ACustomPlayerController::Move</span><span class="params">(<span class="type">const</span> FInputActionValue&amp; InputActionValue)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 输入阻断：若ASC带有输入锁定Tag，直接返回</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">GetASC</span>() &amp;&amp; <span class="built_in">GetASC</span>()-&gt;<span class="built_in">HasMatchingGameplayTag</span>(FCustomGameplayTags::<span class="built_in">Get</span>().Player_Block_InputPressed))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 获取Axis2D类型的输入值（WSAD映射的FVector2D）</span></span><br><span class="line">	<span class="type">const</span> FVector2D InputAxisVector = InputActionValue.<span class="built_in">Get</span>&lt;FVector2D&gt;();</span><br><span class="line">	<span class="comment">// 基于控制器旋转计算移动方向</span></span><br><span class="line">	<span class="type">const</span> FRotator Rotation = <span class="built_in">GetControlRotation</span>();</span><br><span class="line">	<span class="function"><span class="type">const</span> FRotator <span class="title">YawRotation</span><span class="params">(<span class="number">0.f</span> , Rotation.Yaw , <span class="number">0.f</span>)</span></span>;</span><br><span class="line">	</span><br><span class="line">	<span class="type">const</span> FVector ForwardDirection = <span class="built_in">FRotationMatrix</span>(YawRotation).<span class="built_in">GetUnitAxis</span>(EAxis::X);</span><br><span class="line">	<span class="type">const</span> FVector RightDirection = <span class="built_in">FRotationMatrix</span>(YawRotation).<span class="built_in">GetUnitAxis</span>(EAxis::Y);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 向受控Pawn添加移动输入</span></span><br><span class="line">	<span class="keyword">if</span> (APawn* ControllerPawn = <span class="built_in">GetPawn</span>&lt;APawn&gt;())</span><br><span class="line">	&#123;</span><br><span class="line">		ControllerPawn-&gt;<span class="built_in">AddMovementInput</span>(ForwardDirection , InputAxisVector.Y); <span class="comment">// W/S对应Y轴</span></span><br><span class="line">		ControllerPawn-&gt;<span class="built_in">AddMovementInput</span>(RightDirection , InputAxisVector.X);  <span class="comment">// A/D对应X轴</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="关键注意点"><a href="#关键注意点" class="headerlink" title="关键注意点"></a>关键注意点</h3><ul>
<li><code>ETriggerEvent</code>触发类型：<ul>
<li>Triggered：按住输入时持续触发（适配移动、持续施法等）；</li>
<li>Started：输入按下瞬间触发（适配按键按下响应）；</li>
<li>Completed：输入松开瞬间触发（适配按键松开响应）；</li>
</ul>
</li>
<li>输入值传递：<code>BindAction</code>会根据IA的<code>Value Type</code>自动向回调函数传递<code>FInputActionValue</code>参数，可通过<code>Get&lt;T&gt;()</code>解析为对应类型。</li>
</ul>
<h2 id="2-复杂绑定：自定义EnhancedInputComponent封装批量绑定"><a href="#2-复杂绑定：自定义EnhancedInputComponent封装批量绑定" class="headerlink" title="2. 复杂绑定：自定义EnhancedInputComponent封装批量绑定"></a>2. 复杂绑定：自定义EnhancedInputComponent封装批量绑定</h2><p>对于技能输入等需批量绑定的场景，可自定义<code>UCustomInputComponent</code>（继承<code>UEnhancedInputComponent</code>），通过模板封装批量绑定逻辑（适配IA与GameplayTag的映射）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GAS_Custom_API</span> UCustomInputComponent : <span class="keyword">public</span> UEnhancedInputComponent</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 模板函数：批量绑定技能输入（按下/松开/按住）</span></span><br><span class="line">	<span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> UserClass , <span class="keyword">typename</span> PressedFuncType , <span class="keyword">typename</span> ReleasedFuncType , <span class="keyword">typename</span> HeldFuncType&gt;</span></span><br><span class="line"><span class="function">	<span class="type">void</span> <span class="title">BindAbilityActions</span><span class="params">(<span class="type">const</span> UCustomConfigInput* InputConfig , UserClass* Object , PressedFuncType PressedFunc , ReleasedFuncType ReleasedFunc , HeldFuncType HeldFunc)</span></span>;</span><br><span class="line">	</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">UserClass</span>, <span class="keyword">typename</span> PressedFuncType, <span class="keyword">typename</span> ReleasedFuncType, <span class="keyword">typename</span> HeldFuncType&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UCustomInputComponent::BindAbilityActions</span><span class="params">(<span class="type">const</span> UCustomConfigInput* InputConfig, UserClass* Object,</span></span></span><br><span class="line"><span class="params"><span class="function">	PressedFuncType PressedFunc, ReleasedFuncType ReleasedFunc, HeldFuncType HeldFunc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">check</span>(InputConfig);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 遍历InputConfig中的IA-Tag映射，批量绑定</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">const</span> FCustomInputAction&amp; Action : InputConfig-&gt;AbilityInputActions)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (Action.InputAction &amp;&amp; Action.InputTag.<span class="built_in">IsValid</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// 按下触发：传递GameplayTag给回调函数</span></span><br><span class="line">			<span class="keyword">if</span> (PressedFunc)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">BindAction</span>(Action.InputAction , ETriggerEvent::Started , Object , PressedFunc , Action.InputTag);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 松开触发</span></span><br><span class="line">			<span class="keyword">if</span> (ReleasedFunc)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">BindAction</span>(Action.InputAction , ETriggerEvent::Completed , Object , ReleasedFunc , Action.InputTag);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 按住触发</span></span><br><span class="line">			<span class="keyword">if</span> (HeldFunc)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">BindAction</span>(Action.InputAction , ETriggerEvent::Triggered , Object , HeldFunc , Action.InputTag);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="PlayerController中调用批量绑定"><a href="#PlayerController中调用批量绑定" class="headerlink" title="PlayerController中调用批量绑定"></a>PlayerController中调用批量绑定</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ACustomPlayerController::SetupInputComponent</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Super::<span class="built_in">SetupInputComponent</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 强转为自定义输入组件</span></span><br><span class="line">	UCustomInputComponent* CustomInputComponent = <span class="built_in">CastChecked</span>&lt;UCustomInputComponent&gt;(InputComponent);</span><br><span class="line">	<span class="comment">// 批量绑定技能输入（回调函数接收GameplayTag参数）</span></span><br><span class="line">	CustomInputComponent-&gt;<span class="built_in">BindAbilityActions</span>(InputConfig , <span class="keyword">this</span> , &amp;ThisClass::AbilityInputTagPressed , &amp;ThisClass::AbilityInputTagReleased , &amp;ThisClass::AbilityInputTagHeld);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 技能输入按下回调（传递Tag给ASC处理）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ACustomPlayerController::AbilityInputTagPressed</span><span class="params">(FGameplayTag InputTag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">GetASC</span>()) <span class="built_in">GetASC</span>()-&gt;<span class="built_in">AbilityInputTagPressed</span>(InputTag);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="核心技巧"><a href="#核心技巧" class="headerlink" title="核心技巧"></a>核心技巧</h3><ul>
<li>模板函数：适配任意类型的回调函数，提升绑定逻辑的通用性；</li>
<li>委托参数传递：<code>BindAction</code>支持在回调函数后追加自定义参数（如GameplayTag），底层通过委托封装实现，可在UE源码的<code>BindAction</code>模板定义中验证：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> DelegateType, <span class="keyword">class</span> UserClass, <span class="keyword">typename</span>... VarTypes &gt;</span></span><br><span class="line"><span class="function">FInputActionBinding&amp; <span class="title">BindAction</span><span class="params">(<span class="type">const</span> FName ActionName, <span class="type">const</span> EInputEvent KeyEvent, UserClass* Object, <span class="keyword">typename</span> DelegateType::<span class="keyword">template</span> TMethodPtr&lt; UserClass &gt; Func, VarTypes... Vars)</span> </span>= <span class="keyword">delete</span>;</span><br></pre></td></tr></table></figure>

<h2 id="3-最终步骤：激活IMC（绑定设备输入与PlayerController）"><a href="#3-最终步骤：激活IMC（绑定设备输入与PlayerController）" class="headerlink" title="3. 最终步骤：激活IMC（绑定设备输入与PlayerController）"></a>3. 最终步骤：激活IMC（绑定设备输入与PlayerController）</h2><p>IMC需通过<code>UEnhancedInputLocalPlayerSubsystem</code>添加到LocalPlayer中，才能让PlayerController识别设备输入与IA的绑定关系，核心逻辑在<code>BeginPlay</code>中：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ACustomPlayerController::BeginPlay</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Super::<span class="built_in">BeginPlay</span>();</span><br><span class="line">	<span class="built_in">check</span>(CustomContext); <span class="comment">// CustomContext为编辑器配置的IMC引用</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 获取EnhancedInput本地玩家子系统（专属EnhancedInput的管理类）</span></span><br><span class="line">	UEnhancedInputLocalPlayerSubsystem* Subsystem = ULocalPlayer::<span class="built_in">GetSubsystem</span>&lt;UEnhancedInputLocalPlayerSubsystem&gt;(<span class="built_in">GetLocalPlayer</span>());</span><br><span class="line">	<span class="keyword">if</span> (Subsystem)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 添加IMC，优先级为0（可叠加多个IMC，优先级高的覆盖低的）</span></span><br><span class="line">		Subsystem-&gt;<span class="built_in">AddMappingContext</span>(CustomContext , <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 鼠标配置（可选）</span></span><br><span class="line">	bShowMouseCursor = <span class="literal">true</span>;</span><br><span class="line">	DefaultMouseCursor = EMouseCursor::Default;</span><br><span class="line"></span><br><span class="line">	FInputModeGameAndUI InputModeData;</span><br><span class="line">	InputModeData.<span class="built_in">SetLockMouseToViewportBehavior</span>(EMouseLockMode::DoNotLock);</span><br><span class="line">	InputModeData.<span class="built_in">SetHideCursorDuringCapture</span>(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">SetInputMode</span>(InputModeData);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>SystemDesigns</category>
        <category>Input</category>
      </categories>
      <tags>
        <tag>EnhancedInput</tag>
      </tags>
  </entry>
  <entry>
    <title>CheckPoint</title>
    <url>/ue5-blog/2025/12/18/SystemDesigns/SaveAndLoad/CheckPoint/</url>
    <content><![CDATA[<h1 id="核心总结"><a href="#核心总结" class="headerlink" title="核心总结"></a>核心总结</h1><p>CheckPoint（检查点）是实现游戏自然存档的核心组件，继承自PlayerStart类（作为玩家读档后的潜在出生点），通过存储<code>bReached</code>（是否到达）状态管理存档&#x2F;读档逻辑；玩家通过重叠检测触发存档，读档时根据<code>bReached</code>还原检查点状态并给出视觉反馈，避免存档操作生硬，提升游玩体验。</p>
<span id="more"></span>

<h1 id="CheckPoint（检查点存档）"><a href="#CheckPoint（检查点存档）" class="headerlink" title="CheckPoint（检查点存档）"></a>CheckPoint（检查点存档）</h1><p>游戏中为避免存档操作过于生硬，通常通过CheckPoint（检查点）实现场景化存档，核心设计要点如下：</p>
<h2 id="1-类继承规则"><a href="#1-类继承规则" class="headerlink" title="1. 类继承规则"></a>1. 类继承规则</h2><p>CheckPoint必须继承自PlayerStart类，因为每个检查点都是玩家读档后的潜在初始生成位置；需在场景编辑器中为每个CheckPoint的<code>PlayerStartTag</code>规范命名，确保读档时能精准匹配对应的生成位置。</p>
<h2 id="2-存档数据设计"><a href="#2-存档数据设计" class="headerlink" title="2. 存档数据设计"></a>2. 存档数据设计</h2><p>CheckPoint自身需作为可存档对象，仅存储核心状态变量<code>bReached</code>（是否被玩家到达）：无需冗余数据，仅通过该布尔值区分“未发现”“已激活”两种核心状态。</p>
<h2 id="3-读档逻辑实现"><a href="#3-读档逻辑实现" class="headerlink" title="3. 读档逻辑实现"></a>3. 读档逻辑实现</h2><p>重写存档接口的读档方法，核心根据<code>bReached</code>状态执行差异化逻辑：</p>
<ul>
<li>若<code>bReached</code>为true（已到达）：触发视觉反馈（如点亮存档点、播放激活特效），执行已激活后的专属逻辑；</li>
<li>若<code>bReached</code>为false（未到达）：保持初始状态，等待玩家触发。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ACheckPoint::LoadActor_Implementation</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (bReached)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">HandleGlowEffects</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-存档触发机制"><a href="#4-存档触发机制" class="headerlink" title="4. 存档触发机制"></a>4. 存档触发机制</h2><p>存档操作在玩家到达检查点时触发，核心流程：</p>
<ul>
<li>触发方式：为CheckPoint添加碰撞体，通过重叠检测判断玩家是否进入检查点范围；</li>
<li>交互反馈：触发存档时播放视觉&#x2F;听觉效果（如存档点发光、提示音），明确告知玩家已完成存档；</li>
<li>状态更新：将<code>bReached</code>设为true，调用存档逻辑将状态写入SaveGame对象。</li>
</ul>
<p>注：读档操作固定在玩家类的<code>PossessedBy</code>函数中执行（玩家被Controller接管时），确保进入关卡后优先还原检查点状态。</p>
]]></content>
      <categories>
        <category>SystemDesigns</category>
        <category>SaveAndLoad</category>
      </categories>
      <tags>
        <tag>CheckPoint</tag>
      </tags>
  </entry>
  <entry>
    <title>WorldTransition</title>
    <url>/ue5-blog/2025/12/17/SystemDesigns/Levels/WorldTransition/</url>
    <content><![CDATA[<h1 id="核心总结"><a href="#核心总结" class="headerlink" title="核心总结"></a>核心总结</h1><p>WorldTransition（关卡转换）是实现多关卡无缝切换的核心逻辑，主要包含UI触发、地图入口触发两种方式，核心依赖<code>UGameplayStatics::OpenLevelBySoftObjectPtr</code>实现关卡跳转；同时通过重写GameMode的<code>ChoosePlayerStart</code>函数指定玩家新关卡初始位置，结合存档保存关卡状态、进度和玩家起点标签，保证关卡切换的连贯性。</p>
<span id="more"></span>

<h1 id="关卡转换实现"><a href="#关卡转换实现" class="headerlink" title="关卡转换实现"></a>关卡转换实现</h1><p>这里我们考虑“直接跳转”场景（无加载页面），主要分为UI触发和地图入口触发两种形式，同时需自定义玩家在新关卡的初始生成位置。</p>
<h2 id="1-UI触发关卡转换"><a href="#1-UI触发关卡转换" class="headerlink" title="1. UI触发关卡转换"></a>1. UI触发关卡转换</h2><p>通过UI界面选择地图触发跳转，核心是为UI按钮绑定关卡跳转逻辑，目标关卡需以<code>TSoftObjectPtr&lt;UWorld&gt;</code>类型保存，确保异步加载兼容性：</p>
<h3 id="核心代码实现"><a href="#核心代码实现" class="headerlink" title="核心代码实现"></a>核心代码实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ACustomGameModeBase::TravelToMap</span><span class="params">(UMVVM_LoadSlot* Slot)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">const</span> FString SlotName = Slot-&gt;<span class="built_in">GetLoadSlotName</span>();</span><br><span class="line">	<span class="type">const</span> int32 SlotIndex = Slot-&gt;SlotIndex;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 按软对象指针打开目标关卡</span></span><br><span class="line">	UGameplayStatics::<span class="built_in">OpenLevelBySoftObjectPtr</span>(Slot , Maps.<span class="built_in">FindChecked</span>(Slot-&gt;<span class="built_in">GetMapName</span>()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-地图入口（Map-Entrance）触发转换"><a href="#2-地图入口（Map-Entrance）触发转换" class="headerlink" title="2. 地图入口（Map Entrance）触发转换"></a>2. 地图入口（Map Entrance）触发转换</h2><p>玩家进入关卡内指定入口区域（Sphere碰撞体）时触发跳转，核心函数与UI触发一致，需额外保存关卡状态和玩家进度，保证跨关卡数据连贯：</p>
<h3 id="核心逻辑"><a href="#核心逻辑" class="headerlink" title="核心逻辑"></a>核心逻辑</h3><ul>
<li>触发方式：通过Sphere组件的重叠事件检测玩家进入入口；</li>
<li>数据保存：跳转前保存关卡状态（WorldState）、进度（Progress）及目标起点标签；</li>
<li>视觉提示：为入口添加点光源，玩家靠近时通过<code>Set Visibility</code>点亮，提示传送功能。</li>
</ul>
<h3 id="核心代码实现-1"><a href="#核心代码实现-1" class="headerlink" title="核心代码实现"></a>核心代码实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMapEntrance::OnSphereOverlap</span><span class="params">(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, <span class="type">bool</span> bFromSweep, <span class="type">const</span> FHitResult&amp; SweepResult)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 仅对玩家触发跳转逻辑</span></span><br><span class="line">	<span class="keyword">if</span> (OtherActor-&gt;<span class="built_in">Implements</span>&lt;UPlayerInterface&gt;())</span><br><span class="line">	&#123;</span><br><span class="line">		bReached = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 保存当前关卡状态，记录目标地图名称</span></span><br><span class="line">		<span class="keyword">if</span> (ACustomGameModeBase* CustomGM = <span class="built_in">Cast</span>&lt;ACustomGameModeBase&gt;(UGameplayStatics::<span class="built_in">GetGameMode</span>(<span class="keyword">this</span>)))</span><br><span class="line">		&#123;</span><br><span class="line">			CustomGM-&gt;<span class="built_in">SaveWorldState</span>(<span class="built_in">GetWorld</span>() , DestinationMap.<span class="built_in">ToSoftObjectPath</span>().<span class="built_in">GetAssetName</span>());</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 保存玩家进度，记录目标关卡的起点标签</span></span><br><span class="line">		IPlayerInterface::<span class="built_in">Execute_SaveProgress</span>(OtherActor , DestinationPlayerStartTag);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 跳转至目标关卡</span></span><br><span class="line">		UGameplayStatics::<span class="built_in">OpenLevelBySoftObjectPtr</span>(<span class="keyword">this</span> , DestinationMap);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-自定义玩家新关卡初始位置"><a href="#3-自定义玩家新关卡初始位置" class="headerlink" title="3. 自定义玩家新关卡初始位置"></a>3. 自定义玩家新关卡初始位置</h2><p>默认情况下玩家会随机生成在关卡的PlayerStart位置，需重写GameMode的<code>ChoosePlayerStart</code>函数，根据存档的起点标签指定精准生成位置：</p>
<h3 id="核心逻辑-1"><a href="#核心逻辑-1" class="headerlink" title="核心逻辑"></a>核心逻辑</h3><ul>
<li>遍历关卡内所有PlayerStart Actor（含检查点）；</li>
<li>匹配存档的<code>PlayerStartTag</code>，优先选择对应位置生成；</li>
<li>无匹配时默认选择第一个PlayerStart位置。</li>
</ul>
<h3 id="核心代码实现-2"><a href="#核心代码实现-2" class="headerlink" title="核心代码实现"></a>核心代码实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">AActor* <span class="title">ACustomGameModeBase::ChoosePlayerStart_Implementation</span><span class="params">(AController* Player)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	UCustomGameInstance* CustomGameInstance = <span class="built_in">Cast</span>&lt;UCustomGameInstance&gt;(<span class="built_in">GetGameInstance</span>());</span><br><span class="line">	</span><br><span class="line">	TArray&lt;AActor*&gt; Actors;</span><br><span class="line">	UGameplayStatics::<span class="built_in">GetAllActorsOfClass</span>(<span class="built_in">GetWorld</span>() , APlayerStart::<span class="built_in">StaticClass</span>() , Actors);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (Actors.<span class="built_in">Num</span>() &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		AActor* SelectedActor = Actors[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 查找与存档标签匹配的PlayerStart</span></span><br><span class="line">		<span class="keyword">for</span> (AActor* Actor : Actors)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (APlayerStart* PlayerStart = <span class="built_in">Cast</span>&lt;APlayerStart&gt;(Actor))</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (PlayerStart-&gt;PlayerStartTag == CustomGameInstance-&gt;PlayerStartTag)</span><br><span class="line">				&#123;</span><br><span class="line">					SelectedActor = Actor;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> SelectedActor;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="关键说明"><a href="#关键说明" class="headerlink" title="关键说明"></a>关键说明</h3><ul>
<li>该函数无需手动调用，打开新关卡时引擎会自动执行；</li>
<li>需在目标关卡的「World Settings」中选择自定义GameMode，确保函数生效；</li>
<li>仅需保存一个<code>PlayerStartTag</code>，也就是玩家上一次保存时的位置。</li>
</ul>
]]></content>
      <categories>
        <category>SystemDesigns</category>
        <category>Levels</category>
      </categories>
      <tags>
        <tag>WorldTransition</tag>
      </tags>
  </entry>
  <entry>
    <title>SaveGame</title>
    <url>/ue5-blog/2025/12/18/SystemDesigns/SaveAndLoad/SaveGame/</url>
    <content><![CDATA[<h1 id="核心总结"><a href="#核心总结" class="headerlink" title="核心总结"></a>核心总结</h1><p>SaveGame是UE存档系统的核心数据载体，存档逻辑核心分为两步：将玩家进度、技能、世界状态等关键数据写入自定义SaveGame对象，再通过UE封装的函数完成对象与磁盘的读写交互；需自定义结构体封装技能、地图&#x2F;Actor等复杂数据，并为结构体重定义相等运算符，适配数组去重逻辑。</p>
<span id="more"></span>

<h1 id="SaveGame对象（存档核心载体）"><a href="#SaveGame对象（存档核心载体）" class="headerlink" title="SaveGame对象（存档核心载体）"></a>SaveGame对象（存档核心载体）</h1><p>存档的核心是把需持久化的动态数据写入SaveGame对象，再将该对象存储到磁盘；UE已封装好SaveGame对象与磁盘的交互函数，开发者只需完成“向SaveGame填入数据”和“从SaveGame读取数据”两类操作。</p>
<h2 id="SaveGame中保存的核心内容"><a href="#SaveGame中保存的核心内容" class="headerlink" title="SaveGame中保存的核心内容"></a>SaveGame中保存的核心内容</h2><p>自定义SaveGame对象仅存储影响游戏进度的关键动态数据，核心包含三类内容：</p>
<h3 id="1-玩家属性与等级"><a href="#1-玩家属性与等级" class="headerlink" title="1. 玩家属性与等级"></a>1. 玩家属性与等级</h3><p>这类信息为基础数值变量（如等级、经验、力量&#x2F;智力等属性值），直接在SaveGame中定义对应变量即可存储，无需复杂封装。</p>
<h3 id="2-玩家技能集合"><a href="#2-玩家技能集合" class="headerlink" title="2. 玩家技能集合"></a>2. 玩家技能集合</h3><p>技能信息包含技能类、配置状态等多维度数据，需自定义结构体封装后完整存储：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">USTRUCT</span>(BlueprintType)</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">FSavedAbility</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(EditDefaultsOnly , BlueprintReadOnly , Category = <span class="string">&quot;ClassDefaults&quot;</span>)</span><br><span class="line">	TSubclassOf&lt;UGameplayAbility&gt; GameplayAbility;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(EditDefaultsOnly , BlueprintReadWrite)</span><br><span class="line">	FGameplayTag AbilityTag = <span class="built_in">FGameplayTag</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(EditDefaultsOnly , BlueprintReadWrite)</span><br><span class="line">	FGameplayTag AbilityStatus = <span class="built_in">FGameplayTag</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(EditDefaultsOnly , BlueprintReadWrite)</span><br><span class="line">	FGameplayTag AbilitySlot = <span class="built_in">FGameplayTag</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(EditDefaultsOnly , BlueprintReadWrite)</span><br><span class="line">	FGameplayTag AbilityType = <span class="built_in">FGameplayTag</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(EditDefaultsOnly , BlueprintReadWrite)</span><br><span class="line">	int32 AbilityLevel = <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> FSavedAbility&amp; Left, <span class="type">const</span> FSavedAbility&amp; Right)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> Left.AbilityTag.<span class="built_in">MatchesTagExact</span>(Right.AbilityTag);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结构体除存储技能类（GameplayAbility）外，还需记录技能的核心配置信息：技能唯一标签、激活状态、绑定的输入槽位、技能类型、等级，确保读档时能完整还原技能的使用状态。</p>
<h3 id="3-世界信息（地图-Actor状态）"><a href="#3-世界信息（地图-Actor状态）" class="headerlink" title="3. 世界信息（地图+Actor状态）"></a>3. 世界信息（地图+Actor状态）</h3><p>世界信息聚焦地图及地图内Actor的核心状态（如是否触发、位置等），仅存储Actor的唯一标识和需序列化的状态数据（非Actor全量信息）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">USTRUCT</span>(BlueprintType)</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">FSavedActor</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line">	<span class="built_in">UPROPERTY</span>()</span><br><span class="line">	FName ActorName = <span class="built_in">FName</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">UPROPERTY</span>()</span><br><span class="line">	FTransform Transform = <span class="built_in">FTransform</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 仅序列化Actor中带SaveGame关键字的变量</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>()</span><br><span class="line">	TArray&lt;uint8&gt; Bytes;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> FSavedActor&amp; Left, <span class="type">const</span> FSavedActor&amp; Right)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> Left.ActorName == Right.ActorName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">USTRUCT</span>()</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">FSavedMap</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line">	<span class="built_in">UPROPERTY</span>()</span><br><span class="line">	FString MapAssetName = <span class="built_in">FString</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">UPROPERTY</span>()</span><br><span class="line">	TArray&lt;FSavedActor&gt; SavedActors;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>FSavedActor：存储Actor的唯一名称（引擎生成，确保唯一性）、Transform（可选恢复位置），以及序列化后的核心状态字节流（仅含SaveGame关键字变量）；</li>
<li>FSavedMap：按地图维度管理Actor状态，通过MapAssetName关联地图，SavedActors存储该地图下所有需存档的Actor状态。</li>
</ul>
<h2 id="自定义结构体的相等运算符重定义"><a href="#自定义结构体的相等运算符重定义" class="headerlink" title="自定义结构体的相等运算符重定义"></a>自定义结构体的相等运算符重定义</h2><p>为自定义结构体重定义&#x3D;&#x3D;运算符，核心适配UE数组的AddUnique方法（避免重复存储）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> FSavedActor&amp; Left, <span class="type">const</span> FSavedActor&amp; Right)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> Left.ActorName == Right.ActorName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="核心原因"><a href="#核心原因" class="headerlink" title="核心原因"></a>核心原因</h3><p>存储技能、Actor状态时，需将结构体实例添加到数组中，使用AddUnique可自动过滤重复数据；而AddUnique内置的相等判断逻辑依赖&#x3D;&#x3D;运算符，因此需为自定义结构体明确“相等判定规则”：</p>
<ul>
<li>FSavedAbility：通过AbilityTag（技能唯一标签）判断是否为同一技能；</li>
<li>FSavedActor：通过ActorName（Actor唯一名称）判断是否为同一Actor；<br>确保数组中仅保留唯一的技能&#x2F;Actor状态，避免存档数据冗余。</li>
</ul>
]]></content>
      <categories>
        <category>SystemDesigns</category>
        <category>SaveAndLoad</category>
      </categories>
      <tags>
        <tag>SaveGame</tag>
      </tags>
  </entry>
  <entry>
    <title>AsyncTask</title>
    <url>/ue5-blog/2025/12/08/SystemDesigns/UI/AsyncTask/</url>
    <content><![CDATA[<h1 id="核心总结"><a href="#核心总结" class="headerlink" title="核心总结"></a>核心总结</h1><span id="more"></span>]]></content>
      <categories>
        <category>SystemDesigns</category>
      </categories>
      <tags>
        <tag>AsyncTasks</tag>
      </tags>
  </entry>
  <entry>
    <title>GameMode</title>
    <url>/ue5-blog/2025/12/18/SystemDesigns/SaveAndLoad/GameMode/</url>
    <content><![CDATA[<h1 id="核心总结"><a href="#核心总结" class="headerlink" title="核心总结"></a>核心总结</h1><p>GameMode是UE服务端独有的核心类（Client端无法访问），核心承担三大功能：配置玩家操控相关类、托管全局核心游戏数据、管理存档与读档逻辑；通过区分“固定游戏数据”（如敌人属性）和“玩家进度数据”（如等级、位置）实现数据分层管理，结合GameInstance的跨关卡生命周期特性完成多档位存档管控，需在每个Level的World Settings中配置对应GameMode以生效。</p>
<span id="more"></span>

<h1 id="GameMode-的核心定位与数据区分"><a href="#GameMode-的核心定位与数据区分" class="headerlink" title="GameMode 的核心定位与数据区分"></a>GameMode 的核心定位与数据区分</h1><p>GameMode仅存在于Server端，可安全存储核心数据，避免客户端作弊；使用前需明确两类数据的管理边界：</p>
<ul>
<li><strong>固定游戏数据</strong>：游戏内预设的静态数值（如敌人基础攻击力、奖励规则），无需存档，集中托管在DataAsset中；</li>
<li><strong>玩家进度数据</strong>：随玩家游玩状态变化的动态信息（如等级、保存位置、已激活技能），需存入存档，仅保留必要内容。</li>
</ul>
<h1 id="1-配置玩家操控"><a href="#1-配置玩家操控" class="headerlink" title="1. 配置玩家操控"></a>1. 配置玩家操控</h1><p>GameMode在关卡加载时自动配置玩家核心操控类，同时支持自定义玩家初始生成位置：</p>
<h3 id="1-1-核心配置项"><a href="#1-1-核心配置项" class="headerlink" title="1.1 核心配置项"></a>1.1 核心配置项</h3><p>GameMode可配置以下关键类，决定玩家的核心交互逻辑：</p>
<ul>
<li>Player Controller Class（玩家控制器）</li>
<li>Player State Class（玩家状态，存储等级&#x2F;经验等）</li>
<li>HUD Class（玩家界面）</li>
<li>Default Pawn Class（默认操控角色）</li>
</ul>
<h3 id="1-2-自定义玩家初始位置（PlayerStart）"><a href="#1-2-自定义玩家初始位置（PlayerStart）" class="headerlink" title="1.2 自定义玩家初始位置（PlayerStart）"></a>1.2 自定义玩家初始位置（PlayerStart）</h3><p>默认情况下玩家随机生成在场景的PlayerStart位置，重写<code>ChoosePlayerStart</code>可精准指定生成位置（如匹配存档的检查点）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">AActor* <span class="title">ACustomGameModeBase::ChoosePlayerStart_Implementation</span><span class="params">(AController* Player)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	UCustomGameInstance* CustomGameInstance = <span class="built_in">Cast</span>&lt;UCustomGameInstance&gt;(<span class="built_in">GetGameInstance</span>());</span><br><span class="line">	</span><br><span class="line">	TArray&lt;AActor*&gt; Actors;</span><br><span class="line">	UGameplayStatics::<span class="built_in">GetAllActorsOfClass</span>(<span class="built_in">GetWorld</span>() , APlayerStart::<span class="built_in">StaticClass</span>() , Actors);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (Actors.<span class="built_in">Num</span>() &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		AActor* SelectedActor = Actors[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 查找与存档标签匹配的PlayerStart</span></span><br><span class="line">		<span class="keyword">for</span> (AActor* Actor : Actors)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (APlayerStart* PlayerStart = <span class="built_in">Cast</span>&lt;APlayerStart&gt;(Actor))</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (PlayerStart-&gt;PlayerStartTag == CustomGameInstance-&gt;PlayerStartTag)</span><br><span class="line">				&#123;</span><br><span class="line">					SelectedActor = Actor;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> SelectedActor;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数在GameMode初始化时自动调用，无需手动触发。</p>
<h1 id="2-保存重要游戏数据"><a href="#2-保存重要游戏数据" class="headerlink" title="2. 保存重要游戏数据"></a>2. 保存重要游戏数据</h1><p>核心游戏数据（DataAsset）最终挂载在GameMode上，确保仅Server端可访问，避免客户端篡改：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UPROPERTY</span>(EditDefaultsOnly , Category = <span class="string">&quot;Character Class Defaults&quot;</span>)</span><br><span class="line">TObjectPtr&lt;UCharacterClassInfo&gt; CharacterClassInfo;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditDefaultsOnly , Category = <span class="string">&quot;Ability Info&quot;</span>)</span><br><span class="line">TObjectPtr&lt;UAbilityInfo&gt; AbilityInfo;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditDefaultsOnly , Category = <span class="string">&quot;Loot Tiers&quot;</span>)</span><br><span class="line">TObjectPtr&lt;ULootTiers&gt; LootTiers;</span><br></pre></td></tr></table></figure>
<p>所有业务逻辑需通过GameMode获取DataAsset数据，保证数据权威性。</p>
<h1 id="3-存档与读档"><a href="#3-存档与读档" class="headerlink" title="3. 存档与读档"></a>3. 存档与读档</h1><p>存档核心逻辑分为两层：<strong>游戏世界 ↔ SaveGame对象</strong>（自定义映射）、<strong>SaveGame对象 ↔ 磁盘</strong>（UE封装函数），磁盘文件通过SlotName和SlotIndex区分不同档位。</p>
<h2 id="3-1-基础存档操作（删档-读档-存档）"><a href="#3-1-基础存档操作（删档-读档-存档）" class="headerlink" title="3.1 基础存档操作（删档&#x2F;读档&#x2F;存档）"></a>3.1 基础存档操作（删档&#x2F;读档&#x2F;存档）</h2><p>封装磁盘交互函数，仅处理SaveGame对象与磁盘的读写，不涉及游戏世界数据映射：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ACustomGameModeBase::SaveSlotData</span><span class="params">(UMVVM_LoadSlot* LoadSlot, int32 SlotIndex)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">DeleteSlot</span>(LoadSlot-&gt;<span class="built_in">GetLoadSlotName</span>() , SlotIndex);</span><br><span class="line">	</span><br><span class="line">	USaveGame* SaveGameObject = UGameplayStatics::<span class="built_in">CreateSaveGameObject</span>(CustomSaveDataClass);</span><br><span class="line">	UCustomSaveGame* CustomSaveGame = <span class="built_in">Cast</span>&lt;UCustomSaveGame&gt;(SaveGameObject);</span><br><span class="line">	CustomSaveGame-&gt;PlayerName = LoadSlot-&gt;<span class="built_in">GetPlayerName</span>();</span><br><span class="line">	CustomSaveGame-&gt;SaveSlotStatus = Taken;</span><br><span class="line">	CustomSaveGame-&gt;MapName = LoadSlot-&gt;<span class="built_in">GetMapName</span>();</span><br><span class="line">	CustomSaveGame-&gt;PlayerStartTag = LoadSlot-&gt;PlayerStartTag;</span><br><span class="line"></span><br><span class="line">	UGameplayStatics::<span class="built_in">SaveGameToSlot</span>(CustomSaveGame , LoadSlot-&gt;<span class="built_in">GetLoadSlotName</span>() , SlotIndex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">UCustomSaveGame* <span class="title">ACustomGameModeBase::GetSaveSlotData</span><span class="params">(<span class="type">const</span> FString&amp; SlotName, int32 SlotIndex)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	USaveGame* SaveGameObject  = <span class="literal">nullptr</span>;</span><br><span class="line">	<span class="keyword">if</span> (UGameplayStatics::<span class="built_in">DoesSaveGameExist</span>(SlotName, SlotIndex))</span><br><span class="line">	&#123;</span><br><span class="line">		SaveGameObject = UGameplayStatics::<span class="built_in">LoadGameFromSlot</span>(SlotName , SlotIndex);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		SaveGameObject = UGameplayStatics::<span class="built_in">CreateSaveGameObject</span>(CustomSaveDataClass);</span><br><span class="line">	&#125;</span><br><span class="line">	UCustomSaveGame* CustomSaveGame = <span class="built_in">Cast</span>&lt;UCustomSaveGame&gt;(SaveGameObject);</span><br><span class="line">	<span class="keyword">return</span> CustomSaveGame;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ACustomGameModeBase::DeleteSlot</span><span class="params">(<span class="type">const</span> FString&amp; SlotName, int32 SlotIndex)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (UGameplayStatics::<span class="built_in">DoesSaveGameExist</span>(SlotName , SlotIndex))</span><br><span class="line">	&#123;</span><br><span class="line">		UGameplayStatics::<span class="built_in">DeleteGameInSlot</span>(SlotName , SlotIndex);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-2-GameInstance：多档位全局管控"><a href="#3-2-GameInstance：多档位全局管控" class="headerlink" title="3.2 GameInstance：多档位全局管控"></a>3.2 GameInstance：多档位全局管控</h2><p>GameInstance的生命周期跨关卡（游戏运行期间持续存在），核心存储当前游玩档位的<code>SlotName</code>和<code>SlotIndex</code>，解决“游戏世界识别当前生效SaveGame对象”的问题：</p>
<ul>
<li>档位切换（新建&#x2F;选择存档）仅在UI层对应位置修改GameInstance的档位信息；</li>
<li>GameMode通过GameInstance获取当前档位，定位对应的SaveGame对象：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">UCustomSaveGame* <span class="title">ACustomGameModeBase::RetrieveInGameSaveData</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	UCustomGameInstance* CustomGameInstance = <span class="built_in">Cast</span>&lt;UCustomGameInstance&gt;(<span class="built_in">GetGameInstance</span>());</span><br><span class="line"></span><br><span class="line">	<span class="type">const</span> FString InGameLoadSlotName = CustomGameInstance-&gt;LoadSlotName;</span><br><span class="line">	<span class="type">const</span> int32 InGameLoadSlotIndex = CustomGameInstance-&gt;LoadSlotIndex;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">GetSaveSlotData</span>(InGameLoadSlotName, InGameLoadSlotIndex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-3-玩家进度（Progress）的存档与读档"><a href="#3-3-玩家进度（Progress）的存档与读档" class="headerlink" title="3.3 玩家进度（Progress）的存档与读档"></a>3.3 玩家进度（Progress）的存档与读档</h2><p>Progress包含玩家等级、技能、属性等动态信息，采用“解耦设计”：GameMode处理磁盘交互，玩家类处理数据映射（避免GameMode耦合GAS逻辑）。</p>
<h3 id="3-3-1-GameMode层：SaveGame对象读写"><a href="#3-3-1-GameMode层：SaveGame对象读写" class="headerlink" title="3.3.1 GameMode层：SaveGame对象读写"></a>3.3.1 GameMode层：SaveGame对象读写</h3><p>GameMode层的核心职责是“桥梁作用”，不参与具体数据解析：</p>
<ol>
<li>从GameInstance获取当前生效的档位信息（SlotName、SlotIndex），定位到对应的SaveGame对象；</li>
<li>仅执行两类核心操作：将填充好数据的SaveGame对象写入磁盘，或从磁盘读取对应档位的SaveGame对象；</li>
<li>额外同步玩家起点标签（PlayerStartTag）到GameInstance，确保后续关卡切换时能精准定位玩家初始生成位置。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ACustomGameModeBase::SaveInGameProgressData</span><span class="params">(UCustomSaveGame* SaveObject)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	UCustomGameInstance* CustomGameInstance = <span class="built_in">Cast</span>&lt;UCustomGameInstance&gt;(<span class="built_in">GetGameInstance</span>());</span><br><span class="line"></span><br><span class="line">	<span class="type">const</span> FString InGameLoadSlotName = CustomGameInstance-&gt;LoadSlotName;</span><br><span class="line">	<span class="type">const</span> int32 InGameLoadSlotIndex = CustomGameInstance-&gt;LoadSlotIndex;</span><br><span class="line"></span><br><span class="line">	CustomGameInstance-&gt;PlayerStartTag = SaveObject-&gt;PlayerStartTag;</span><br><span class="line">	</span><br><span class="line">	UGameplayStatics::<span class="built_in">SaveGameToSlot</span>(SaveObject , InGameLoadSlotName , InGameLoadSlotIndex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-3-2-玩家类层：数据映射"><a href="#3-3-2-玩家类层：数据映射" class="headerlink" title="3.3.2 玩家类层：数据映射"></a>3.3.2 玩家类层：数据映射</h3><h4 id="读档：从SaveGame更新玩家状态"><a href="#读档：从SaveGame更新玩家状态" class="headerlink" title="读档：从SaveGame更新玩家状态"></a>读档：从SaveGame更新玩家状态</h4><p>读档逻辑区分“首次加载”和“非首次加载”，适配不同游玩阶段：</p>
<ol>
<li>首次加载：玩家无存档数据，执行默认初始化流程，包括初始化角色基础属性、添加初始技能；</li>
<li>非首次加载（：从存档恢复完整状态，核心步骤：<ul>
<li>技能恢复：通过ASC（Ability System Component）从存档数据中重新添加已激活的技能，还原技能配置；</li>
<li>等级与资源恢复：同步PlayerState中存储的等级、经验值等到玩家当前状态；</li>
<li>属性值恢复：借助AbilitySystemLibrary工具函数，通过临时创建GameplayEffect的方式，将存档中的核心属性同步到AttributeSet。</li>
</ul>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ACustomCharacter::LoadProgress</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ACustomGameModeBase* CustomGameMode = <span class="built_in">Cast</span>&lt;ACustomGameModeBase&gt;(UGameplayStatics::<span class="built_in">GetGameMode</span>(<span class="keyword">this</span>));</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (CustomGameMode)</span><br><span class="line">	&#123;</span><br><span class="line">		UCustomSaveGame* SaveData = CustomGameMode-&gt;<span class="built_in">RetrieveInGameSaveData</span>();</span><br><span class="line">		<span class="keyword">if</span> (SaveData == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (SaveData-&gt;bFirstLoadIn)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">InitializeDefaultAttributes</span>();</span><br><span class="line">			<span class="built_in">AddCharacterAbilities</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (UCustomAbilitySystemComponent* CustomASC = <span class="built_in">Cast</span>&lt;UCustomAbilitySystemComponent&gt;(AbilitySystemComponent))</span><br><span class="line">			&#123;</span><br><span class="line">				CustomASC-&gt;<span class="built_in">AddCharacterAbilitiesFromSaveData</span>(SaveData);</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span> (ACustomPlayerState* CustomPlayerState = <span class="built_in">Cast</span>&lt;ACustomPlayerState&gt;(<span class="built_in">GetPlayerState</span>()))</span><br><span class="line">			&#123;</span><br><span class="line">				CustomPlayerState-&gt;<span class="built_in">SetLevel</span>(SaveData-&gt;PlayerLevel);</span><br><span class="line">				CustomPlayerState-&gt;<span class="built_in">SetXP</span>(SaveData-&gt;XP);</span><br><span class="line">				CustomPlayerState-&gt;<span class="built_in">SetAttributePoints</span>(SaveData-&gt;AttributePoints);</span><br><span class="line">				CustomPlayerState-&gt;<span class="built_in">SetSpellPoints</span>(SaveData-&gt;SpellPoints);</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">            <span class="comment">// 通过临时GameplayEffect初始化存档属性</span></span><br><span class="line">			UCustomAbilitySystemLibrary::<span class="built_in">InitializeDefaultAttributesFromSaveData</span>(<span class="keyword">this</span> , AbilitySystemComponent , SaveData);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="存档：将玩家状态写入SaveGame"><a href="#存档：将玩家状态写入SaveGame" class="headerlink" title="存档：将玩家状态写入SaveGame"></a>存档：将玩家状态写入SaveGame</h4><p>存档逻辑完整收集玩家核心进度数据，其中技能数据通过委托机制高效遍历收集：</p>
<ol>
<li>基础数据收集：先同步玩家当前检查点标签、PlayerState中的等级&#x2F;经验&#x2F;属性点，以及AttributeSet中的力量、活力等属性值到SaveGame；</li>
<li>技能数据收集（委托机制）：<ul>
<li>定义遍历技能的委托（FForEachAbility），绑定回调函数；</li>
<li>回调函数核心逻辑：提取技能标签、类型、等级、绑定输入插槽、技能状态等信息，封装为SavedAbility结构体并添加到SaveGame的技能列表；</li>
<li>调用ASC的ForEachAbility方法触发委托，遍历所有已激活技能完成数据收集；</li>
</ul>
</li>
<li>权限校验：仅在服务端（HasAuthority为true）执行技能数据收集，避免客户端篡改数据；</li>
<li>最终保存：调用GameMode的存档方法，将填充完整数据的SaveGame对象写入磁盘，完成进度保存。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ACustomCharacter::SaveProgress_Implementation</span><span class="params">(<span class="type">const</span> FName&amp; CheckPointTag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ACustomGameModeBase* CustomGameMode = <span class="built_in">Cast</span>&lt;ACustomGameModeBase&gt;(UGameplayStatics::<span class="built_in">GetGameMode</span>(<span class="keyword">this</span>));</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (CustomGameMode)</span><br><span class="line">	&#123;</span><br><span class="line">		UCustomSaveGame* SaveData = CustomGameMode-&gt;<span class="built_in">RetrieveInGameSaveData</span>();</span><br><span class="line">		<span class="keyword">if</span> (SaveData == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">		SaveData-&gt;PlayerStartTag = CheckPointTag;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (ACustomPlayerState* CustomPlayerState = <span class="built_in">Cast</span>&lt;ACustomPlayerState&gt;(<span class="built_in">GetPlayerState</span>()))</span><br><span class="line">		&#123;</span><br><span class="line">			SaveData-&gt;PlayerLevel = CustomPlayerState-&gt;<span class="built_in">GetPlayerLevel</span>();</span><br><span class="line">			SaveData-&gt;XP = CustomPlayerState-&gt;<span class="built_in">GetXP</span>();</span><br><span class="line">			SaveData-&gt;AttributePoints = CustomPlayerState-&gt;<span class="built_in">GetAttributePoints</span>();</span><br><span class="line">			SaveData-&gt;SpellPoints = CustomPlayerState-&gt;<span class="built_in">GetSpellPoints</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		SaveData-&gt;Strength = UCustomAttributeSet::<span class="built_in">GetStrengthAttribute</span>().<span class="built_in">GetNumericValue</span>(<span class="built_in">GetAttributeSet</span>());</span><br><span class="line">		SaveData-&gt;Vigor = UCustomAttributeSet::<span class="built_in">GetVigorAttribute</span>().<span class="built_in">GetNumericValue</span>(<span class="built_in">GetAttributeSet</span>());</span><br><span class="line">		SaveData-&gt;Intelligence = UCustomAttributeSet::<span class="built_in">GetIntelligenceAttribute</span>().<span class="built_in">GetNumericValue</span>(<span class="built_in">GetAttributeSet</span>());</span><br><span class="line">		SaveData-&gt;Resilience = UCustomAttributeSet::<span class="built_in">GetResilienceAttribute</span>().<span class="built_in">GetNumericValue</span>(<span class="built_in">GetAttributeSet</span>());</span><br><span class="line"></span><br><span class="line">		SaveData-&gt;bFirstLoadIn = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!<span class="built_in">HasAuthority</span>()) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">		UCustomAbilitySystemComponent* CustomASC = <span class="built_in">Cast</span>&lt;UCustomAbilitySystemComponent&gt;(AbilitySystemComponent);</span><br><span class="line">		FForEachAbility SaveAbilityDelegate;</span><br><span class="line">		SaveData-&gt;SavedAbilities.<span class="built_in">Empty</span>();</span><br><span class="line"></span><br><span class="line">		SaveAbilityDelegate.<span class="built_in">BindLambda</span>(</span><br><span class="line">			[<span class="keyword">this</span> , CustomASC , SaveData](<span class="type">const</span> FGameplayAbilitySpec&amp; AbilitySpec)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="type">const</span> FGameplayTag AbilityTag = CustomASC-&gt;<span class="built_in">GetAbilityTagFromSpec</span>(AbilitySpec);</span><br><span class="line">				UAbilityInfo* AbilityInfo = UCustomAbilitySystemLibrary::<span class="built_in">GetAbilityInfo</span>(<span class="keyword">this</span>);</span><br><span class="line">				FCustomAbilityInfo Info = AbilityInfo-&gt;<span class="built_in">FindAbilityInfoForTag</span>(AbilityTag);</span><br><span class="line"></span><br><span class="line">				FSavedAbility SavedAbility;</span><br><span class="line">				SavedAbility.GameplayAbility = Info.Ability;</span><br><span class="line">				SavedAbility.AbilityType = Info.AbilityType;</span><br><span class="line">				SavedAbility.AbilityTag = AbilityTag;</span><br><span class="line">				SavedAbility.AbilityLevel = AbilitySpec.Level;</span><br><span class="line">				SavedAbility.AbilitySlot = CustomASC-&gt;<span class="built_in">GetInputTagFromAbilityTag</span>(AbilityTag);</span><br><span class="line">				SavedAbility.AbilityStatus = CustomASC-&gt;<span class="built_in">GetStatusFromAbilityTag</span>(AbilityTag);</span><br><span class="line"></span><br><span class="line">				SaveData-&gt;SavedAbilities.<span class="built_in">AddUnique</span>(SavedAbility);</span><br><span class="line">			&#125;</span><br><span class="line">			);</span><br><span class="line"></span><br><span class="line">		CustomASC-&gt;<span class="built_in">ForEachAbility</span>(SaveAbilityDelegate);</span><br><span class="line">		</span><br><span class="line">		CustomGameMode-&gt;<span class="built_in">SaveInGameProgressData</span>(SaveData);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-4-世界状态（World-State）的存档与读档"><a href="#3-4-世界状态（World-State）的存档与读档" class="headerlink" title="3.4 世界状态（World State）的存档与读档"></a>3.4 世界状态（World State）的存档与读档</h2><p>World State保存当前地图及地图内Actor的核心状态（非全量信息，如“是否触发”“宝箱是否开启”），仅序列化带<code>SaveGame</code>关键字的变量。</p>
<h3 id="3-4-1-保存世界状态"><a href="#3-4-1-保存世界状态" class="headerlink" title="3.4.1 保存世界状态"></a>3.4.1 保存世界状态</h3><p>核心是收集当前地图及地图内关键Actor的核心状态，存入对应档位的SaveGame对象：</p>
<ol>
<li>地图信息预处理：提取当前地图的纯净名称（去除引擎自动添加的StreamingLevelsPrefix前缀），从GameInstance获取当前档位信息，定位到对应的SaveGame对象；</li>
<li>地图状态初始化：若SaveGame中无当前地图的状态记录，创建新的SavedMap结构体并添加，保证每个地图的状态独立存储，互不干扰；</li>
<li>Actor筛选与遍历：仅遍历地图内实现<code>USaveInterface</code>的Actor；</li>
<li>Actor状态序列化：对目标Actor，先记录Actor名称、Transform（可选用于位置恢复），再通过内存写入器（FMemoryWriter）和存档代理（FObjectAndNameAsStringProxyArchive），将带<code>SaveGame</code>关键字的变量序列化为字节流，确保仅保存核心状态；</li>
<li>数据更新与持久化：替换SaveGame中当前地图的旧状态（清空旧数据后重新填充），最后将更新后的SaveGame对象写入磁盘，完成世界状态保存。</li>
</ol>
<p>有关存档序列化的内容详见<a href="/ue5-blog/2025/12/10/ProgrammingSkills/Serialize">这里</a>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ACustomGameModeBase::SaveWorldState</span><span class="params">(UWorld* World, <span class="type">const</span> FString&amp; DestinationMapAssetName)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	FString WorldName = World-&gt;<span class="built_in">GetName</span>();</span><br><span class="line">	WorldName.<span class="built_in">RemoveFromStart</span>(World-&gt;StreamingLevelsPrefix);</span><br><span class="line"></span><br><span class="line">	UCustomGameInstance* CustomGI = <span class="built_in">Cast</span>&lt;UCustomGameInstance&gt;(<span class="built_in">GetGameInstance</span>());</span><br><span class="line">	<span class="built_in">check</span>(CustomGI);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (UCustomSaveGame* SaveGame = <span class="built_in">GetSaveSlotData</span>(CustomGI-&gt;LoadSlotName , CustomGI-&gt;LoadSlotIndex))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (DestinationMapAssetName != <span class="built_in">FString</span>(<span class="string">&quot;&quot;</span>))</span><br><span class="line">		&#123;</span><br><span class="line">			SaveGame-&gt;MapAssetName = DestinationMapAssetName;</span><br><span class="line">			SaveGame-&gt;MapName = <span class="built_in">GetMapNameFromMapAssetName</span>(DestinationMapAssetName);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (!SaveGame-&gt;<span class="built_in">HasMap</span>(WorldName))</span><br><span class="line">		&#123;</span><br><span class="line">			FSavedMap NewSavedMap;</span><br><span class="line">			NewSavedMap.MapAssetName = WorldName;</span><br><span class="line">			SaveGame-&gt;SavedMaps.<span class="built_in">Add</span>(NewSavedMap);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		FSavedMap SavedMap = SaveGame-&gt;<span class="built_in">GetSavedMapWithMapName</span>(WorldName);</span><br><span class="line">		SavedMap.SavedActors.<span class="built_in">Empty</span>(); <span class="comment">// 清空旧数据，重新填充</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (FActorIterator <span class="built_in">It</span>(World) ; It ; ++It)</span><br><span class="line">		&#123;</span><br><span class="line">			AActor* Actor = *It;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (!<span class="built_in">IsValid</span>(Actor) || !Actor-&gt;<span class="built_in">Implements</span>&lt;USaveInterface&gt;()) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">			FSavedActor SavedActor;</span><br><span class="line">			SavedActor.ActorName = Actor-&gt;<span class="built_in">GetFName</span>();</span><br><span class="line">			SavedActor.Transform = Actor-&gt;<span class="built_in">GetTransform</span>();</span><br><span class="line"></span><br><span class="line">			<span class="function">FMemoryWriter <span class="title">MemoryWriter</span><span class="params">(SavedActor.Bytes)</span></span>;</span><br><span class="line"></span><br><span class="line">			<span class="function">FObjectAndNameAsStringProxyArchive <span class="title">Archive</span><span class="params">(MemoryWriter , <span class="literal">true</span>)</span></span>;</span><br><span class="line">			Archive.ArIsSaveGame = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">			Actor-&gt;<span class="built_in">Serialize</span>(Archive); <span class="comment">// 序列化SaveGame变量</span></span><br><span class="line"></span><br><span class="line">			SavedMap.SavedActors.<span class="built_in">AddUnique</span>(SavedActor);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (FSavedMap&amp; MapToReplace : SaveGame-&gt;SavedMaps)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (MapToReplace.MapAssetName == WorldName)</span><br><span class="line">			&#123;</span><br><span class="line">				MapToReplace = SavedMap;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		UGameplayStatics::<span class="built_in">SaveGameToSlot</span>(SaveGame , CustomGI-&gt;LoadSlotName , CustomGI-&gt;LoadSlotIndex);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-4-2-加载世界状态"><a href="#3-4-2-加载世界状态" class="headerlink" title="3.4.2 加载世界状态"></a>3.4.2 加载世界状态</h3><p>核心是将存档中的世界状态还原到当前地图，恢复Actor的核心状态：</p>
<ol>
<li>存档加载校验：先检查当前档位的存档是否存在，不存在则直接返回并输出错误日志，避免空指针导致崩溃；</li>
<li>Actor匹配与筛选：遍历当前地图内实现<code>USaveInterface</code>的Actor，通过Actor名称（ActorName）匹配存档中的SavedActor；</li>
<li>状态反序列化：<ul>
<li>位置恢复：通过<code>ShouldLoadTransform</code>接口判断是否需要恢复Actor的Transform（如移动平台、可交互物件需恢复位置，固定场景物件无需恢复）；</li>
<li>变量还原：通过内存读取器（FMemoryReader）和存档代理，将序列化的字节流反序列化，还原Actor中带<code>SaveGame</code>关键字的变量；</li>
</ul>
</li>
<li>自定义逻辑触发：调用<code>LoadActor</code>接口执行Actor的自定义加载逻辑（如宝箱已开启则隐藏宝物、触发过的敌人生成点不再生成敌人、机关已激活则保持开启状态），完成状态落地。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ACustomGameModeBase::LoadWorldState</span><span class="params">(UWorld* World)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	FString WorldName = World-&gt;<span class="built_in">GetName</span>();</span><br><span class="line">	WorldName.<span class="built_in">RemoveFromStart</span>(World-&gt;StreamingLevelsPrefix);</span><br><span class="line"></span><br><span class="line">	UCustomGameInstance* CustomGI = <span class="built_in">Cast</span>&lt;UCustomGameInstance&gt;(<span class="built_in">GetGameInstance</span>());</span><br><span class="line">	<span class="built_in">check</span>(CustomGI);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (UGameplayStatics::<span class="built_in">DoesSaveGameExist</span>(CustomGI-&gt;LoadSlotName , CustomGI-&gt;LoadSlotIndex))</span><br><span class="line">	&#123;</span><br><span class="line">		UCustomSaveGame* SaveGame = <span class="built_in">Cast</span>&lt;UCustomSaveGame&gt;(UGameplayStatics::<span class="built_in">LoadGameFromSlot</span>(CustomGI-&gt;LoadSlotName , CustomGI-&gt;LoadSlotIndex));</span><br><span class="line">		<span class="keyword">if</span> (SaveGame == <span class="literal">nullptr</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">UE_LOG</span>(LogCustom , Error , <span class="built_in">TEXT</span>(<span class="string">&quot;Fail to load slot&quot;</span>));</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span> (FActorIterator <span class="built_in">It</span>(World) ; It ; ++It)</span><br><span class="line">		&#123;</span><br><span class="line">			AActor* Actor = *It;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (!Actor-&gt;<span class="built_in">Implements</span>&lt;USaveInterface&gt;()) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">for</span> (FSavedActor SavedActor : SaveGame-&gt;<span class="built_in">GetSavedMapWithMapName</span>(WorldName).SavedActors)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (SavedActor.ActorName == Actor-&gt;<span class="built_in">GetFName</span>())</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">if</span> (ISaveInterface::<span class="built_in">Execute_ShouldLoadTransform</span>(Actor))</span><br><span class="line">					&#123;</span><br><span class="line">						Actor-&gt;<span class="built_in">SetActorTransform</span>(SavedActor.Transform);</span><br><span class="line">					&#125;</span><br><span class="line"></span><br><span class="line">					<span class="function">FMemoryReader <span class="title">MemoryReader</span><span class="params">(SavedActor.Bytes)</span></span>;</span><br><span class="line"></span><br><span class="line">					<span class="function">FObjectAndNameAsStringProxyArchive <span class="title">Archive</span><span class="params">(MemoryReader , <span class="literal">true</span>)</span></span>;</span><br><span class="line">					Archive.ArIsSaveGame = <span class="literal">true</span>;</span><br><span class="line">					Actor-&gt;<span class="built_in">Serialize</span>(Archive); <span class="comment">// 反序列化恢复变量</span></span><br><span class="line"></span><br><span class="line">					ISaveInterface::<span class="built_in">Execute_LoadActor</span>(Actor); <span class="comment">// 执行Actor自定义加载逻辑</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-5-加载触发时机"><a href="#3-5-加载触发时机" class="headerlink" title="3.5 加载触发时机"></a>3.5 加载触发时机</h2><p>选择在玩家被Controller接管（<code>PossessedBy</code>）后触发世界状态加载，保证数据恢复的完整性和逻辑合理性：</p>
<ol>
<li>时机合理性：<code>PossessedBy</code>是玩家进入关卡后Controller与角色绑定的核心节点，此时GAS（Ability System Component）、PlayerState、AttributeSet等核心系统已完成初始化，避免因依赖未就绪导致数据恢复失败；</li>
<li>执行顺序：先初始化GAS相关组件（InitAbilityActorInfo），再加载玩家进度（LoadProgress），最后加载世界状态（LoadWorldState），确保玩家自身状态优先于场景状态恢复，符合游戏游玩逻辑；</li>
<li>体验保障：在玩家可操作角色前完成世界状态加载，能让玩家进入关卡时直接看到符合存档进度的场景状态（如已开启的宝箱、已清理的敌人营地），避免场景状态与玩家进度不一致的违和感。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ACustomCharacter::PossessedBy</span><span class="params">(AController* NewController)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Super::<span class="built_in">PossessedBy</span>(NewController);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">InitAbilityActorInfo</span>(); <span class="comment">// 初始化GAS相关信息</span></span><br><span class="line">	<span class="built_in">LoadProgress</span>(); <span class="comment">// 加载玩家进度</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ACustomGameModeBase* CustomGameMode = <span class="built_in">Cast</span>&lt;ACustomGameModeBase&gt;(UGameplayStatics::<span class="built_in">GetGameMode</span>(<span class="keyword">this</span>)))</span><br><span class="line">	&#123;</span><br><span class="line">		CustomGameMode-&gt;<span class="built_in">LoadWorldState</span>(<span class="built_in">GetWorld</span>()); <span class="comment">// 加载世界状态</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ACustomCharacter::InitAbilityActorInfo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ACustomPlayerState* CustomPlayerState = <span class="built_in">GetPlayerState</span>&lt;ACustomPlayerState&gt;();</span><br><span class="line">	<span class="built_in">check</span>(CustomPlayerState);</span><br><span class="line">	CustomPlayerState-&gt;<span class="built_in">GetAbilitySystemComponent</span>()-&gt;<span class="built_in">InitAbilityActorInfo</span>(CustomPlayerState , <span class="keyword">this</span>);</span><br><span class="line">	<span class="built_in">Cast</span>&lt;UCustomAbilitySystemComponent&gt;(CustomPlayerState-&gt;<span class="built_in">GetAbilitySystemComponent</span>())-&gt;<span class="built_in">AbilityActorInfoSet</span>();</span><br><span class="line">	</span><br><span class="line">	AbilitySystemComponent = CustomPlayerState-&gt;<span class="built_in">GetAbilitySystemComponent</span>();</span><br><span class="line">	AttributeSet = CustomPlayerState-&gt;<span class="built_in">GetAttributeSet</span>();</span><br><span class="line"></span><br><span class="line">	OnASCRegistered.<span class="built_in">Broadcast</span>(AbilitySystemComponent);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (ACustomPlayerController* CustomPlayerController = <span class="built_in">Cast</span>&lt;ACustomPlayerController&gt;(<span class="built_in">GetController</span>()))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (ACustomHUD*  CustomHUD = <span class="built_in">Cast</span>&lt;ACustomHUD&gt;(CustomPlayerController-&gt;<span class="built_in">GetHUD</span>()))</span><br><span class="line">		&#123;</span><br><span class="line">			CustomHUD-&gt;<span class="built_in">InitOverlay</span>(CustomPlayerController , CustomPlayerState , AbilitySystemComponent , AttributeSet);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="4-角色死亡处理"><a href="#4-角色死亡处理" class="headerlink" title="4 角色死亡处理"></a>4 角色死亡处理</h1><p>角色死亡后加载最近存档的关卡，恢复玩家状态：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ACustomGameModeBase::PlayerDied</span><span class="params">(ACharacter* DeadCharacter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	UCustomSaveGame* SaveGame = <span class="built_in">RetrieveInGameSaveData</span>();</span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">IsValid</span>(SaveGame)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	UGameplayStatics::<span class="built_in">OpenLevel</span>(DeadCharacter , <span class="built_in">FName</span>(SaveGame-&gt;MapAssetName));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>SystemDesigns</category>
        <category>SaveAndLoad</category>
      </categories>
      <tags>
        <tag>GameMode</tag>
      </tags>
  </entry>
  <entry>
    <title>Head Up Display (HUD)</title>
    <url>/ue5-blog/2025/12/08/SystemDesigns/UI/HUD/</url>
    <content><![CDATA[<h1 id="核心总结"><a href="#核心总结" class="headerlink" title="核心总结"></a>核心总结</h1><span id="more"></span>]]></content>
      <categories>
        <category>SystemDesigns</category>
        <category>UI</category>
      </categories>
      <tags>
        <tag>HUD</tag>
      </tags>
  </entry>
  <entry>
    <title>Model View ViewModel (MVVM)</title>
    <url>/ue5-blog/2025/12/08/SystemDesigns/UI/MVVM/</url>
    <content><![CDATA[<h1 id="核心总结"><a href="#核心总结" class="headerlink" title="核心总结"></a>核心总结</h1><span id="more"></span>]]></content>
      <categories>
        <category>SystemDesigns</category>
        <category>UI</category>
      </categories>
      <tags>
        <tag>MVVM</tag>
        <tag>FieldNotify</tag>
      </tags>
  </entry>
  <entry>
    <title>Model View Controller (MVC)</title>
    <url>/ue5-blog/2025/12/19/SystemDesigns/UI/MVC/</url>
    <content><![CDATA[<h1 id="核心总结"><a href="#核心总结" class="headerlink" title="核心总结"></a>核心总结</h1><p>MVC架构是实现UI系统，核心是将“数据展示&#x2F;交互”与“数据获取&#x2F;修改”解耦：Widget作为View层负责UI渲染和用户输入响应，WidgetController作为Controller层承接游戏逻辑与UI的交互，统一管理数据获取、广播和修改；通过委托（Delegate）实现数据的单向流动，既保证UI模块的独立性，又能高效同步游戏内动态数据。</p>
<span id="more"></span>

<h1 id="MVC-架构"><a href="#MVC-架构" class="headerlink" title="MVC 架构"></a>MVC 架构</h1><p>UI的核心功能分为两类：展示游戏内动态数据、响应用户输入操作。Widget承担UI可视化与交互入口的角色（如按钮、文本显示），但直接让Widget对接游戏逻辑会导致耦合过高，因此引入WidgetController作为中间层：</p>
<ul>
<li>Widget：专注View层职责，仅负责数据展示和暴露交互接口，不直接操作游戏数据；</li>
<li>WidgetController：专注Controller层职责，统一处理数据的获取、更新、修改，作为Widget与游戏世界（PlayerController、PlayerState等）的唯一交互桥梁；</li>
<li>每个Widget绑定专属的WidgetController，所有游戏数据均通过WidgetController获取或修改。</li>
</ul>
<h1 id="Widget-Controller（核心中间层）"><a href="#Widget-Controller（核心中间层）" class="headerlink" title="Widget Controller（核心中间层）"></a>Widget Controller（核心中间层）</h1><h2 id="1-数据获取（对接游戏核心数据）"><a href="#1-数据获取（对接游戏核心数据）" class="headerlink" title="1. 数据获取（对接游戏核心数据）"></a>1. 数据获取（对接游戏核心数据）</h2><p>GAS框架下，UI所需核心数据来源于四类对象：PlayerController（PC）、PlayerState（PS）、AbilitySystemComponent（ASC）、AttributeSet（AS），四类对象存在明确的从属关系：</p>
<ul>
<li>PC是基础载体，可获取所属PS；</li>
<li>PS管理玩家核心数据，其中属性相关数据托管给AS，技能相关数据托管给ASC，等级、经验等关键数值直接存储在PS中。</li>
</ul>
<p>基于该从属关系，封装通用的数据获取方法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">UCustomAbilitySystemLibrary::MakeWidgetControllerParams</span><span class="params">(<span class="type">const</span> UObject* WorldContextObject , FWidgetControllerParams&amp; OutWidgetControllerParams, ACustomHUD*&amp; OutCustomHUD)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (APlayerController* PC = UGameplayStatics::<span class="built_in">GetPlayerController</span>(WorldContextObject , <span class="number">0</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		OutCustomHUD = <span class="built_in">Cast</span>&lt;ACustomHUD&gt;(PC-&gt;<span class="built_in">GetHUD</span>());</span><br><span class="line">		<span class="keyword">if</span> (OutCustomHUD)</span><br><span class="line">		&#123;</span><br><span class="line">			ACustomPlayerState* PS = PC-&gt;<span class="built_in">GetPlayerState</span>&lt;ACustomPlayerState&gt;();</span><br><span class="line">			UAbilitySystemComponent* ASC = PS-&gt;<span class="built_in">GetAbilitySystemComponent</span>();</span><br><span class="line">			UAttributeSet* AS = PS-&gt;<span class="built_in">GetAttributeSet</span>();</span><br><span class="line">			</span><br><span class="line">			OutWidgetControllerParams.AttributeSet = AS;</span><br><span class="line">			OutWidgetControllerParams.AbilitySystemComponent = ASC;</span><br><span class="line">			OutWidgetControllerParams.PlayerController = PC;</span><br><span class="line">			OutWidgetControllerParams.PlayerState = PS;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-在-Widget-中绑定-WidgetController"><a href="#2-在-Widget-中绑定-WidgetController" class="headerlink" title="2. 在 Widget 中绑定 WidgetController"></a>2. 在 Widget 中绑定 WidgetController</h2><h3 id="2-1-WidgetController的实例化规则"><a href="#2-1-WidgetController的实例化规则" class="headerlink" title="2.1 WidgetController的实例化规则"></a>2.1 WidgetController的实例化规则</h3><p>WidgetController遵循“实例化一次、共享复用”原则：</p>
<ul>
<li>同类子控件（如多个属性显示控件）共享同一个WidgetController，无需为每个子控件单独创建；</li>
<li>WidgetController统一托管在HUD中，Widget获取时优先从HUD读取已有实例，无实例时再创建并初始化。</li>
</ul>
<p>WidgetController按“业务类型”分类（如属性类、技能类），不同类型对应不同的委托（Delegate），适配不同的数据传输需求：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">UAttributeMenuWidgetController* <span class="title">UCustomAbilitySystemLibrary::GetAttributeMenuWidgetController</span><span class="params">(<span class="type">const</span> UObject* WorldContextObject)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	FWidgetControllerParams WCParams;</span><br><span class="line">	ACustomHUD* CustomHUD = <span class="literal">nullptr</span>;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">MakeWidgetControllerParams</span>(WorldContextObject , WCParams , CustomHUD))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> CustomHUD-&gt;<span class="built_in">GetAttributeMenuWidgetController</span>(WCParams);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">UAttributeMenuWidgetController* <span class="title">ACustomHUD::GetAttributeMenuWidgetController</span><span class="params">(<span class="type">const</span> FWidgetControllerParams&amp; WCparams)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (AttributeMenuWidgetController == <span class="literal">nullptr</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		AttributeMenuWidgetController = <span class="built_in">NewObject</span>&lt;UAttributeMenuWidgetController&gt;(<span class="keyword">this</span> , AttributeMenuWidgetControllerClass);</span><br><span class="line">		AttributeMenuWidgetController-&gt;<span class="built_in">SetWidgetControllerParams</span>(WCparams);</span><br><span class="line">		AttributeMenuWidgetController-&gt;<span class="built_in">BindCallbacksToDependencies</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> AttributeMenuWidgetController;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-Widget与WidgetController的绑定逻辑"><a href="#2-2-Widget与WidgetController的绑定逻辑" class="headerlink" title="2.2 Widget与WidgetController的绑定逻辑"></a>2.2 Widget与WidgetController的绑定逻辑</h3><ul>
<li>父Widget在Construct阶段调用<code>GetXXWidgetController</code>获取实例，子Widget无需重复获取，直接复用父Widget的WidgetController；</li>
<li>子Widget的回调逻辑不绑定在Construct中，而是通过<code>WidgetControllerSet</code>虚函数触发，确保Controller绑定完成后再执行逻辑：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GAS_Custom_API</span> UCustomUserWidget : <span class="keyword">public</span> UUserWidget</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">GENERATED_BODY</span>()</span><br><span class="line">	</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintCallable)</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">SetWidgetController</span><span class="params">(UObject* InWidgetController)</span></span>;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">UPROPERTY</span>(BlueprintReadOnly)</span><br><span class="line">	TObjectPtr&lt;UObject&gt; WidgetController;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintImplementableEvent)</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">WidgetControllerSet</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UCustomUserWidget::SetWidgetController</span><span class="params">(UObject* InWidgetController)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	WidgetController = InWidgetController;</span><br><span class="line">	<span class="built_in">WidgetControllerSet</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-数据广播（向Widget同步数据）"><a href="#3-数据广播（向Widget同步数据）" class="headerlink" title="3. 数据广播（向Widget同步数据）"></a>3. 数据广播（向Widget同步数据）</h2><p>WidgetController通过多播委托（Multicast Delegate）向Widget传输数据，核心分为“初始数据广播”和“变化数据广播”两类：</p>
<h3 id="3-1-初始数据广播"><a href="#3-1-初始数据广播" class="headerlink" title="3.1 初始数据广播"></a>3.1 初始数据广播</h3><p>WidgetController初始化完成后，一次性广播所有初始数据，核心设计特点：</p>
<ul>
<li>多播委托：同一类数据通过一个委托管道传输，所有绑定该Controller的Widget均可接收，适配多控件共享数据的场景；</li>
<li>空间换时间：即使Widget仅需部分数据（如仅显示生命值），仍接收全量数据（如体力、智力等），以减少委托管道数量，降低维护成本。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam</span>(FAttributeInfoSignature, <span class="type">const</span> FCustomAttributeInfo&amp; , Info);</span><br><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span>(BlueprintAssignable , Category = <span class="string">&quot;GAS|Attributes&quot;</span>)</span><br><span class="line">AttributeInfoSignature AttributeInfoDelegate;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UAttributeMenuWidgetController::BroadcastInitValues</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">check</span>(AttributeInfo)</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; Pair : <span class="built_in">GetCustomAS</span>()-&gt;TagToAttribute)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">BroadCastAttributeInfo</span>(Pair.Key , Pair.<span class="built_in">Value</span>());</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	AttributePointsChangedDelegate.<span class="built_in">Broadcast</span>(<span class="built_in">GetCustomPS</span>()-&gt;<span class="built_in">GetAttributePoints</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UAttributeMenuWidgetController::BroadCastAttributeInfo</span><span class="params">(<span class="type">const</span> FGameplayTag&amp; AttributeTag,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                            <span class="type">const</span> FGameplayAttribute&amp; Attribute)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	FCustomAttributeInfo Info = AttributeInfo-&gt;<span class="built_in">FindAttributeInfoForTag</span>(AttributeTag);</span><br><span class="line">	Info.AttributeValue = Attribute.<span class="built_in">GetNumericValue</span>(AttributeSet);</span><br><span class="line">	AttributeInfoDelegate.<span class="built_in">Broadcast</span>(Info);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="关键注意事项"><a href="#关键注意事项" class="headerlink" title="关键注意事项"></a>关键注意事项</h4><p>需保证“先绑定回调，后广播数据”：<code>BroadcastInitValues</code>需在所有Widget构建完成后执行，通常放在WidgetController初始化的最后阶段，避免数据广播时Widget未完成回调绑定。<br>Widget中绑定回调的方式：<br><img src="/ue5-blog/2025/12/19/SystemDesigns/UI/MVC/image.png" alt="alt text"></p>
<h3 id="3-2-变化数据广播（实时同步）"><a href="#3-2-变化数据广播（实时同步）" class="headerlink" title="3.2 变化数据广播（实时同步）"></a>3.2 变化数据广播（实时同步）</h3><p>为监控数据动态变化，采用“嵌套委托”机制：</p>
<ol>
<li>第一层委托：数据源头（如ASC、PS）的变化通知委托，用于告知WidgetController“数据已更新”；</li>
<li>第二层委托：WidgetController的广播委托，将更新后的数据同步给所有绑定的Widget。</li>
</ol>
<h4 id="委托绑定时机"><a href="#委托绑定时机" class="headerlink" title="委托绑定时机"></a>委托绑定时机</h4><p>第一层委托的回调需在WidgetController初始化完成后立即绑定（<code>BindCallbacksToDependencies</code>函数），确保数据变化前完成监听：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UAttributeMenuWidgetController::BindCallbacksToDependencies</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">check</span>(AttributeInfo)</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; Pair : <span class="built_in">GetCustomAS</span>()-&gt;TagToAttribute)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// GAS内置委托：监听GE修改属性的变化</span></span><br><span class="line">		AbilitySystemComponent-&gt;<span class="built_in">GetGameplayAttributeValueChangeDelegate</span>(Pair.<span class="built_in">Value</span>()).<span class="built_in">AddLambda</span>(</span><br><span class="line">			[<span class="keyword">this</span> , Pair](<span class="type">const</span> FOnAttributeChangeData&amp; Data)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">BroadCastAttributeInfo</span>(Pair.Key , Pair.<span class="built_in">Value</span>());</span><br><span class="line">			&#125;</span><br><span class="line">			);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 自定义委托：监听手动修改的属性点变化</span></span><br><span class="line">	<span class="built_in">GetCustomPS</span>()-&gt;OnAttributePointsChangedDelegate.<span class="built_in">AddLambda</span>(</span><br><span class="line">		[<span class="keyword">this</span>](int32 Points)</span><br><span class="line">		&#123;</span><br><span class="line">			AttributePointsChangedDelegate.<span class="built_in">Broadcast</span>(Points);</span><br><span class="line">		&#125;</span><br><span class="line">	);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ACustomPlayerState::AddToAttributePoints</span><span class="params">(int32 InAttributePoints)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	AttributePoints += InAttributePoints;</span><br><span class="line">	OnAttributePointsChangedDelegate.<span class="built_in">Broadcast</span>(AttributePoints);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="委托类型说明"><a href="#委托类型说明" class="headerlink" title="委托类型说明"></a>委托类型说明</h4><ul>
<li>GAS内置委托：通过<code>GetGameplayAttributeValueChangeDelegate</code>监听由GameplayEffect修改的属性值变化；</li>
<li>自定义委托：监听手动修改的数值（如属性点）变化，需自行定义并触发广播。</li>
</ul>
<h2 id="4-数据修改（响应用户输入）"><a href="#4-数据修改（响应用户输入）" class="headerlink" title="4. 数据修改（响应用户输入）"></a>4. 数据修改（响应用户输入）</h2><p>Widget接收用户输入后，通过WidgetController调用游戏逻辑接口修改数据，避免Widget直接操作核心数据：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UAttributeMenuWidgetController::UpgradeAttribute</span><span class="params">(<span class="type">const</span> FGameplayTag&amp; AttributeTag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">GetCustomASC</span>()-&gt;<span class="built_in">UpgradeAttribute</span>(AttributeTag);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">UCustomAbilitySystemComponent* <span class="title">UCustomWidgetController::GetCustomASC</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (CustomAbilitySystemComponent == <span class="literal">nullptr</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		CustomAbilitySystemComponent = <span class="built_in">Cast</span>&lt;UCustomAbilitySystemComponent&gt;(AbilitySystemComponent);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> CustomAbilitySystemComponent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Overlay-Message（全局提示信息）"><a href="#Overlay-Message（全局提示信息）" class="headerlink" title="Overlay Message（全局提示信息）"></a>Overlay Message（全局提示信息）</h1><p>Overlay Message是UI的典型场景：触发游戏事件时向屏幕发送提示信息，核心逻辑仍基于“WidgetController+委托”实现：</p>
<ol>
<li>消息载体：提示信息以Widget形式展示，在Overlay Widget中动态创建；</li>
<li>数据传递：通过嵌套委托实现“游戏事件→WidgetController→Overlay Widget”的信息传递；</li>
<li>数据管理：通过DataTable管理不同类型的提示信息（文本、图片、Widget模板），按Tag匹配调用。</li>
</ol>
<h2 id="核心实现逻辑"><a href="#核心实现逻辑" class="headerlink" title="核心实现逻辑"></a>核心实现逻辑</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UCustomAbilitySystemComponent::ClientEffectApplied_Implementation</span><span class="params">(UAbilitySystemComponent* AbilitySystemComponent,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                                     <span class="type">const</span> FGameplayEffectSpec&amp; EffectSpec, FActiveGameplayEffectHandle ActiveEffectHandle)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	FGameplayTagContainer TagContainer;</span><br><span class="line">	EffectSpec.<span class="built_in">GetAllAssetTags</span>(TagContainer);</span><br><span class="line"></span><br><span class="line">	EffectAssetTags.<span class="built_in">Broadcast</span>(TagContainer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UOverlayWidgetController::BindCallbacksToDependencies</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">GetCustomASC</span>()-&gt;EffectAssetTags.<span class="built_in">AddLambda</span>(</span><br><span class="line">		[<span class="keyword">this</span>](<span class="type">const</span> FGameplayTagContainer&amp; AssetTags)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="type">const</span> FGameplayTag&amp; Tag : AssetTags)</span><br><span class="line">				&#123;</span><br><span class="line">					FGameplayTag MessageTag = FGameplayTag::<span class="built_in">RequestGameplayTag</span>(<span class="built_in">FName</span>(<span class="string">&quot;Message&quot;</span>));</span><br><span class="line">					<span class="keyword">if</span> (Tag.<span class="built_in">MatchesTag</span>(MessageTag))</span><br><span class="line">					&#123;</span><br><span class="line">						<span class="type">const</span> FUIWidgetRow* Row = <span class="built_in">GetDataTableRowByTag</span>&lt;FUIWidgetRow&gt;(MessageWidgetDataTable , Tag);</span><br><span class="line">						MessageWidgetRowDelegate.<span class="built_in">Broadcast</span>(*Row);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通用DataTable查表模板函数</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T* <span class="title">GetDataTableRowByTag</span><span class="params">(UDataTable* DataTable , <span class="type">const</span> FGameplayTag&amp; Tag )</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T* <span class="title">UOverlayWidgetController::GetDataTableRowByTag</span><span class="params">(UDataTable* DataTable, <span class="type">const</span> FGameplayTag&amp; Tag)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> DataTable-&gt;<span class="built_in">FindRow</span>&lt;T&gt;(Tag.<span class="built_in">GetTagName</span>() , <span class="built_in">TEXT</span>(<span class="string">&quot;&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提示信息数据结构（关联DataTable）</span></span><br><span class="line"><span class="built_in">USTRUCT</span>(BlueprintType)</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">FUIWidgetRow</span> : <span class="keyword">public</span> FTableRowBase</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(EditAnywhere, BlueprintReadOnly)</span><br><span class="line">	FGameplayTag MessageTag = <span class="built_in">FGameplayTag</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(EditAnywhere, BlueprintReadOnly)</span><br><span class="line">	FText Message = <span class="built_in">FText</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(EditAnywhere, BlueprintReadOnly)</span><br><span class="line">	TSubclassOf&lt;UCustomUserWidget&gt; MessageWidget;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(editAnywhere, BlueprintReadOnly)</span><br><span class="line">	UTexture2D* Image = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Widget中接收并显示提示信息的逻辑：<br><img src="/ue5-blog/2025/12/19/SystemDesigns/UI/MVC/image1.png" alt="alt text"></p>
]]></content>
      <categories>
        <category>SystemDesigns</category>
        <category>UI</category>
      </categories>
      <tags>
        <tag>MVC</tag>
        <tag>Widget</tag>
        <tag>WidgetController</tag>
      </tags>
  </entry>
  <entry>
    <title>Highlight</title>
    <url>/ue5-blog/2025/12/16/SystemDesigns/VisualEffects/Highlight/</url>
    <content><![CDATA[<h1 id="核心总结"><a href="#核心总结" class="headerlink" title="核心总结"></a>核心总结</h1><p>Highlight（高亮）是游戏中突出玩家选中对象的核心视觉交互功能，通过三层逻辑实现：</p>
<ol>
<li>PlayerController控制高亮的触发&#x2F;关闭时机，</li>
<li>基于UE后处理渲染管线实现高亮视觉效果，</li>
<li>Actor通过自定义接口和渲染配置决定自身高亮表现形式。</li>
</ol>
<span id="more"></span>

<h1 id="高亮显示"><a href="#高亮显示" class="headerlink" title="高亮显示"></a>高亮显示</h1><p>实现对象高亮需解决三个核心问题：触发时机控制、渲染层面的视觉实现、Actor侧的高亮配置，以下是具体实现逻辑：</p>
<h2 id="1-PlayerController：控制高亮的触发与关闭时机"><a href="#1-PlayerController：控制高亮的触发与关闭时机" class="headerlink" title="1. PlayerController：控制高亮的触发与关闭时机"></a>1. PlayerController：控制高亮的触发与关闭时机</h2><p>核心逻辑是通过逐帧追踪鼠标指向的Actor，对比“上一帧选中对象（LastActor）”和“当前帧选中对象（ThisActor）”，实现高亮的切换：</p>
<ul>
<li>若两帧选中对象不同，关闭上一帧对象的高亮，开启当前帧对象的高亮；</li>
<li>仅对实现了<code>UHighlightInterface</code>接口的Actor生效，确保非高亮对象不触发逻辑。<br>可以验证对于所有情形以上逻辑均是正确的，注意高亮仅当选取对象实现了相关接口时才有效；</li>
</ul>
<h3 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AAuraPlayerController::CursorTrace</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">const</span> ECollisionChannel TraceChannel = ECC_Visibility;</span><br><span class="line">	<span class="built_in">GetHitResultUnderCursor</span>(TraceChannel , <span class="literal">false</span> , CursorHitResult);</span><br><span class="line">	<span class="keyword">if</span> (!CursorHitResult.bBlockingHit) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 缓存上一帧选中对象，更新当前帧对象</span></span><br><span class="line">	LastActor = ThisActor;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">IsValid</span>(CursorHitResult.<span class="built_in">GetActor</span>()) &amp;&amp; CursorHitResult.<span class="built_in">GetActor</span>()-&gt;<span class="built_in">Implements</span>&lt;UHighlightInterface&gt;())</span><br><span class="line">	&#123;</span><br><span class="line">		ThisActor = CursorHitResult.<span class="built_in">GetActor</span>();	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		ThisActor = <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 对象变化时切换高亮状态</span></span><br><span class="line">	<span class="keyword">if</span> (LastActor != ThisActor)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">UnHighlightActor</span>(LastActor);</span><br><span class="line">		<span class="built_in">HighlightActor</span>(ThisActor);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AAuraPlayerController::HighlightActor</span><span class="params">(AActor* InActor)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 仅对有效且实现高亮接口的Actor开启高亮</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">IsValid</span>(InActor) &amp;&amp; InActor-&gt;<span class="built_in">Implements</span>&lt;UHighlightInterface&gt;())</span><br><span class="line">	&#123;</span><br><span class="line">		IHighlightInterface::<span class="built_in">Execute_HighlightActor</span>(InActor);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AAuraPlayerController::UnHighlightActor</span><span class="params">(AActor* InActor)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 仅对有效且实现高亮接口的Actor关闭高亮</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">IsValid</span>(InActor) &amp;&amp; InActor-&gt;<span class="built_in">Implements</span>&lt;UHighlightInterface&gt;())</span><br><span class="line">	&#123;</span><br><span class="line">		IHighlightInterface::<span class="built_in">Execute_UnHighlightActor</span>(InActor);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-渲染层面：实现高亮的视觉效果"><a href="#2-渲染层面：实现高亮的视觉效果" class="headerlink" title="2. 渲染层面：实现高亮的视觉效果"></a>2. 渲染层面：实现高亮的视觉效果</h2><p>UE中高亮效果基于后处理管线实现，核心利用自定义深度（Custom Depth）和模板测试（Stencil）标记目标对象，通过后处理材质渲染边缘高亮：</p>
<h3 id="配置步骤"><a href="#配置步骤" class="headerlink" title="配置步骤"></a>配置步骤</h3><ol>
<li>关卡中添加<code>PostProcessVolume</code>（后处理体积），勾选「Infinite Extent (Unbound)」，使其作用于全局场景；</li>
<li>为PostProcessVolume绑定自定义后处理材质：该材质通过关联“自定义深度值”与高亮颜色，识别目标Mesh并渲染边缘高亮效果,</li>
</ol>
<p><a href="/ue5-blog/2025/12/16/SystemDesigns/VisualEffects/Highlight/PP_Highlight.uasset" download="PP_Highlight.uasset">点击下载高亮后处理示例材料</a>;</p>
<ol start="3">
<li>项目设置配置：在Project Settings 中搜索 Custom Depth-Stencil Pass中，选择「Enabled With Stencil」，确保引擎能识别Actor设置的自定义深度值。</li>
</ol>
<h2 id="3-Character-接口：定义Actor的高亮表现形式"><a href="#3-Character-接口：定义Actor的高亮表现形式" class="headerlink" title="3. Character&#x2F;接口：定义Actor的高亮表现形式"></a>3. Character&#x2F;接口：定义Actor的高亮表现形式</h2><p>Actor需实现<code>UHighlightInterface</code>接口，并配置自定义深度渲染参数，通过开关“自定义深度渲染”实现高亮&#x2F;取消高亮：</p>
<h3 id="核心实现"><a href="#核心实现" class="headerlink" title="核心实现"></a>核心实现</h3><ol>
<li>构造时配置自定义深度值：为Mesh&#x2F;武器设置专属自定义深度值（标记为高亮目标），并刷新渲染状态；</li>
<li>重写接口函数：通过开关<code>SetRenderCustomDepth</code>控制自定义深度渲染，进而触发后处理高亮效果。</li>
</ol>
<h3 id="核心代码-1"><a href="#核心代码-1" class="headerlink" title="核心代码"></a>核心代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">AAuraEnemy::<span class="built_in">AAuraEnemy</span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 为Mesh和武器设置自定义深度值（标记高亮目标）</span></span><br><span class="line">	<span class="built_in">GetMesh</span>()-&gt;<span class="built_in">SetCustomDepthStencilValue</span>(CUSTOM_DEPTH_RED);</span><br><span class="line">	<span class="built_in">GetMesh</span>()-&gt;<span class="built_in">MarkRenderStateDirty</span>();</span><br><span class="line">	Weapon-&gt;<span class="built_in">SetCustomDepthStencilValue</span>(CUSTOM_DEPTH_RED);</span><br><span class="line">	Weapon-&gt;<span class="built_in">MarkRenderStateDirty</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AAuraEnemy::HighlightActor_Implementation</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 开启自定义深度渲染，触发高亮</span></span><br><span class="line">	<span class="built_in">GetMesh</span>()-&gt;<span class="built_in">SetRenderCustomDepth</span>(<span class="literal">true</span>);</span><br><span class="line">	Weapon-&gt;<span class="built_in">SetRenderCustomDepth</span>(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AAuraEnemy::UnHighlightActor_Implementation</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 关闭自定义深度渲染，取消高亮</span></span><br><span class="line">	<span class="built_in">GetMesh</span>()-&gt;<span class="built_in">SetRenderCustomDepth</span>(<span class="literal">false</span>);</span><br><span class="line">	Weapon-&gt;<span class="built_in">SetRenderCustomDepth</span>(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>SystemDesigns</category>
        <category>VisualEffects</category>
      </categories>
      <tags>
        <tag>Highlight</tag>
      </tags>
  </entry>
  <entry>
    <title>Fade Actor</title>
    <url>/ue5-blog/2025/12/17/SystemDesigns/VisualEffects/FadeActor/</url>
    <content><![CDATA[<h1 id="核心总结"><a href="#核心总结" class="headerlink" title="核心总结"></a>核心总结</h1><p>Fade Actor（对象淡入淡出）是解决俯视视角游戏中“场景物体遮挡摄像机视线”的核心方案：通过动态材质调整透明度实现遮挡物透明化，结合碰撞管理与重叠检测控制淡入淡出时机，既避免摄像机碰撞导致的镜头突兀行为，又保证玩家始终可见主角。</p>
<span id="more"></span>

<h1 id="隐藏遮挡视线对象"><a href="#隐藏遮挡视线对象" class="headerlink" title="隐藏遮挡视线对象"></a>隐藏遮挡视线对象</h1><p>游戏场景中物体遮挡摄像机视线是常见问题：若为Camera&#x2F;SpringArm启用碰撞，会导致镜头突然凑近角色等违和行为；若禁用碰撞，俯视视角下高大物体易遮挡主角。因此需让遮挡视线的物体动态淡去，保证视野清晰。</p>
<h1 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h1><p>核心逻辑分为三部分：制作支持淡入淡出的动态材质、封装通用的Fade Actor基类、在角色侧控制淡入淡出时机。</p>
<h2 id="1-动态材质（淡入淡出核心）"><a href="#1-动态材质（淡入淡出核心）" class="headerlink" title="1. 动态材质（淡入淡出核心）"></a>1. 动态材质（淡入淡出核心）</h2><p>需制作支持透明度调节的动态材质，核心是添加Opacity参数控制淡入淡出效果：</p>
<ul>
<li>将材质的Blend Mode设为Masked；</li>
<li>在Opacity Mask选项中新增参数，并接入DitherTemporalAA节点，实现平滑的淡入淡出过渡；<br><img src="/ue5-blog/2025/12/17/SystemDesigns/VisualEffects/FadeActor/image.png" alt="alt text"></li>
</ul>
<h2 id="2-BP-FadeActor（通用淡入淡出基类）"><a href="#2-BP-FadeActor（通用淡入淡出基类）" class="headerlink" title="2. BP_FadeActor（通用淡入淡出基类）"></a>2. BP_FadeActor（通用淡入淡出基类）</h2><p>所有需动态淡去的物体均继承自BP_FadeActor，该类封装材质管理、淡入淡出逻辑、碰撞恢复等核心能力：</p>
<h3 id="2-1-材质管理"><a href="#2-1-材质管理" class="headerlink" title="2.1 材质管理"></a>2.1 材质管理</h3><ul>
<li>保存带Fade参数的基础材质，并为Mesh的每个材质槽逐一创建动态材质实例；</li>
<li>严格按材质槽顺序保存动态材质，避免材质显示错乱；<br><img src="/ue5-blog/2025/12/17/SystemDesigns/VisualEffects/FadeActor/image1.png" alt="alt text"></li>
</ul>
<h3 id="2-2-淡入淡出逻辑（FadeOut-FadeIn）"><a href="#2-2-淡入淡出逻辑（FadeOut-FadeIn）" class="headerlink" title="2.2 淡入淡出逻辑（FadeOut &amp; FadeIn）"></a>2.2 淡入淡出逻辑（FadeOut &amp; FadeIn）</h3><p>通过Timeline时间线动态调整材质的Opacity参数：</p>
<ul>
<li>利用Timeline的Reverse节点，复用同一时间线实现淡入（正向）、淡出（反向）；</li>
<li>通过Timeline终点的传出值，区分是淡入还是淡出触发后续的FadeFinished函数；<br><img src="/ue5-blog/2025/12/17/SystemDesigns/VisualEffects/FadeActor/image2.png" alt="alt text"></li>
</ul>
<h3 id="2-3-结束处理（FadeFinished）"><a href="#2-3-结束处理（FadeFinished）" class="headerlink" title="2.3 结束处理（FadeFinished）"></a>2.3 结束处理（FadeFinished）</h3><p>淡入&#x2F;淡出完成后处理碰撞逻辑：</p>
<ul>
<li>淡出时关闭物体碰撞响应（如避免子弹击中淡出物体触发爆炸）；</li>
<li>淡入时恢复碰撞响应，并将材质还原为原始状态；<br><img src="/ue5-blog/2025/12/17/SystemDesigns/VisualEffects/FadeActor/image3.png" alt="alt text"></li>
</ul>
<h2 id="3-角色侧触发逻辑"><a href="#3-角色侧触发逻辑" class="headerlink" title="3. 角色侧触发逻辑"></a>3. 角色侧触发逻辑</h2><p>在角色类中控制Fade Actor的淡入淡出时机，核心通过重叠检测实现：</p>
<ul>
<li>在角色与摄像机之间放置尺寸适配的Box碰撞体；</li>
<li>当Box触发重叠事件时，调用重叠对象的FadeOut（遮挡时）&#x2F;FadeIn（离开时）函数；</li>
<li>将FadeIn&#x2F;FadeOut封装为接口，仅对实现接口的物体生效，避免误操作无淡入淡出能力的对象。</li>
</ul>
<h3 id="关键优化：避免频繁淡入淡出"><a href="#关键优化：避免频繁淡入淡出" class="headerlink" title="关键优化：避免频繁淡入淡出"></a>关键优化：避免频繁淡入淡出</h3><p>由于使用重叠检测，需为Fade Actor配置Simple Box Collision（而非复杂碰撞）：</p>
<ul>
<li>复杂碰撞易导致物体边缘多次触发重叠事件，引发频繁淡入淡出；</li>
<li>简单盒碰撞可确保重叠事件仅触发一次，保证淡入淡出逻辑稳定。</li>
</ul>
]]></content>
      <categories>
        <category>SystemDesigns</category>
        <category>VisualEffects</category>
      </categories>
      <tags>
        <tag>Fade Actor</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/ue5-blog/2025/12/19/SystemDesigns/UI/DamageText/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Dissolve Effect</title>
    <url>/ue5-blog/2025/12/17/SystemDesigns/VisualEffects/DissolveEffect/</url>
    <content><![CDATA[<h1 id="核心总结"><a href="#核心总结" class="headerlink" title="核心总结"></a>核心总结</h1><p>Dissolve Effect（溶解效果）是提升游戏视觉表现力的经典动态材质效果，核心通过<code>UMaterialInstanceDynamic</code>（动态材质实例）结合Timeline时间线，动态修改材质参数（如溶解阈值），实现Mesh（角色&#x2F;武器）随时间渐进式溶解，并在溶解边缘生成高亮效果，典型应用于角色死亡、道具消失等场景。</p>
<span id="more"></span>

<h1 id="溶解效果的实现（基于动态材质）"><a href="#溶解效果的实现（基于动态材质）" class="headerlink" title="溶解效果的实现（基于动态材质）"></a>溶解效果的实现（基于动态材质）</h1><p>动态材质是实现Mesh视觉状态随时间变化的核心手段，溶解效果的核心逻辑是：通过调整材质的<code>Dissolve</code>参数生成随机噪声，使Mesh局部区域逐步消失，同时在边缘渲染高亮金光。<br><a href="/ue5-blog/2025/12/17/SystemDesigns/VisualEffects/DissolveEffect/M_DissolveEffect.uasset" download="M_DissolveEffect.uasset">点击下载溶解动态材质示例</a>;</p>
<p>以角色死亡时的渐进式溶解为例，核心实现步骤如下：</p>
<ol>
<li>为角色&#x2F;武器配置溶解效果的基础材质实例；</li>
<li>角色死亡时，将Mesh&#x2F;武器的材质替换为动态材质实例；</li>
<li>通过Timeline时间线按时间梯度修改动态材质的溶解参数，实现渐进溶解。</li>
</ol>
<h2 id="核心代码实现"><a href="#核心代码实现" class="headerlink" title="核心代码实现"></a>核心代码实现</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ABaseCharacter::Dissolve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">IsValid</span>(DissolveMaterialInstance))</span><br><span class="line">	&#123;</span><br><span class="line">		UMaterialInstanceDynamic* DynamicMatIns = UMaterialInstanceDynamic::<span class="built_in">Create</span>(DissolveMaterialInstance , <span class="keyword">this</span>);</span><br><span class="line">		<span class="built_in">GetMesh</span>()-&gt;<span class="built_in">SetMaterial</span>(<span class="number">0</span> , DynamicMatIns);</span><br><span class="line">		<span class="built_in">StartDissolveTimeline</span>(DynamicMatIns);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">IsValid</span>(WeaponDissolveMaterialInstance))</span><br><span class="line">	&#123;</span><br><span class="line">		UMaterialInstanceDynamic* DynamicMatIns = UMaterialInstanceDynamic::<span class="built_in">Create</span>(WeaponDissolveMaterialInstance , <span class="keyword">this</span>);</span><br><span class="line">		Weapon-&gt;<span class="built_in">SetMaterial</span>(<span class="number">0</span> , DynamicMatIns);</span><br><span class="line">		<span class="built_in">StartWeaponDissolveTimeline</span>(DynamicMatIns);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Timeline时间线配置（蓝图实现）"><a href="#Timeline时间线配置（蓝图实现）" class="headerlink" title="Timeline时间线配置（蓝图实现）"></a>Timeline时间线配置（蓝图实现）</h2><p><code>StartDissolveTimeline</code>和<code>StartWeaponDissolveTimeline</code>为蓝图可执行事件，将Timeline放在蓝图中便于可视化编辑溶解参数的时间曲线：<br><img src="/ue5-blog/2025/12/17/SystemDesigns/VisualEffects/DissolveEffect/image.png" alt="alt text"></p>
]]></content>
      <categories>
        <category>SystemDesigns</category>
        <category>VisualEffects</category>
      </categories>
      <tags>
        <tag>Dissolve Effect</tag>
      </tags>
  </entry>
  <entry>
    <title>序列化 (Serialize)</title>
    <url>/ue5-blog//2025/12/10/ProgrammingSkills/Serialize/</url>
    <content><![CDATA[<h1 id="核心总结"><a href="#核心总结" class="headerlink" title="核心总结"></a>核心总结</h1><p>序列化本质是将内存中的数据（变量、对象、结构体）转换为二进制&#x2F;字节流格式，便于持久化存储（存档）、网络传输（同步）；反序列化则是将字节流还原为内存中的原始数据。<br>在实际使用中，最常见的是存档读档、网络同步两大场景。对于如何进行相应的序列化操作，应当充分了解。</p>
<span id="more"></span>

<h1 id="为什么需要序列化"><a href="#为什么需要序列化" class="headerlink" title="为什么需要序列化"></a>为什么需要序列化</h1><p>原生内存中的数据（如角色血量、道具列表）仅在程序运行时存在，且无法直接跨进程&#x2F;网络传输，序列化解决了三大核心问题：</p>
<ol>
<li><strong>持久化存储</strong>：将游戏数据（玩家等级、进度、位置）转为字节流写入文件，实现存档&#x2F;读档，保证数据不随程序关闭丢失；</li>
<li><strong>网络同步</strong>：将服务器端的对象状态（敌人位置、角色血量）转为字节流传输到客户端，反序列化后还原，保证多端数据一致；</li>
<li><strong>跨平台兼容</strong>：二进制格式不依赖运行环境，可在PC&#x2F;主机&#x2F;移动端等不同平台间传输、读取数据。</li>
</ol>
<h1 id="存档与读档"><a href="#存档与读档" class="headerlink" title="存档与读档"></a>存档与读档</h1><p>UE中通过<code>UGameplayStatics::SaveGameToSlot</code>和<code>UGameplayStatics::LoadGameFromSlot</code>可快速完成存档&#x2F;读档，核心是自动将<code>USaveGame</code>子类对象序列化&#x2F;反序列化为二进制文件；开发中只需操作变量（无需直接处理二进制），但基础类型与复杂对象（如AActor）的处理逻辑不同：</p>
<h2 id="1-基础类型的自动序列化"><a href="#1-基础类型的自动序列化" class="headerlink" title="1. 基础类型的自动序列化"></a>1. 基础类型的自动序列化</h2><p>对于<code>int</code>&#x2F;<code>float</code>&#x2F;<code>FString</code>等基础类型，只需将变量放入继承<code>USaveGame</code>的存档类，并标记<code>UPROPERTY(SaveGame)</code>，调用以下接口即可自动完成序列化（存）&#x2F;反序列化（读）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 存档：将SaveGame对象序列化为二进制文件</span></span><br><span class="line">UGameplayStatics::<span class="built_in">SaveGameToSlot</span>(SaveGame , GI-&gt;LoadSlotName , GI-&gt;LoadSlotIndex);</span><br><span class="line"><span class="comment">// 读档：将二进制文件反序列化为SaveGame对象</span></span><br><span class="line">SaveGame = UGameplayStatics::<span class="built_in">LoadGameFromSlot</span>(GI-&gt;LoadSlotName , GI-&gt;LoadSlotIndex);</span><br></pre></td></tr></table></figure>

<h2 id="2-复杂对象（AActor）的手动序列化"><a href="#2-复杂对象（AActor）的手动序列化" class="headerlink" title="2. 复杂对象（AActor）的手动序列化"></a>2. 复杂对象（AActor）的手动序列化</h2><p>AActor作为复杂UObject，无法像基础类型一样直接序列化，需通过以下步骤将需保存的变量转为二进制存储到<code>SaveGame</code>的字节数组中：</p>
<h3 id="核心原理"><a href="#核心原理" class="headerlink" title="核心原理"></a>核心原理</h3><ul>
<li>步骤1：在目标AActor中，用<code>UPROPERTY(SaveGame)</code>标记需保存的变量（告知引擎序列化范围）；</li>
<li>步骤2：在<code>SaveGame</code>类中定义<code>TArray&lt;uint8&gt; Bytes</code>，作为存储Actor二进制数据的容器；</li>
<li>步骤3：存档时调用<code>Actor-&gt;Serialize()</code>，将标记的变量转为二进制写入<code>Bytes</code>；读档时反向读取<code>Bytes</code>还原变量；</li>
<li>步骤4：通过<code>SaveGameToSlot</code>&#x2F;<code>LoadGameFromSlot</code>存储&#x2F;读取包含<code>Bytes</code>的<code>SaveGame</code>对象，完成Actor数据的存档&#x2F;读档。</li>
</ul>
<h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 目标Actor（Checkpoint.h）</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>(BlueprintReadWrite , SaveGame)</span><br><span class="line"><span class="type">bool</span> bReached = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 存档类（SaveGame.h）</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>()</span><br><span class="line">TArray&lt;uint8&gt; Bytes;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 存档/读档逻辑（GameMode.cpp）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AGameModeBase::SaveWorldState</span><span class="params">(AActor* Actor)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">FMemoryWriter <span class="title">MemoryWriter</span><span class="params">(SaveGame.Bytes)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建存档专用归档器，标记为存档模式</span></span><br><span class="line">    <span class="function">FObjectAndNameAsStringProxyArchive <span class="title">Archive</span><span class="params">(MemoryWriter , <span class="literal">true</span>)</span></span>;</span><br><span class="line">    Archive.ArIsSaveGame = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 序列化Actor：将SaveGame标记的变量写入Bytes</span></span><br><span class="line">    Actor-&gt;<span class="built_in">Serialize</span>(Archive);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存SaveGame对象到文件</span></span><br><span class="line">    UGameplayStatics::<span class="built_in">SaveGameToSlot</span>(SaveGame , GI-&gt;LoadSlotName , GI-&gt;LoadSlotIndex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AGameModeBase::LoadWorldState</span><span class="params">(AActor* Actor)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SaveGame = UGameplayStatics::<span class="built_in">LoadGameFromSlot</span>(GI-&gt;LoadSlotName , GI-&gt;LoadSlotIndex);</span><br><span class="line"></span><br><span class="line">    <span class="function">FMemoryReader <span class="title">MemoryReader</span><span class="params">(SaveGame.Bytes)</span></span>;</span><br><span class="line">    <span class="function">FObjectAndNameAsStringProxyArchive <span class="title">Archive</span><span class="params">(MemoryReader , <span class="literal">true</span>)</span></span>;</span><br><span class="line">    Archive.ArIsSaveGame = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反序列化Actor：从Bytes还原SaveGame标记的变量</span></span><br><span class="line">    Actor-&gt;<span class="built_in">Serialize</span>(Archive);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行Actor的自定义加载逻辑（如接口函数）</span></span><br><span class="line">    ISaveInterface::<span class="built_in">Execute_LoadActor</span>(Actor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="网络序列化"><a href="#网络序列化" class="headerlink" title="网络序列化"></a>网络序列化</h1><p>UE网络同步的核心是将服务器数据序列化为二进制流传输到客户端，再反序列化还原；基础类型可由引擎自动完成序列化，自定义类型（如<code>FCustomGameplayEffectContext</code>）需手动重写<code>NetSerialize</code>函数，精准控制同步逻辑与传输开销。</p>
<h2 id="1-基础类型的自动网络序列化"><a href="#1-基础类型的自动网络序列化" class="headerlink" title="1. 基础类型的自动网络序列化"></a>1. 基础类型的自动网络序列化</h2><p>对于<code>int</code>&#x2F;<code>float</code>&#x2F;<code>FString</code>&#x2F;<code>FVector</code>等UE内置基础类型，仅需两步即可实现自动网络序列化：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 步骤1：标记需同步的变量</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>(Replicated)</span><br><span class="line"><span class="type">float</span> CurrentHealth = <span class="number">100.0f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 步骤2：重写注册函数，将变量加入同步列表</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">APlayerCharacter::GetLifetimeReplicatedProps</span><span class="params">(TArray&lt;FLifetimeProperty&gt;&amp; OutLifetimeProps)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Super::<span class="built_in">GetLifetimeReplicatedProps</span>(OutLifetimeProps);</span><br><span class="line">    <span class="built_in">DOREPLIFETIME</span>(APlayerCharacter, CurrentHealth);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 引擎自动行为：</span></span><br><span class="line"><span class="comment">// - 服务器修改CurrentHealth后，自动将其序列化为二进制流；</span></span><br><span class="line"><span class="comment">// - 二进制流传输到客户端后，引擎自动反序列化还原CurrentHealth值；</span></span><br><span class="line"><span class="comment">// - 无需手动处理二进制转换、数据传输逻辑。</span></span><br></pre></td></tr></table></figure>

<h2 id="2-自定义类型的手动网络序列化"><a href="#2-自定义类型的手动网络序列化" class="headerlink" title="2. 自定义类型的手动网络序列化"></a>2. 自定义类型的手动网络序列化</h2><p>自定义结构体&#x2F;类（如<code>FCustomGameplayEffectContext</code>）无法被引擎自动序列化，需重写<code>NetSerialize</code>函数，手动定义“哪些数据同步、如何同步”，核心是通过<code>RepBits</code>（位掩码）标记有效数据，减少网络传输开销。</p>
<h3 id="核心原理-1"><a href="#核心原理-1" class="headerlink" title="核心原理"></a>核心原理</h3><ul>
<li><p><code>NetSerialize</code>是网络序列化的核心接口，返回<code>bool</code>表示序列化&#x2F;反序列化是否成功；</p>
</li>
<li><p><code>RepBits</code>：用二进制位标记需同步的有效数据（仅传输有值数据，避免冗余）；</p>
</li>
<li><p><code>FArchive&amp; Ar</code>：存储二进制数据（<code>Ar.IsSaving()</code>&#x3D;服务器序列化，<code>Ar.IsLoading()</code>&#x3D;客户端反序列化）；</p>
</li>
<li><p><code>UPackageMap* Map</code>：处理UObject指针的网络映射（避免直接传输内存地址）；</p>
</li>
<li><p>核心流程：</p>
<ol>
<li>服务器：遍历变量→用<code>RepBits</code>标记有效数据→将数据写入<code>Ar</code>→传输二进制流；</li>
<li>客户端：读取<code>RepBits</code>→仅反序列化标记的有效数据→还原变量值。</li>
</ol>
</li>
</ul>
<h3 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">FCustomGameplayEffectContext::NetSerialize</span><span class="params">(FArchive&amp; Ar, <span class="keyword">class</span> UPackageMap* Map, <span class="type">bool</span>&amp; bOutSuccess)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 步骤1：定义位掩码RepBits</span></span><br><span class="line">    uint32 RepBits = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Ar.<span class="built_in">IsSaving</span>()) <span class="comment">// 服务器：标记需同步的有效数据</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 每一位对应一个变量，数据有效则置位</span></span><br><span class="line">        <span class="keyword">if</span> (bReplicateInstigator &amp;&amp; Instigator.<span class="built_in">IsValid</span>()) &#123; RepBits |= <span class="number">1</span> &lt;&lt; <span class="number">0</span>; &#125;</span><br><span class="line">        <span class="keyword">if</span> (bReplicateEffectCauser &amp;&amp; EffectCauser.<span class="built_in">IsValid</span>()) &#123; RepBits |= <span class="number">1</span> &lt;&lt; <span class="number">1</span>; &#125;</span><br><span class="line">        <span class="keyword">if</span> (AbilityCDO.<span class="built_in">IsValid</span>()) &#123; RepBits |= <span class="number">1</span> &lt;&lt; <span class="number">2</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 步骤2：序列化RepBits（客户端先读RepBits，才知道要解析哪些数据）</span></span><br><span class="line">    Ar.<span class="built_in">SerializeBits</span>(&amp;RepBits, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 步骤3：根据RepBits序列化/反序列化对应变量</span></span><br><span class="line">    <span class="keyword">if</span> (RepBits &amp; (<span class="number">1</span> &lt;&lt; <span class="number">0</span>)) &#123; Ar &lt;&lt; Instigator; &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 容器类型：调用专用序列化函数</span></span><br><span class="line">    <span class="keyword">if</span> (RepBits &amp; (<span class="number">1</span> &lt;&lt; <span class="number">4</span>)) &#123; <span class="built_in">SafeNetSerializeTArray_Default</span>&lt;<span class="number">31</span>&gt;(Ar, Actors); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复杂子类型：调用自身NetSerialize函数</span></span><br><span class="line">    <span class="keyword">if</span> (RepBits &amp; (<span class="number">1</span> &lt;&lt; <span class="number">5</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (Ar.<span class="built_in">IsLoading</span>() &amp;&amp; !HitResult.<span class="built_in">IsValid</span>()) &#123; HitResult = <span class="built_in">MakeShared</span>&lt;FHitResult&gt;(); &#125;</span><br><span class="line">        HitResult-&gt;<span class="built_in">NetSerialize</span>(Ar, Map, bOutSuccess);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 嵌套逻辑：仅bIsRadialDamage有效时，才同步其下的子变量</span></span><br><span class="line">    <span class="keyword">if</span> (RepBits &amp; (<span class="number">1</span> &lt;&lt; <span class="number">16</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        Ar &lt;&lt; bIsRadialDamage;</span><br><span class="line">        <span class="keyword">if</span> (RepBits &amp; (<span class="number">1</span> &lt;&lt; <span class="number">17</span>)) &#123; Ar &lt;&lt; RadialDamageInnerRadius; &#125;</span><br><span class="line">        <span class="keyword">if</span> (RepBits &amp; (<span class="number">1</span> &lt;&lt; <span class="number">18</span>)) &#123; Ar &lt;&lt; RadialDamageOuterRadius; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 步骤4：客户端加载后初始化关联逻辑</span></span><br><span class="line">    <span class="keyword">if</span> (Ar.<span class="built_in">IsLoading</span>()) &#123; <span class="built_in">AddInstigator</span>(Instigator.<span class="built_in">Get</span>(), EffectCauser.<span class="built_in">Get</span>()); &#125;</span><br><span class="line"></span><br><span class="line">    bOutSuccess = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TStructOpsTypeTraits</span>&lt;FCustomGameplayEffectContext&gt; : <span class="keyword">public</span> TStructOpsTypeTraitsBase2&lt;FCustomGameplayEffectContext&gt;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">enum</span></span><br><span class="line">	&#123;</span><br><span class="line">		WithNetSerializer = <span class="literal">true</span>, <span class="comment">// 标记支持网络序列化</span></span><br><span class="line">		WithCopy = <span class="literal">true</span> <span class="comment">// 标记支持拷贝操作</span></span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ProgrammingSkills</category>
      </categories>
      <tags>
        <tag>Serialize</tag>
      </tags>
  </entry>
</search>
