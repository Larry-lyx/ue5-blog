<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>/ue5-blog/2025/12/08/ProgrammingSkills/Networking/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/ue5-blog/2025/12/06/ProgrammingSkills/Reflection/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/ue5-blog/2025/12/07/ProgrammingSkills/Interface/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>委托 (Delegate)</title>
    <url>/ue5-blog/2025/12/09/ProgrammingSkills/Delegate/</url>
    <content><![CDATA[<h1 id="核心总结"><a href="#核心总结" class="headerlink" title="核心总结"></a>核心总结</h1><p>委托的核心价值可概括为两点：</p>
<ol>
<li><p><strong>解耦：</strong><br>发送方仅负责在合适时机广播事件，无需知晓接收方逻辑；接收方专注实现回调，无需关联发送方细节，双方独立扩展逻辑。</p>
</li>
<li><p><strong>异步：</strong><br>接收方无需预判事件触发时间，只需提前绑定回调函数，事件广播时自动执行，降低时机同步成本。</p>
</li>
</ol>
<span id="more"></span>

<h1 id="什么是委托-Delegate"><a href="#什么是委托-Delegate" class="headerlink" title="什么是委托(Delegate)"></a>什么是委托(Delegate)</h1><p>游戏系统中存在大量跨对象的交互事件——事件发起者执行某个行为后，其他对象需要对该行为做出响应。</p>
<p>以“子弹击中敌人”为例：子弹触发Overlap事件是行为发起端，若直接在子弹代码中修改敌人血量、硬直等属性，会导致代码扩展性极差（比如不同敌人有不同的减伤、免硬直等差异化逻辑）。核心问题在于：子弹无需知晓被击中对象的具体类型和响应逻辑，所有“受击后的处理”都应归属于被击中对象自身。</p>
<p>委托（Delegate）正是解决这类问题的核心机制，其本质是一套“事件通信管道”：</p>
<ul>
<li>事件发起者只需负责向“管道”发送消息，无需关心谁会接收、如何处理；</li>
<li>事件接收者提前将处理逻辑（回调函数）绑定到“管道”，当收到消息时自动执行逻辑。</li>
</ul>
<p>需明确委托机制的三个核心要素：</p>
<ol>
<li>委托事件（即“通信管道”）：需要定义在某个通用类中；</li>
<li>消息发送：事件发起方在合适的时机触发委托、广播消息；</li>
<li>回调绑定：事件接收方需在事件发生前，将处理函数绑定到委托上。</li>
</ol>
<p>这里的核心易错点是<strong>绑定时机</strong>：回调函数的绑定必须早于委托广播，否则接收方无法响应。即便在“自身向自身发消息”的场景中，代码层面仍需先定义回调逻辑、完成绑定，再执行委托广播——回调函数的代码书写顺序在前，实际执行却在收到消息后，这也是委托使用中易混淆的点。</p>
<h1 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// DelegateSender.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 动态多播委托（支持蓝图绑定）：需声明参数类型+参数名</span></span><br><span class="line"><span class="built_in">DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam</span>(FOnSingleParamEvent, int32, DamageValue); </span><br><span class="line"><span class="comment">// 2. 普通多播委托（仅C++可用）：只需参数类型，参数名用注释说明（提升可读性）</span></span><br><span class="line"><span class="built_in">DECLARE_MULTICAST_DELEGATE_TwoParams</span>(FOnTwoParamEvent, FVector, <span class="comment">/* HitLocation */</span>, AActor*, <span class="comment">/* HitActor */</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// MULTICAST表示有多个接受方，多个接收方都会自动执行回调</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 委托发送方类（示例：子弹类）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GAME_API</span> UDelegateSender : <span class="keyword">public</span> UObject</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 声明委托实例（供外部绑定回调）</span></span><br><span class="line">    FOnSingleParamEvent OnDamageEvent;       <span class="comment">// 单参数委托实例（如传递伤害值）</span></span><br><span class="line">    FOnTwoParamEvent OnHitEvent;             <span class="comment">// 双参数委托实例（如传递击中位置+击中对象）</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// DelegateSender.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 委托发送方：在事件触发时机广播委托（示例：子弹检测到击中时）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UDelegateSender::TriggerHitEvent</span><span class="params">(int32 Damage, FVector HitLoc, AActor* HitActor)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 广播委托：所有绑定的回调函数会自动执行</span></span><br><span class="line">    OnDamageEvent.<span class="built_in">Broadcast</span>(Damage);</span><br><span class="line">    OnHitEvent.<span class="built_in">Broadcast</span>(HitLoc, HitActor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// DelegateReceiver.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;DelegateReceiver.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;DelegateSender.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 委托接收方：绑定回调函数到发送方的委托（需在事件触发前完成绑定）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UDelegateReceiver::BindToDelegate</span><span class="params">(UDelegateSender* Sender)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!Sender) <span class="keyword">return</span>; <span class="comment">// 空指针校验</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方式1：绑定成员函数（最常用）</span></span><br><span class="line">    <span class="comment">// AddUObject：接收方为UObject子类时使用，自动处理生命周期（对象销毁时解绑）</span></span><br><span class="line">    Sender-&gt;OnDamageEvent.<span class="built_in">AddUObject</span>(<span class="keyword">this</span>, &amp;UDelegateReceiver::OnReceiveDamage);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方式2：绑定Lambda表达式（适合简单逻辑，无需单独写成员函数）</span></span><br><span class="line">    Sender-&gt;OnHitEvent.<span class="built_in">AddLambda</span>(</span><br><span class="line">        [<span class="keyword">this</span>](FVector HitLocation, AActor* HitActor) <span class="comment">// 捕获this以访问接收方成员</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 击中事件的回调逻辑</span></span><br><span class="line">            <span class="built_in">UE_LOG</span>(LogTemp, Log, <span class="built_in">TEXT</span>(<span class="string">&quot;击中位置：%s&quot;</span>), *HitLocation.<span class="built_in">ToString</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 委托回调函数（对应OnDamageEvent）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UDelegateReceiver::OnReceiveDamage</span><span class="params">(int32 DamageValue)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 接收方的处理逻辑</span></span><br><span class="line">    <span class="built_in">UE_LOG</span>(LogTemp, Log, <span class="built_in">TEXT</span>(<span class="string">&quot;收到伤害值：%d&quot;</span>), DamageValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="疑难解释"><a href="#疑难解释" class="headerlink" title="疑难解释"></a>疑难解释</h1><h2 id="1-委托的定义位置：并非必须绑定发送方"><a href="#1-委托的定义位置：并非必须绑定发送方" class="headerlink" title="1. 委托的定义位置：并非必须绑定发送方"></a>1. 委托的定义位置：并非必须绑定发送方</h2><p>委托的声明位置可灵活调整——既可以定义在事件发送方，也可以定义在接收方，但核心前提是：<strong>委托的广播方（实际触发者）必须能获取到委托所属类的实例</strong>。</p>
<p>这一点容易引发“解耦不彻底”的疑问：绑定回调时，接收方需要包含委托定义类的头文件，看似仍存在耦合。以子弹击中敌人的场景为例：若委托定义在子弹类（发送方），敌人需持有子弹指针才能绑定回调，这意味着“敌人必须知道触发伤害的具体类型”；即便委托定义在敌人类（接收方），子弹需知道敌人的类型才能广播委托——两种方式都违背“敌人无需知晓攻击来源、子弹无需知晓被击目标”的解耦原则（尤其当子弹&#x2F;敌人类型扩展后，代码修改成本会急剧增加）。</p>
<h2 id="2-解耦方案：委托归属于“通用基类”"><a href="#2-解耦方案：委托归属于“通用基类”" class="headerlink" title="2. 解耦方案：委托归属于“通用基类”"></a>2. 解耦方案：委托归属于“通用基类”</h2><p>为进一步解耦，实战中会将委托定义在<strong>通用基类</strong>中：</p>
<ul>
<li>发送方（如子弹）仅需依赖该通用基类，无需知晓具体接收方类型，只需在事件触发时调用基类的委托广播接口；</li>
<li>接收方（如不同类型的敌人、道具）继承该通用基类，重写&#x2F;绑定自定义回调函数，实现差异化的事件处理；</li>
<li>核心优势：发送方和接收方仅依赖“通用基类”，彼此完全隔离，新增子弹&#x2F;敌人类型时无需修改原有逻辑。</li>
</ul>
<p>需要注意的是，委托代表的通信管道是和<strong>实例</strong>同级的，一个实例代表一个单独的通信管道。</p>
<h2 id="3-场景适配：委托-vs-GAS的GE（GameplayEffect）"><a href="#3-场景适配：委托-vs-GAS的GE（GameplayEffect）" class="headerlink" title="3. 场景适配：委托 vs GAS的GE（GameplayEffect）"></a>3. 场景适配：委托 vs GAS的GE（GameplayEffect）</h2><p>子弹击中造成伤害、附加Debuff、击飞（Knockback）等战斗事件，看似可用委托实现，但这类事件的上下文（伤害数值、Debuff类型、击飞力度等）复杂且需支持扩展，纯委托方案会因参数膨胀、逻辑分散变得难以维护。</p>
<p>在GAS框架中，这类战斗事件更适合用 <strong>GE</strong> 处理：GE天然封装了属性修改、效果叠加、持续时间等战斗逻辑，且通过GameplayTag实现灵活的触发&#x2F;取消规则，比委托更贴合“技能-属性-状态”的联动需求。</p>
<p>而简单的多播委托更适配<strong>UI交互场景</strong>：比如角色属性（血量、蓝量）变化时更新UI、技能冷却完成时刷新按钮状态——此时可将委托定义在ASC中，所有UI组件绑定该委托，当属性&#x2F;状态变更时广播委托，UI组件自动更新显示，无需业务逻辑层关心具体UI实现。这也是GAS框架中ASC、AS的核心作用之一：作为“通用事件枢纽”，统一管理属性变更、技能状态等事件的广播与回调，兼顾解耦与扩展性。</p>
]]></content>
      <categories>
        <category>ProgrammingSkills</category>
      </categories>
      <tags>
        <tag>Delegate</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/ue5-blog/2025/12/08/ProgrammingSkills/Lock/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>AbilitySystemComponent</title>
    <url>/ue5-blog/2025/12/08/SystemDesigns/GAS/AbilitySystemComponent/</url>
    <content><![CDATA[<h1 id="ASC-Ability-System-Component-的作用"><a href="#ASC-Ability-System-Component-的作用" class="headerlink" title="ASC(Ability System Component)的作用"></a>ASC(Ability System Component)的作用</h1>]]></content>
      <categories>
        <category>SystemDesgins</category>
        <category>GAS</category>
      </categories>
      <tags>
        <tag>GAS</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/ue5-blog/2025/12/06/ProgrammingSkills/Singleton/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/ue5-blog/2025/12/07/SystemDesigns/GAS/GameplayAbility/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/ue5-blog/2025/12/06/SystemDesigns/GAS/GAS/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/ue5-blog/2025/12/07/ProgrammingSkills/Serialize/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/ue5-blog/2025/12/07/SystemDesigns/GAS/AttributeSet/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/ue5-blog/2025/12/07/SystemDesigns/GAS/GameplayCue/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/ue5-blog/2025/12/08/SystemDesigns/Input/Highlight/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/ue5-blog/2025/12/08/SystemDesigns/DataDriven/Data/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/ue5-blog/2025/12/06/SystemDesigns/UI/MVC/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/ue5-blog/2025/12/08/SystemDesigns/SaveAndLoad/Load/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/ue5-blog/2025/12/07/SystemDesigns/GAS/GameplayEffect/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/ue5-blog/2025/12/08/SystemDesigns/GAS/GameplayTag/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/ue5-blog/2025/12/08/SystemDesigns/SaveAndLoad/Save/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/ue5-blog/2025/12/06/SystemDesigns/UI/MVVM/</url>
    <content><![CDATA[]]></content>
  </entry>
</search>
