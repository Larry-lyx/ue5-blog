<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>类的继承 (Inheritance)</title>
    <url>/ue5-blog/2025/12/09/ProgrammingSkills/Inheritance/</url>
    <content><![CDATA[<h1 id="核心总结"><a href="#核心总结" class="headerlink" title="核心总结"></a>核心总结</h1><p>类的继承是游戏开发中实现代码复用、逻辑扩展的核心手段，其核心价值在于：</p>
<ul>
<li>通过基类统一抽象通用逻辑，子类定制差异化行为；</li>
<li>保证代码可维护性，尤其在C++&#x2F;蓝图混合开发中，需兼顾封装性与灵活扩展。</li>
</ul>
<span id="more"></span>

<h1 id="基类"><a href="#基类" class="headerlink" title="基类"></a>基类</h1><p>游戏开发中，为同类对象构建基类是提升开发效率的核心习惯，核心原因有二：</p>
<ol>
<li><strong>通用逻辑复用</strong>：大量游戏对象（如敌人、道具、技能）存在共性属性&#x2F;行为（如血量、受击逻辑、销毁逻辑），基类可集中封装这些通用逻辑，避免重复编码；</li>
<li><strong>批量扩展便捷</strong>：后续需为某类对象新增功能（如所有敌人添加“被击硬直”）时，只需修改基类，所有子类自动继承，无需逐个调整。</li>
</ol>
<p>在UE开发中，几乎所有自定义C++类都会配套创建<strong>蓝图基类</strong>，核心优势在于：</p>
<ul>
<li>配置灵活：无需硬编码&#x2F;重新编译，即可调整Mesh、数值参数（如敌人血量、技能冷却时间），快速验证效果；</li>
<li>轻量逻辑快速迭代：简单逻辑（如UI提示、音效触发）可直接在蓝图中实现，开发效率高，且非密集计算类逻辑几乎无性能损耗。</li>
</ul>
<p>但蓝图也有明确的使用边界：</p>
<ul>
<li>复杂逻辑易因节点布线混乱导致维护成本高；</li>
<li>版本控制中难以追踪蓝图的具体修改内容。<br>因此最佳实践是：蓝图仅处理“配置+极简逻辑”，复杂逻辑仍放在C++中实现。</li>
</ul>
<h1 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h1><p>丰富的功能实现依赖灵活的继承体系：子类可继承父类的变量&#x2F;函数，也可重写函数逻辑，极大提升代码扩展性。</p>
<h2 id="核心问题：为何要区分-public-protected-private-访问权限？"><a href="#核心问题：为何要区分-public-protected-private-访问权限？" class="headerlink" title="核心问题：为何要区分 public&#x2F;protected&#x2F;private 访问权限？"></a>核心问题：为何要区分 public&#x2F;protected&#x2F;private 访问权限？</h2><p>个人开发中，若类的规模小、仅自己维护，权限区分的影响不明显；但在团队协作或源码复用场景下，权限划分是“降低理解成本、避免逻辑混乱”的关键：</p>
<ul>
<li><strong>public</strong>：对外暴露的核心接口（如<code>GetHealth()</code>），使用者无需关注内部实现，直接调用即可；</li>
<li><strong>protected</strong>：仅子类可访问&#x2F;重写的逻辑（如<code>OnTakeDamage()</code>），保证子类可定制，又避免外部随意调用；</li>
<li><strong>private</strong>：父类纯内部逻辑（如辅助计算的临时变量），完全隐藏实现细节，防止意外篡改。</li>
</ul>
<p>因此，当类的逻辑逐渐复杂时，需梳理头文件：明确权限划分、添加注释说明接口用途，让使用者快速知晓“哪些可调用、哪些可重写、哪些不可触碰”，无需深挖实现细节。</p>
<h1 id="类与实例"><a href="#类与实例" class="headerlink" title="类与实例"></a>类与实例</h1><p>类是“模板”，实例是基于模板创建的“具体对象”：类中定义的非静态变量&#x2F;函数，会在每个实例中独立存在（如两个Enemy实例的血量、位置相互独立）。</p>
<h2 id="静态成员的适用场景"><a href="#静态成员的适用场景" class="headerlink" title="静态成员的适用场景"></a>静态成员的适用场景</h2><p>对无需区分实例的通用逻辑&#x2F;数据（如全局配置、工具函数），可添加<code>static</code>关键字绑定到类上，核心优势：</p>
<ol>
<li>性能优化：无需创建实例即可调用，减少内存占用；</li>
<li>逻辑统一：所有实例共享同一数据&#x2F;逻辑。</li>
</ol>
<h2 id="关键注意点"><a href="#关键注意点" class="headerlink" title="关键注意点"></a>关键注意点</h2><p>UE开发中需牢记：继承后的属性&#x2F;函数始终归属于“具体实例”，而非类本身。例如：</p>
<ul>
<li>为<code>Enemy1</code>实例绑定的受击回调，仅会响应该实例的受击事件；</li>
<li>修改<code>Enemy2</code>实例的血量，不会影响其他Enemy实例的状态。<br>即使IDE的自动提示已经十分完善，也需时刻明确“操作的是类模板还是实例对象”，避免因边界混淆导致逻辑错误。</li>
</ul>
]]></content>
      <categories>
        <category>ProgrammingSkills</category>
      </categories>
      <tags>
        <tag>Inheritance</tag>
      </tags>
  </entry>
  <entry>
    <title>实例化 (Instance)</title>
    <url>/ue5-blog/2025/12/08/ProgrammingSkills/Instance/</url>
    <content><![CDATA[<h1 id="核心总结"><a href="#核心总结" class="headerlink" title="核心总结"></a>核心总结</h1><span id="more"></span>]]></content>
      <categories>
        <category>ProgrammingSkills</category>
      </categories>
      <tags>
        <tag>Instance</tag>
      </tags>
  </entry>
  <entry>
    <title>函数库 (Library)</title>
    <url>/ue5-blog/2025/12/10/ProgrammingSkills/Library/</url>
    <content><![CDATA[<h1 id="核心总结"><a href="#核心总结" class="headerlink" title="核心总结"></a>核心总结</h1><p>自定义函数库是UE开发中解耦跨类通用逻辑、提升代码复用性的核心手段，通过封装静态通用函数，可避免重复编码、减少性能损耗（如频繁Cast），同时让跨模块&#x2F;无继承关系的类高效共享算法与工具逻辑。</p>
<span id="more"></span>

<h1 id="自定义函数库的优势"><a href="#自定义函数库的优势" class="headerlink" title="自定义函数库的优势"></a>自定义函数库的优势</h1><ol>
<li><strong>解耦跨类复用逻辑</strong>：许多通用算法（如位置计算、数据校验）的使用方无明显继承关系（如敌人召唤逻辑、战利品生成、弹道计算），函数库可作为“公共逻辑容器”，脱离类的继承层级限制；</li>
<li><strong>提升开发效率</strong>：将可复用逻辑（如角色周围随机位置生成）提前封装为通用函数，后续开发无需重复编写&#x2F;调试，直接调用即可；</li>
<li><strong>全局高效访问</strong>：函数库中的函数需声明为<code>static</code>（静态），无需创建类实例即可调用，兼顾全局访问性与性能；</li>
<li><strong>统一维护入口</strong>：通用逻辑集中管理，后续修改（如调整位置算法的精度）只需改函数库，所有调用方自动生效，降低维护成本。</li>
</ol>
<h1 id="自定义函数库的核心内容"><a href="#自定义函数库的核心内容" class="headerlink" title="自定义函数库的核心内容"></a>自定义函数库的核心内容</h1><h2 id="1-通用算法（通用化参数设计）"><a href="#1-通用算法（通用化参数设计）" class="headerlink" title="1. 通用算法（通用化参数设计）"></a>1. 通用算法（通用化参数设计）</h2><p>封装无业务耦合的纯算法逻辑，参数设计需足够通用，避免硬编码，适配多场景调用。</p>
<h3 id="2-轻量化类型转换（封装static-cast的Setter-Getter）"><a href="#2-轻量化类型转换（封装static-cast的Setter-Getter）" class="headerlink" title="2. 轻量化类型转换（封装static_cast的Setter&#x2F;Getter）"></a>2. 轻量化类型转换（封装static_cast的Setter&#x2F;Getter）</h3><p>UE中<code>Cast</code>操作（动态类型转换）性能开销大，需尽量避免；对于自定义扩展的框架类型（如GAS的<code>GameplayEffectContext</code>），可将<code>static_cast</code>封装到函数库，减少重复转换逻辑，提升调用效率。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UCustomAbilitySystemLibrary::SetIsBlockedHit</span><span class="params">(FGameplayEffectContextHandle&amp; EffectContextHandle, <span class="type">bool</span> bInIsBlockedHit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (FCustomGameplayEffectContext* CustomContext = <span class="built_in">static_cast</span>&lt;FCustomGameplayEffectContext*&gt;(EffectContextHandle.<span class="built_in">Get</span>()))</span><br><span class="line">	&#123;</span><br><span class="line">		CustomContext-&gt;<span class="built_in">SetBlockedHit</span>(bInIsBlockedHit);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="自定义函数库的关键规范"><a href="#自定义函数库的关键规范" class="headerlink" title="自定义函数库的关键规范"></a>自定义函数库的关键规范</h3><ol>
<li><strong>类继承要求</strong>：必须继承<code>UBlueprintFunctionLibrary</code>，否则无法作为全局函数库使用；</li>
<li><strong>函数声明规则</strong>：<ul>
<li>函数需为<code>static</code> + <code>UFUNCTION(BlueprintCallable)</code>，支持C++&#x2F;蓝图双端调用；</li>
<li>加<code>Category</code>分类，便于蓝图中搜索和管理；</li>
</ul>
</li>
<li><strong>参数设计原则</strong>：<ul>
<li>通用算法参数“按需开放”（如角度范围设默认值），适配多场景；</li>
<li>避免传入冗余参数，核心参数前置，可选参数后置并设默认值；</li>
</ul>
</li>
<li><strong>性能注意</strong>：<ul>
<li>函数库仅封装轻量逻辑（算法、类型转换），不存放状态变量；</li>
<li>避免在函数库中执行耗时操作（如加载资源、遍历大量数据）；</li>
</ul>
</li>
<li><strong>头文件循环引用提醒</strong>：<br>函数库中若直接引用其他类的头文件，这些被引用的类将无法反向包含函数库头文件（触发循环引用报错）。建议通过“前向声明”替代直接包含：仅在函数库头文件中对所需类做前向声明（如<code>class FCustomGameplayEffectContext;</code>），函数具体实现放在cpp文件中，且仅在cpp里包含对应类的头文件，避免循环引用问题。</li>
</ol>
]]></content>
      <categories>
        <category>ProgrammingSkills</category>
      </categories>
      <tags>
        <tag>Library</tag>
      </tags>
  </entry>
  <entry>
    <title>接口 (Interface)</title>
    <url>/ue5-blog/2025/12/09/ProgrammingSkills/Interface/</url>
    <content><![CDATA[<h1 id="核心总结"><a href="#核心总结" class="headerlink" title="核心总结"></a>核心总结</h1><p>接口是游戏开发中“按功能归类”的核心手段，可突破类继承的层级限制，让不同类型的对象实现同一套功能逻辑；<br>在UE中结合<code>BlueprintNativeEvent</code>使用，既能保证功能统一，又能避免频繁类型转换(Cast)，提升代码效率与扩展性。</p>
<span id="more"></span>

<h1 id="为什么需要接口-Interface"><a href="#为什么需要接口-Interface" class="headerlink" title="为什么需要接口(Interface)"></a>为什么需要接口(Interface)</h1><p>按“对象类型”的继承体系（如EnemyBase→Enemy1、ItemBase→Collectible）能解决同类对象的复用问题，但无法满足“跨类型共享功能”的需求：<br>例如开发“鼠标指向目标高亮”功能时，敌人、收集物、地图出入口等完全不同的对象，都需要实现高亮逻辑——这些对象类型差异极大，无法通过继承复用代码，而接口正是解决这类问题的核心方案。</p>
<p>从调用方视角（如PlayerController），实现高亮功能无需知晓目标是“敌人”还是“收集物”，只需明确两个核心：</p>
<ol>
<li>目标是否支持高亮功能；</li>
<li>如何触发目标的高亮逻辑。</li>
</ol>
<p>接口的本质是功能约定：</p>
<ul>
<li>接口类仅声明功能（如<code>HighlightActor()</code>），不实现具体逻辑；</li>
<li>任意对象只要继承该接口，就必须实现对应的功能逻辑；</li>
<li>调用方只需针对接口编程，无需关注对象具体类型，且子类实现接口函数时，可直接使用自身的成员变量（如敌人的Mesh、收集物的Sprite）。</li>
</ul>
<h1 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Interface.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// UE接口必须用此宏声明（替代GENERATED_BODY）</span></span><br><span class="line"><span class="built_in">UINTERFACE</span>(MinimalAPI)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UHighlightInterface</span> : <span class="keyword">public</span> UInterface</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">GENERATED_BODY</span>()</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GAME_API</span> IHighlightInterface</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">UFUNCTION</span>(BlueprintNativeEvent)</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">HighlightActor</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Enemy.h</span></span><br><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GAME_API</span> AEnemy : <span class="keyword">public</span> IHighlightInterface</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">HighlightActor_Implementation</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Enemy.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AEnemy::HighlightActor_Implementation</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">GetMesh</span>()-&gt;<span class="built_in">SetRenderCustomDepth</span>(<span class="literal">true</span>);</span><br><span class="line">	Weapon-&gt;<span class="built_in">SetRenderCustomDepth</span>(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// PlayerController.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">APlayerController::HighlightActor</span><span class="params">(AActor* InActor)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">IsValid</span>(InActor) &amp;&amp; InActor-&gt;<span class="built_in">Implements</span>&lt;UHighlightInterface&gt;())</span><br><span class="line">	&#123;</span><br><span class="line">		IHighlightInterface::<span class="built_in">Execute_HighlightActor</span>(InActor);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h1><h2 id="使用BlueprintNativeEvent避免频繁Cast"><a href="#使用BlueprintNativeEvent避免频繁Cast" class="headerlink" title="使用BlueprintNativeEvent避免频繁Cast"></a>使用BlueprintNativeEvent避免频繁Cast</h2><p>Cast 操作会产生类型检查开销，尤其在高频调用（如每帧检测鼠标指向）时，直接用<code>Implements&lt;&gt;+Execute_</code>调用接口函数，效率远高于<code>Cast&lt;IHighlightInterface&gt;(InActor)</code>后调用函数。</p>
<h2 id="接口的继承特性"><a href="#接口的继承特性" class="headerlink" title="接口的继承特性"></a>接口的继承特性</h2><p>若父类实现了某接口，其子类会自动继承该接口（如 EnemyBase 实现 IHighlightInterface，Enemy1&#x2F;Enemy2 无需重复声明即可使用高亮功能）。</p>
]]></content>
      <categories>
        <category>ProgrammingSkills</category>
      </categories>
      <tags>
        <tag>Interface</tag>
      </tags>
  </entry>
  <entry>
    <title>反射系统 (Reflection)</title>
    <url>/ue5-blog/2025/12/09/ProgrammingSkills/Reflection/</url>
    <content><![CDATA[<h1 id="核心总结"><a href="#核心总结" class="headerlink" title="核心总结"></a>核心总结</h1><p>UE的反射系统是突破C++静态编译限制的核心机制，通过一系列宏为C++代码注入“运行时类型信息”，实现蓝图交互、序列化、编辑器可视化、属性自动同步等关键功能；<br>在实际应用中最需要的，就是熟悉一些常用的反射宏。</p>
<span id="more"></span>

<h1 id="为什么需要反射-Reflection"><a href="#为什么需要反射-Reflection" class="headerlink" title="为什么需要反射(Reflection)"></a>为什么需要反射(Reflection)</h1><p>原生C++是静态编译型语言，编译后丢失类、属性、函数的元信息，无法在运行时动态获取&#x2F;修改类的成员（比如无法通过字符串“Health”直接找到角色的血量变量）。</p>
<p>而游戏开发中，大量场景需要“运行时动态操作类成员”：</p>
<ul>
<li>蓝图要访问C++定义的血量、技能函数；</li>
<li>存档系统要自动序列化&#x2F;反序列化角色属性；</li>
<li>编辑器要可视化显示C++变量（如Mesh、数值参数）并支持实时修改；</li>
<li>GAS要动态遍历角色的Attribute属性，实现技能效果计算。</li>
</ul>
<p>UE的反射系统正是为解决这些问题而生：通过反射宏标记C++元素，让UE在编译时生成额外的“元信息表”，运行时可通过该表动态访问、修改类的成员，无需硬编码关联。</p>
<h1 id="UE中的反射宏"><a href="#UE中的反射宏" class="headerlink" title="UE中的反射宏"></a>UE中的反射宏</h1><h2 id="UCLASS"><a href="#UCLASS" class="headerlink" title="UCLASS"></a>UCLASS</h2><p>创建类时自动生成核心宏（<code>GENERATED_BODY()</code>），无需手动修改；</p>
<h2 id="UPROPERTY"><a href="#UPROPERTY" class="headerlink" title="UPROPERTY"></a>UPROPERTY</h2><ol>
<li><strong>编辑器权限</strong><ul>
<li><code>EditDefaultsOnly</code>：仅蓝图&#x2F;类的默认值面板可修改，场景实例不可改；</li>
<li><code>EditAnywhere</code>：蓝图默认值+场景实例面板均可修改。</li>
</ul>
</li>
<li><strong>蓝图权限</strong><ul>
<li><code>BlueprintReadOnly</code>：蓝图仅可读，不可修改；</li>
<li><code>BlueprintReadWrite</code>：蓝图可读写，仅在蓝图需操作该变量时使用。</li>
</ul>
</li>
<li><strong>分类管理</strong><ul>
<li><code>Category = &quot;父类 | 子类&quot;</code>：用<code>|</code>分割层级（如<code>Category = &quot;Enemy | Combat&quot;</code>），让编辑器面板属性归类更清晰。</li>
</ul>
</li>
<li><strong>委托专属</strong><ul>
<li><code>BlueprintAssignable</code>：蓝图可绑定委托回调；</li>
<li><code>BlueprintCallable</code>：蓝图可主动触发委托广播；</li>
<li>注：仅<code>DECLARE_DYNAMIC_*</code>系列动态委托支持上述关键字，原生委托（无DYNAMIC）无效。</li>
</ul>
</li>
<li><strong>存档序列化</strong><ul>
<li><code>SaveGame</code>：标记变量需纳入存档系统，读档时自动恢复值。</li>
</ul>
</li>
<li><strong>私有变量暴露</strong><ul>
<li><code>meta = (AllowPrivateAccess = &quot;true&quot;)</code>：private中的变量需加此元数据，才能被反射系统识别（蓝图&#x2F;编辑器可见）。</li>
</ul>
</li>
<li><strong>网络同步</strong></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基础同步：服务器修改后自动同步到客户端</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>(Replicated)</span><br><span class="line"><span class="type">float</span> CurrentHealth = <span class="number">100.0f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同步+回调：变量同步后触发指定函数（更新UI/逻辑）</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>(ReplicatedUsing=OnRep_HealthChanged)</span><br><span class="line"><span class="type">float</span> SyncHealth = <span class="number">100.0f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同步回调函数（必须加UFUNCTION()）</span></span><br><span class="line"><span class="built_in">UFUNCTION</span>()</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OnRep_HealthChanged</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 必须重写该函数完成同步注册</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UAttributeSet::GetLifetimeReplicatedProps</span><span class="params">(TArray&lt;FLifetimeProperty&gt;&amp; OutLifetimeProps)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Super::<span class="built_in">GetLifetimeReplicatedProps</span>(OutLifetimeProps);</span><br><span class="line">    <span class="comment">// 注册同步变量（COND_None=无条件同步，REPNOTIFY_Always=始终触发回调）</span></span><br><span class="line">    <span class="built_in">DOREPLIFETIME_CONDITION_NOTIFY</span>(UAttributeSet, Health, COND_None, REPNOTIFY_Always);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GAS属性同步回调</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UAttributeSet::OnRep_Health</span><span class="params">(<span class="type">const</span> FGameplayAttributeData&amp; OldHealth)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">GAMEPLAYATTRIBUTE_REPNOTIFY</span>(UAttributeSet, Health, OldHealth);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>关键注意点:</strong><br>空<code>UPROPERTY()</code>并非无意义：所有<code>UObject</code>子类指针（如<code>UComponent*</code>&#x2F;<code>AActor*</code>）必须添加，否则 UE 的 GC（垃圾回收）无法追踪指针，可能导致内存泄漏（无引用时不回收）或野指针（被误回收）。</p>
<h2 id="UFUNCTION"><a href="#UFUNCTION" class="headerlink" title="UFUNCTION"></a>UFUNCTION</h2><ol>
<li><strong>蓝图执行</strong></li>
</ol>
<ul>
<li><code>BlueprintCallable</code>：蓝图可调用，有执行引脚，可修改对象状态；</li>
<li><code>BlueprintPure</code>：蓝图可调用，无执行引脚，仅用于状态获取 &#x2F; 纯计算（不修改变量）。</li>
</ul>
<ol start="2">
<li><strong>蓝图实现 &#x2F; 扩展</strong></li>
</ol>
<ul>
<li><code>BlueprintImplementableEvent</code>：C++ 声明函数，蓝图中实现逻辑（无 C++ 实现体）；</li>
<li><code>BlueprintNativeEvent</code>：C++ 提供基础实现（函数名加<code>_Implementation</code>后缀），蓝图可重写扩展；调用时用<code>Execute_XXX()</code>。</li>
</ul>
<ol start="3">
<li><strong>网络同步</strong></li>
</ol>
<ul>
<li><code>NetMulticast</code>：服务器调用，所有客户端（含服务器）执行；需搭配<code>Reliable</code>（可靠传输）&#x2F;<code>Unreliable</code>（高频低优先级）；</li>
<li><code>Server</code>（客户端调、服务器执行）、<code>Client</code>（服务器调、客户端执行），需搭配<code>WithValidation</code>（参数验证）。</li>
</ul>
<ol start="4">
<li><strong>元数据扩展</strong></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// DefaultToSelf：参数默认值为自身；DisplayName：自定义蓝图节点名称</span></span><br><span class="line"><span class="built_in">UFUNCTION</span>(BlueprintCallable, meta=(DefaultToSelf=<span class="string">&quot;WorldContextObject&quot;</span>, DisplayName=<span class="string">&quot;自定义函数名&quot;</span>))</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CustomFunction</span><span class="params">(UObject* WorldContextObject)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="USTRUCT"><a href="#USTRUCT" class="headerlink" title="USTRUCT"></a>USTRUCT</h2><ul>
<li>BlueprintType ，标记自定义结构体，允许蓝图中声明该结构体变量、作为函数参数 &#x2F; 返回值；</li>
</ul>
]]></content>
      <categories>
        <category>ProgrammingSkills</category>
      </categories>
      <tags>
        <tag>Reflection</tag>
      </tags>
  </entry>
  <entry>
    <title>游戏开发中的锁：以FScopedAbilityListLock为例</title>
    <url>/ue5-blog/2025/12/09/ProgrammingSkills/Lock/</url>
    <content><![CDATA[<h1 id="核心总结"><a href="#核心总结" class="headerlink" title="核心总结"></a>核心总结</h1><p>锁的作用是保护<strong>临界资源</strong>避免并发读写冲突，<code>FScopedAbilityListLock</code>是针对GAS中ActivatableAbilities的轻量级封装锁，只要遍历<code>GetActivatableAbilities()</code>,就需要申请锁进行保护。</p>
<span id="more"></span>

<h1 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UAbilitySystemComponent::ClearAbilityOfSlot</span><span class="params">(<span class="type">const</span> FGameplayTag&amp; Slot)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">FScopedAbilityListLock <span class="title">ActiveScopLock</span><span class="params">(*<span class="keyword">this</span>)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (FGameplayAbilitySpec&amp; Spec : <span class="built_in">GetActivatableAbilities</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">AbilityHasSlot</span>(&amp;Spec , Slot))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">ClearSlot</span>(&amp;Spec);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h1><p><code>GetActivatableAbilities()</code> 返回的技能列表在游戏运行中会被高频修改（如技能锁定、添加、冷却禁用等），若读取列表时被其他代码路径修改，会导致迭代器失效、程序崩溃，因此需通过锁保护该临界资源。</p>
<p>这一设计与操作系统中的互斥锁思想一致，但存在两点关键差异：</p>
<ol>
<li>此处使用的是“作用域锁”，会随作用域结束（如函数执行完毕）自动析构解锁，无需手动调用<code>Unlock()</code>；</li>
<li>列表遍历操作耗时极短，无“线程等待资源”场景，因此锁的底层采用自旋锁实现——让线程短暂自旋等待锁释放，而非执行休眠&#x2F;唤醒操作，兼顾效率与安全性。</li>
</ol>
]]></content>
      <categories>
        <category>ProgrammingSkills</category>
      </categories>
      <tags>
        <tag>Lock</tag>
      </tags>
  </entry>
  <entry>
    <title>委托 (Delegate)</title>
    <url>/ue5-blog/2025/12/09/ProgrammingSkills/Delegate/</url>
    <content><![CDATA[<h1 id="核心总结"><a href="#核心总结" class="headerlink" title="核心总结"></a>核心总结</h1><p>委托的核心价值可概括为两点：</p>
<ol>
<li><p><strong>解耦：</strong><br>发送方仅负责在合适时机广播事件，无需知晓接收方逻辑；接收方专注实现回调，无需关联发送方细节，双方独立扩展逻辑。</p>
</li>
<li><p><strong>异步：</strong><br>接收方无需预判事件触发时间，只需提前绑定回调函数，事件广播时自动执行，降低时机同步成本。</p>
</li>
</ol>
<span id="more"></span>

<h1 id="什么是委托-Delegate"><a href="#什么是委托-Delegate" class="headerlink" title="什么是委托(Delegate)"></a>什么是委托(Delegate)</h1><p>游戏系统中存在大量跨对象的交互事件——事件发起者执行某个行为后，其他对象需要对该行为做出响应。</p>
<p>以“子弹击中敌人”为例：子弹触发Overlap事件是行为发起端，若直接在子弹代码中修改敌人血量、硬直等属性，会导致代码扩展性极差（比如不同敌人有不同的减伤、免硬直等差异化逻辑）。核心问题在于：子弹无需知晓被击中对象的具体类型和响应逻辑，所有“受击后的处理”都应归属于被击中对象自身。</p>
<p>委托（Delegate）正是解决这类问题的核心机制，其本质是一套“事件通信管道”：</p>
<ul>
<li>事件发起者只需负责向“管道”发送消息，无需关心谁会接收、如何处理；</li>
<li>事件接收者提前将处理逻辑（回调函数）绑定到“管道”，当收到消息时自动执行逻辑。</li>
</ul>
<p>需明确委托机制的三个核心要素：</p>
<ol>
<li>委托事件（即“通信管道”）：需要定义在某个通用类中；</li>
<li>消息发送：事件发起方在合适的时机触发委托、广播消息；</li>
<li>回调绑定：事件接收方需在事件发生前，将处理函数绑定到委托上。</li>
</ol>
<p>这里的核心易错点是<strong>绑定时机</strong>：回调函数的绑定必须早于委托广播，否则接收方无法响应。即便在“自身向自身发消息”的场景中，代码层面仍需先定义回调逻辑、完成绑定，再执行委托广播——回调函数的代码书写顺序在前，实际执行却在收到消息后，这也是委托使用中易混淆的点。</p>
<h1 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// DelegateSender.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 动态多播委托（支持蓝图绑定）：需声明参数类型+参数名</span></span><br><span class="line"><span class="built_in">DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam</span>(FOnSingleParamEvent, int32, DamageValue); </span><br><span class="line"><span class="comment">// 2. 普通多播委托（仅C++可用）：只需参数类型，参数名用注释说明（提升可读性）</span></span><br><span class="line"><span class="built_in">DECLARE_MULTICAST_DELEGATE_TwoParams</span>(FOnTwoParamEvent, FVector, <span class="comment">/* HitLocation */</span>, AActor*, <span class="comment">/* HitActor */</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// MULTICAST表示有多个接受方，多个接收方都会自动执行回调</span></span><br><span class="line"><span class="comment">// 如果是单播委托，使用Execute进行触发</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 委托发送方类（示例：子弹类）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GAME_API</span> UDelegateSender : <span class="keyword">public</span> UObject</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 声明委托实例（供外部绑定回调）</span></span><br><span class="line">    FOnSingleParamEvent OnDamageEvent;       <span class="comment">// 单参数委托实例（如传递伤害值）</span></span><br><span class="line">    FOnTwoParamEvent OnHitEvent;             <span class="comment">// 双参数委托实例（如传递击中位置+击中对象）</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// DelegateSender.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 委托发送方：在事件触发时机广播委托（示例：子弹检测到击中时）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UDelegateSender::TriggerHitEvent</span><span class="params">(int32 Damage, FVector HitLoc, AActor* HitActor)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 广播委托：所有绑定的回调函数会自动执行</span></span><br><span class="line">    OnDamageEvent.<span class="built_in">Broadcast</span>(Damage);</span><br><span class="line">    OnHitEvent.<span class="built_in">Broadcast</span>(HitLoc, HitActor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// DelegateReceiver.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;DelegateReceiver.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;DelegateSender.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 委托接收方：绑定回调函数到发送方的委托（需在事件触发前完成绑定）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UDelegateReceiver::BindToDelegate</span><span class="params">(UDelegateSender* Sender)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!Sender) <span class="keyword">return</span>; <span class="comment">// 空指针校验</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方式1：绑定成员函数（最常用）</span></span><br><span class="line">    <span class="comment">// AddUObject：接收方为UObject子类时使用，自动处理生命周期（对象销毁时解绑）</span></span><br><span class="line">    Sender-&gt;OnDamageEvent.<span class="built_in">AddUObject</span>(<span class="keyword">this</span>, &amp;UDelegateReceiver::OnReceiveDamage);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方式2：绑定Lambda表达式（适合简单逻辑，无需单独写成员函数）</span></span><br><span class="line">    Sender-&gt;OnHitEvent.<span class="built_in">AddLambda</span>(</span><br><span class="line">        [<span class="keyword">this</span>](FVector HitLocation, AActor* HitActor) <span class="comment">// 捕获this以访问接收方成员</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 击中事件的回调逻辑</span></span><br><span class="line">            <span class="built_in">UE_LOG</span>(LogTemp, Log, <span class="built_in">TEXT</span>(<span class="string">&quot;击中位置：%s&quot;</span>), *HitLocation.<span class="built_in">ToString</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 委托回调函数（对应OnDamageEvent）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UDelegateReceiver::OnReceiveDamage</span><span class="params">(int32 DamageValue)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 接收方的处理逻辑</span></span><br><span class="line">    <span class="built_in">UE_LOG</span>(LogTemp, Log, <span class="built_in">TEXT</span>(<span class="string">&quot;收到伤害值：%d&quot;</span>), DamageValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="疑难解释"><a href="#疑难解释" class="headerlink" title="疑难解释"></a>疑难解释</h1><h2 id="1-委托的定义位置：并非必须绑定发送方"><a href="#1-委托的定义位置：并非必须绑定发送方" class="headerlink" title="1. 委托的定义位置：并非必须绑定发送方"></a>1. 委托的定义位置：并非必须绑定发送方</h2><p>委托的声明位置可灵活调整——既可以定义在事件发送方，也可以定义在接收方，但核心前提是：<strong>委托的广播方（实际触发者）必须能获取到委托所属类的实例</strong>。</p>
<p>这一点容易引发“解耦不彻底”的疑问：绑定回调时，接收方需要包含委托定义类的头文件，看似仍存在耦合。以子弹击中敌人的场景为例：若委托定义在子弹类（发送方），敌人需持有子弹指针才能绑定回调，这意味着“敌人必须知道触发伤害的具体类型”；即便委托定义在敌人类（接收方），子弹需知道敌人的类型才能广播委托——两种方式都违背“敌人无需知晓攻击来源、子弹无需知晓被击目标”的解耦原则（尤其当子弹&#x2F;敌人类型扩展后，代码修改成本会急剧增加）。</p>
<h2 id="2-解耦方案：委托归属于“通用基类”"><a href="#2-解耦方案：委托归属于“通用基类”" class="headerlink" title="2. 解耦方案：委托归属于“通用基类”"></a>2. 解耦方案：委托归属于“通用基类”</h2><p>为进一步解耦，实战中会将委托定义在<strong>通用基类</strong>中：</p>
<ul>
<li>发送方（如子弹）仅需依赖该通用基类，无需知晓具体接收方类型，只需在事件触发时调用基类的委托广播接口；</li>
<li>接收方（如不同类型的敌人、道具）继承该通用基类，重写&#x2F;绑定自定义回调函数，实现差异化的事件处理；</li>
<li>核心优势：发送方和接收方仅依赖“通用基类”，彼此完全隔离，新增子弹&#x2F;敌人类型时无需修改原有逻辑。</li>
</ul>
<p>需要注意的是，委托代表的通信管道是和<strong>实例</strong>同级的，一个实例代表一个单独的通信管道。</p>
<h2 id="3-场景适配：委托-vs-GAS的GE（GameplayEffect）"><a href="#3-场景适配：委托-vs-GAS的GE（GameplayEffect）" class="headerlink" title="3. 场景适配：委托 vs GAS的GE（GameplayEffect）"></a>3. 场景适配：委托 vs GAS的GE（GameplayEffect）</h2><p>子弹击中造成伤害、附加Debuff、击飞（Knockback）等战斗事件，看似可用委托实现，但这类事件的上下文（伤害数值、Debuff类型、击飞力度等）复杂且需支持扩展，纯委托方案会因参数膨胀、逻辑分散变得难以维护。</p>
<p>在GAS框架中，这类战斗事件更适合用 <strong>GE</strong> 处理：GE天然封装了属性修改、效果叠加、持续时间等战斗逻辑，且通过GameplayTag实现灵活的触发&#x2F;取消规则，比委托更贴合“技能-属性-状态”的联动需求。</p>
<p>而简单的多播委托更适配<strong>UI交互场景</strong>：比如角色属性（血量、蓝量）变化时更新UI、技能冷却完成时刷新按钮状态——此时可将委托定义在ASC中，所有UI组件绑定该委托，当属性&#x2F;状态变更时广播委托，UI组件自动更新显示，无需业务逻辑层关心具体UI实现。这也是GAS框架中ASC、AS的核心作用之一：作为“通用事件枢纽”，统一管理属性变更、技能状态等事件的广播与回调，兼顾解耦与扩展性。</p>
<h1 id="蓝图中的广播-Event-Dispatcher"><a href="#蓝图中的广播-Event-Dispatcher" class="headerlink" title="蓝图中的广播 Event Dispatcher"></a>蓝图中的广播 Event Dispatcher</h1><p>蓝图中使用广播很简单，仍然是三步：注册、广播、回调；<br><img src="/ue5-blog/2025/12/09/ProgrammingSkills/Delegate/image.png" alt="alt text"><br><img src="/ue5-blog/2025/12/09/ProgrammingSkills/Delegate/image1.png" alt="alt text"></p>
]]></content>
      <categories>
        <category>ProgrammingSkills</category>
      </categories>
      <tags>
        <tag>Delegate</tag>
      </tags>
  </entry>
  <entry>
    <title>智能指针 (Pointer)</title>
    <url>/ue5-blog//2025/12/10/ProgrammingSkills-Pointer/</url>
    <content><![CDATA[<h1 id="核心总结"><a href="#核心总结" class="headerlink" title="核心总结"></a>核心总结</h1><p>UE中的智能指针是管理对象生命周期、避免裸指针风险的核心工具，分为适配引擎GC的UObject专属指针（TObjectPtr&#x2F;TWeakObjectPtr等）和管理非UObject的通用共享指针（TSharedPtr）；</p>
<p>在实际使用中，最常见的是TObjectPtr，但有时调用引擎内置的函数时可能需使用 &#x2F; 返回特定指针类型，需了解相关转换规则和其中异同。</p>
<span id="more"></span>

<h1 id="为什么使用智能指针"><a href="#为什么使用智能指针" class="headerlink" title="为什么使用智能指针"></a>为什么使用智能指针</h1><p>原生C++裸指针存在三大核心问题：</p>
<ol>
<li><strong>野指针风险</strong>：对象被销毁后，裸指针未置空，访问时导致程序崩溃；</li>
<li><strong>内存泄漏</strong>：UObject指针未被GC追踪，无引用时无法自动回收；</li>
<li><strong>GC兼容问题</strong>：裸指针无法被UE垃圾回收系统识别，易出现“对象误回收”或“内存泄漏”。</li>
</ol>
<p>智能指针的核心价值：</p>
<ul>
<li>自动管理指针生命周期，适配UE GC机制；</li>
<li>避免手动管理内存（new&#x2F;delete），减少人为失误；</li>
<li>区分“强引用&#x2F;弱引用”，灵活控制对象回收逻辑。</li>
</ul>
<h1 id="使用指南"><a href="#使用指南" class="headerlink" title="使用指南"></a>使用指南</h1><h2 id="TObjectPtr"><a href="#TObjectPtr" class="headerlink" title="TObjectPtr"></a>TObjectPtr</h2><p>适用于所有UObject子类实例指针（Actor&#x2F;Component&#x2F;Widget等），替代原生裸指针（UComponent* → TObjectPtr<UComponent>）。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明</span></span><br><span class="line">TObjectPtr&lt;UStaticMeshComponent&gt; MeshComp;</span><br><span class="line"><span class="comment">// 赋值</span></span><br><span class="line">MeshComp = <span class="built_in">CreateDefaultSubobject</span>&lt;UStaticMeshComponent&gt;(<span class="built_in">TEXT</span>(<span class="string">&quot;Mesh&quot;</span>));</span><br><span class="line"><span class="comment">// 访问：直接使用，无需额外解引用</span></span><br><span class="line"><span class="keyword">if</span> (MeshComp) &#123; MeshComp-&gt;<span class="built_in">SetVisibility</span>(<span class="literal">true</span>); &#125;</span><br></pre></td></tr></table></figure>

<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>无需手动释放，GC自动管理；支持与裸指针互转，完全兼容原有UObject逻辑。</p>
<h2 id="TWeakObjectPtr"><a href="#TWeakObjectPtr" class="headerlink" title="TWeakObjectPtr"></a>TWeakObjectPtr</h2><p>UObject弱引用指针，不阻止GC回收对象，仅“观察”对象是否存活。<br>适用于需引用对象但不希望阻止其回收（如UI引用场景Actor、技能引用目标Enemy）。<br>核心优点是<strong>多线程</strong>访问时安全，而TObjectPtr仅在主线程中使用，并未设计线程安全。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 主线程持有</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>()</span><br><span class="line">TObjectPtr&lt;AActor&gt; MyActor;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 多线程使用安全缓存弱引用</span></span><br><span class="line">TWeakObjectPtr&lt;AActor&gt; WeakActor = MyActor;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SomeThreadFunction</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (WeakActor.<span class="built_in">IsValid</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        AActor* ValidActor = WeakActor.<span class="built_in">Get</span>();</span><br><span class="line">        <span class="comment">// 线程安全读操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="TSharedPtr"><a href="#TSharedPtr" class="headerlink" title="TSharedPtr"></a>TSharedPtr</h2><p>通用共享指针，基于引用计数管理<strong>非UObject类型</strong>（原生C++类、结构体），自动释放内存。用于管理非UObject类型（如自定义数据结构、第三方库对象）。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">TSharedPtr&lt;FMyData&gt; Ptr = <span class="built_in">MakeShared</span>&lt;FMyData&gt;();</span><br><span class="line"></span><br><span class="line">TSharedPtr&lt;FMyData&gt; Ptr2 = Ptr; <span class="comment">// 引用计数+1</span></span><br><span class="line">Ptr.<span class="built_in">Reset</span>();                    <span class="comment">// 引用计数-1</span></span><br></pre></td></tr></table></figure>

<h2 id="TSubclassOf"><a href="#TSubclassOf" class="headerlink" title="TSubclassOf"></a>TSubclassOf</h2><p>类引用指针（而非实例指针），限制仅能指向指定类及其子类，编译期校验类型。<br>适用于动态生成Actor&#x2F;创建对象时指定类（如Spawn Actor、创建Component）。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明：仅允许指向AEnemy及其子类</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere)</span><br><span class="line">TSubclassOf&lt;AEnemy&gt; EnemyClass;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用：生成指定类的实例</span></span><br><span class="line">AEnemy* NewEnemy = <span class="built_in">GetWorld</span>()-&gt;<span class="built_in">SpawnActor</span>&lt;AEnemy&gt;(EnemyClass, SpawnLoc, FRotator::ZeroRotator);</span><br></pre></td></tr></table></figure>

<h2 id="Handle"><a href="#Handle" class="headerlink" title="Handle"></a>Handle</h2><p>很多时候，我们使用的数据类型都会有后缀Handle，使用Handle的作用如下：</p>
<ul>
<li>资源或数据的间接引用<br>Handle 通常不直接存储数据或资源本身，而是存储了对数据的引用标识符或指针，用来访问或操作真正的数据。这种间接引用方便管理。</li>
<li>异步和并发安全<br>Handle机制适合异步任务（例如异步加载、异步寻路等），请求方持有Handle可随时查询结果或取消请求，且Handle可防止直接访问未准备好的数据。</li>
<li>节省内存和降低开销<br>由于Handle只是轻量索引或ID，复制和传递成本低，适合频繁传递和存</li>
</ul>
<p>以上内容作为理解，实际使用的时候还是主要根据IDE的类型提示，灵活处理即可。</p>
<h3 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h3><p>存储的是类的UClass对象，非实例；蓝图中可通过下拉框选择子类，类型安全。</p>
<h2 id="指针转换-Get"><a href="#指针转换-Get" class="headerlink" title="指针转换 (.Get())"></a>指针转换 (.Get())</h2><ul>
<li><strong>作用</strong>：从智能指针中提取原生裸指针，适用于所有UE智能指针；</li>
<li><strong>注意</strong>：仅临时使用，不改变智能指针的生命周期，避免长期持有返回的裸指针。</li>
</ul>
]]></content>
      <categories>
        <category>ProgrammingSkills</category>
      </categories>
      <tags>
        <tag>Pointer</tag>
        <tag>Handle</tag>
      </tags>
  </entry>
  <entry>
    <title>序列化 (Serialize)</title>
    <url>/ue5-blog/2025/12/10/ProgrammingSkills/Serialize/</url>
    <content><![CDATA[<h1 id="核心总结"><a href="#核心总结" class="headerlink" title="核心总结"></a>核心总结</h1><p>序列化本质是将内存中的数据（变量、对象、结构体）转换为二进制&#x2F;字节流格式，便于持久化存储（存档）、网络传输（同步）；反序列化则是将字节流还原为内存中的原始数据。<br>在实际使用中，最常见的是存档读档、网络同步两大场景。对于如何进行相应的序列化操作，应当充分了解。</p>
<span id="more"></span>

<h1 id="为什么需要序列化"><a href="#为什么需要序列化" class="headerlink" title="为什么需要序列化"></a>为什么需要序列化</h1><p>原生内存中的数据（如角色血量、道具列表）仅在程序运行时存在，且无法直接跨进程&#x2F;网络传输，序列化解决了三大核心问题：</p>
<ol>
<li><strong>持久化存储</strong>：将游戏数据（玩家等级、进度、位置）转为字节流写入文件，实现存档&#x2F;读档，保证数据不随程序关闭丢失；</li>
<li><strong>网络同步</strong>：将服务器端的对象状态（敌人位置、角色血量）转为字节流传输到客户端，反序列化后还原，保证多端数据一致；</li>
<li><strong>跨平台兼容</strong>：二进制格式不依赖运行环境，可在PC&#x2F;主机&#x2F;移动端等不同平台间传输、读取数据。</li>
</ol>
<h1 id="存档与读档"><a href="#存档与读档" class="headerlink" title="存档与读档"></a>存档与读档</h1><p>UE中通过<code>UGameplayStatics::SaveGameToSlot</code>和<code>UGameplayStatics::LoadGameFromSlot</code>可快速完成存档&#x2F;读档，核心是自动将<code>USaveGame</code>子类对象序列化&#x2F;反序列化为二进制文件；开发中只需操作变量（无需直接处理二进制），但基础类型与复杂对象（如AActor）的处理逻辑不同：</p>
<h2 id="1-基础类型的自动序列化"><a href="#1-基础类型的自动序列化" class="headerlink" title="1. 基础类型的自动序列化"></a>1. 基础类型的自动序列化</h2><p>对于<code>int</code>&#x2F;<code>float</code>&#x2F;<code>FString</code>等基础类型，只需将变量放入继承<code>USaveGame</code>的存档类，并标记<code>UPROPERTY(SaveGame)</code>，调用以下接口即可自动完成序列化（存）&#x2F;反序列化（读）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 存档：将SaveGame对象序列化为二进制文件</span></span><br><span class="line">UGameplayStatics::<span class="built_in">SaveGameToSlot</span>(SaveGame , GI-&gt;LoadSlotName , GI-&gt;LoadSlotIndex);</span><br><span class="line"><span class="comment">// 读档：将二进制文件反序列化为SaveGame对象</span></span><br><span class="line">SaveGame = UGameplayStatics::<span class="built_in">LoadGameFromSlot</span>(GI-&gt;LoadSlotName , GI-&gt;LoadSlotIndex);</span><br></pre></td></tr></table></figure>

<h2 id="2-复杂对象（AActor）的手动序列化"><a href="#2-复杂对象（AActor）的手动序列化" class="headerlink" title="2. 复杂对象（AActor）的手动序列化"></a>2. 复杂对象（AActor）的手动序列化</h2><p>AActor作为复杂UObject，无法像基础类型一样直接序列化，需通过以下步骤将需保存的变量转为二进制存储到<code>SaveGame</code>的字节数组中：</p>
<h3 id="核心原理"><a href="#核心原理" class="headerlink" title="核心原理"></a>核心原理</h3><ul>
<li>步骤1：在目标AActor中，用<code>UPROPERTY(SaveGame)</code>标记需保存的变量（告知引擎序列化范围）；</li>
<li>步骤2：在<code>SaveGame</code>类中定义<code>TArray&lt;uint8&gt; Bytes</code>，作为存储Actor二进制数据的容器；</li>
<li>步骤3：存档时调用<code>Actor-&gt;Serialize()</code>，将标记的变量转为二进制写入<code>Bytes</code>；读档时反向读取<code>Bytes</code>还原变量；</li>
<li>步骤4：通过<code>SaveGameToSlot</code>&#x2F;<code>LoadGameFromSlot</code>存储&#x2F;读取包含<code>Bytes</code>的<code>SaveGame</code>对象，完成Actor数据的存档&#x2F;读档。</li>
</ul>
<h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 目标Actor（Checkpoint.h）</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>(BlueprintReadWrite , SaveGame)</span><br><span class="line"><span class="type">bool</span> bReached = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 存档类（SaveGame.h）</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>()</span><br><span class="line">TArray&lt;uint8&gt; Bytes;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 存档/读档逻辑（GameMode.cpp）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AGameModeBase::SaveWorldState</span><span class="params">(AActor* Actor)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">FMemoryWriter <span class="title">MemoryWriter</span><span class="params">(SaveGame.Bytes)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建存档专用归档器，标记为存档模式</span></span><br><span class="line">    <span class="function">FObjectAndNameAsStringProxyArchive <span class="title">Archive</span><span class="params">(MemoryWriter , <span class="literal">true</span>)</span></span>;</span><br><span class="line">    Archive.ArIsSaveGame = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 序列化Actor：将SaveGame标记的变量写入Bytes</span></span><br><span class="line">    Actor-&gt;<span class="built_in">Serialize</span>(Archive);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存SaveGame对象到文件</span></span><br><span class="line">    UGameplayStatics::<span class="built_in">SaveGameToSlot</span>(SaveGame , GI-&gt;LoadSlotName , GI-&gt;LoadSlotIndex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AGameModeBase::LoadWorldState</span><span class="params">(AActor* Actor)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SaveGame = UGameplayStatics::<span class="built_in">LoadGameFromSlot</span>(GI-&gt;LoadSlotName , GI-&gt;LoadSlotIndex);</span><br><span class="line"></span><br><span class="line">    <span class="function">FMemoryReader <span class="title">MemoryReader</span><span class="params">(SaveGame.Bytes)</span></span>;</span><br><span class="line">    <span class="function">FObjectAndNameAsStringProxyArchive <span class="title">Archive</span><span class="params">(MemoryReader , <span class="literal">true</span>)</span></span>;</span><br><span class="line">    Archive.ArIsSaveGame = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反序列化Actor：从Bytes还原SaveGame标记的变量</span></span><br><span class="line">    Actor-&gt;<span class="built_in">Serialize</span>(Archive);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行Actor的自定义加载逻辑（如接口函数）</span></span><br><span class="line">    ISaveInterface::<span class="built_in">Execute_LoadActor</span>(Actor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="网络序列化"><a href="#网络序列化" class="headerlink" title="网络序列化"></a>网络序列化</h1><p>UE网络同步的核心是将服务器数据序列化为二进制流传输到客户端，再反序列化还原；基础类型可由引擎自动完成序列化，自定义类型（如<code>FCustomGameplayEffectContext</code>）需手动重写<code>NetSerialize</code>函数，精准控制同步逻辑与传输开销。</p>
<h2 id="1-基础类型的自动网络序列化"><a href="#1-基础类型的自动网络序列化" class="headerlink" title="1. 基础类型的自动网络序列化"></a>1. 基础类型的自动网络序列化</h2><p>对于<code>int</code>&#x2F;<code>float</code>&#x2F;<code>FString</code>&#x2F;<code>FVector</code>等UE内置基础类型，仅需两步即可实现自动网络序列化：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 步骤1：标记需同步的变量</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>(Replicated)</span><br><span class="line"><span class="type">float</span> CurrentHealth = <span class="number">100.0f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 步骤2：重写注册函数，将变量加入同步列表</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">APlayerCharacter::GetLifetimeReplicatedProps</span><span class="params">(TArray&lt;FLifetimeProperty&gt;&amp; OutLifetimeProps)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Super::<span class="built_in">GetLifetimeReplicatedProps</span>(OutLifetimeProps);</span><br><span class="line">    <span class="built_in">DOREPLIFETIME</span>(APlayerCharacter, CurrentHealth);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 引擎自动行为：</span></span><br><span class="line"><span class="comment">// - 服务器修改CurrentHealth后，自动将其序列化为二进制流；</span></span><br><span class="line"><span class="comment">// - 二进制流传输到客户端后，引擎自动反序列化还原CurrentHealth值；</span></span><br><span class="line"><span class="comment">// - 无需手动处理二进制转换、数据传输逻辑。</span></span><br></pre></td></tr></table></figure>

<h2 id="2-自定义类型的手动网络序列化"><a href="#2-自定义类型的手动网络序列化" class="headerlink" title="2. 自定义类型的手动网络序列化"></a>2. 自定义类型的手动网络序列化</h2><p>自定义结构体&#x2F;类（如<code>FCustomGameplayEffectContext</code>）无法被引擎自动序列化，需重写<code>NetSerialize</code>函数，手动定义“哪些数据同步、如何同步”，核心是通过<code>RepBits</code>（位掩码）标记有效数据，减少网络传输开销。</p>
<h3 id="核心原理-1"><a href="#核心原理-1" class="headerlink" title="核心原理"></a>核心原理</h3><ul>
<li><p><code>NetSerialize</code>是网络序列化的核心接口，返回<code>bool</code>表示序列化&#x2F;反序列化是否成功；</p>
</li>
<li><p><code>RepBits</code>：用二进制位标记需同步的有效数据（仅传输有值数据，避免冗余）；</p>
</li>
<li><p><code>FArchive&amp; Ar</code>：存储二进制数据（<code>Ar.IsSaving()</code>&#x3D;服务器序列化，<code>Ar.IsLoading()</code>&#x3D;客户端反序列化）；</p>
</li>
<li><p><code>UPackageMap* Map</code>：处理UObject指针的网络映射（避免直接传输内存地址）；</p>
</li>
<li><p>核心流程：</p>
<ol>
<li>服务器：遍历变量→用<code>RepBits</code>标记有效数据→将数据写入<code>Ar</code>→传输二进制流；</li>
<li>客户端：读取<code>RepBits</code>→仅反序列化标记的有效数据→还原变量值。</li>
</ol>
</li>
</ul>
<h3 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">FCustomGameplayEffectContext::NetSerialize</span><span class="params">(FArchive&amp; Ar, <span class="keyword">class</span> UPackageMap* Map, <span class="type">bool</span>&amp; bOutSuccess)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 步骤1：定义位掩码RepBits</span></span><br><span class="line">    uint32 RepBits = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Ar.<span class="built_in">IsSaving</span>()) <span class="comment">// 服务器：标记需同步的有效数据</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 每一位对应一个变量，数据有效则置位</span></span><br><span class="line">        <span class="keyword">if</span> (bReplicateInstigator &amp;&amp; Instigator.<span class="built_in">IsValid</span>()) &#123; RepBits |= <span class="number">1</span> &lt;&lt; <span class="number">0</span>; &#125;</span><br><span class="line">        <span class="keyword">if</span> (bReplicateEffectCauser &amp;&amp; EffectCauser.<span class="built_in">IsValid</span>()) &#123; RepBits |= <span class="number">1</span> &lt;&lt; <span class="number">1</span>; &#125;</span><br><span class="line">        <span class="keyword">if</span> (AbilityCDO.<span class="built_in">IsValid</span>()) &#123; RepBits |= <span class="number">1</span> &lt;&lt; <span class="number">2</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 步骤2：序列化RepBits（客户端先读RepBits，才知道要解析哪些数据）</span></span><br><span class="line">    Ar.<span class="built_in">SerializeBits</span>(&amp;RepBits, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 步骤3：根据RepBits序列化/反序列化对应变量</span></span><br><span class="line">    <span class="keyword">if</span> (RepBits &amp; (<span class="number">1</span> &lt;&lt; <span class="number">0</span>)) &#123; Ar &lt;&lt; Instigator; &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 容器类型：调用专用序列化函数</span></span><br><span class="line">    <span class="keyword">if</span> (RepBits &amp; (<span class="number">1</span> &lt;&lt; <span class="number">4</span>)) &#123; <span class="built_in">SafeNetSerializeTArray_Default</span>&lt;<span class="number">31</span>&gt;(Ar, Actors); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复杂子类型：调用自身NetSerialize函数</span></span><br><span class="line">    <span class="keyword">if</span> (RepBits &amp; (<span class="number">1</span> &lt;&lt; <span class="number">5</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (Ar.<span class="built_in">IsLoading</span>() &amp;&amp; !HitResult.<span class="built_in">IsValid</span>()) &#123; HitResult = <span class="built_in">MakeShared</span>&lt;FHitResult&gt;(); &#125;</span><br><span class="line">        HitResult-&gt;<span class="built_in">NetSerialize</span>(Ar, Map, bOutSuccess);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 嵌套逻辑：仅bIsRadialDamage有效时，才同步其下的子变量</span></span><br><span class="line">    <span class="keyword">if</span> (RepBits &amp; (<span class="number">1</span> &lt;&lt; <span class="number">16</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        Ar &lt;&lt; bIsRadialDamage;</span><br><span class="line">        <span class="keyword">if</span> (RepBits &amp; (<span class="number">1</span> &lt;&lt; <span class="number">17</span>)) &#123; Ar &lt;&lt; RadialDamageInnerRadius; &#125;</span><br><span class="line">        <span class="keyword">if</span> (RepBits &amp; (<span class="number">1</span> &lt;&lt; <span class="number">18</span>)) &#123; Ar &lt;&lt; RadialDamageOuterRadius; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 步骤4：客户端加载后初始化关联逻辑</span></span><br><span class="line">    <span class="keyword">if</span> (Ar.<span class="built_in">IsLoading</span>()) &#123; <span class="built_in">AddInstigator</span>(Instigator.<span class="built_in">Get</span>(), EffectCauser.<span class="built_in">Get</span>()); &#125;</span><br><span class="line"></span><br><span class="line">    bOutSuccess = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TStructOpsTypeTraits</span>&lt;FCustomGameplayEffectContext&gt; : <span class="keyword">public</span> TStructOpsTypeTraitsBase2&lt;FCustomGameplayEffectContext&gt;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">enum</span></span><br><span class="line">	&#123;</span><br><span class="line">		WithNetSerializer = <span class="literal">true</span>, <span class="comment">// 标记支持网络序列化</span></span><br><span class="line">		WithCopy = <span class="literal">true</span> <span class="comment">// 标记支持拷贝操作</span></span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ProgrammingSkills</category>
      </categories>
      <tags>
        <tag>Serialize</tag>
      </tags>
  </entry>
  <entry>
    <title>单例 (Singleton)</title>
    <url>/ue5-blog//2025/12/10/ProgrammingSkills/Singleton/</url>
    <content><![CDATA[<h1 id="核心总结"><a href="#核心总结" class="headerlink" title="核心总结"></a>核心总结</h1><p>单例的核心是确保类&#x2F;结构体在程序运行期间仅有<strong>一个全局实例</strong>，并提供统一的静态访问入口。<br>实际应用中，最常见的场景式采用原生C++单例实现GameplayTag的集中管理，避免多实例导致Tag重复注册、数值不一致，保证各个模块共享一套Tag。</p>
<span id="more"></span>

<h1 id="单例的使用场景"><a href="#单例的使用场景" class="headerlink" title="单例的使用场景"></a>单例的使用场景</h1><p>单例适用于“需全局统一访问、仅初始化一次”的场景：</p>
<ol>
<li><strong>全局常量&#x2F;配置管理</strong>：GameplayTag是游戏内通用标记（属性、技能、状态等），需全局唯一注册、跨模块共享，单例可确保所有模块使用同一套Tag，避免重复定义；</li>
<li><strong>全局状态管理</strong>：如游戏全局开关（音效、无敌模式）、跨场景共享的核心参数，单例保证状态唯一且修改可全局感知；</li>
<li><strong>全局服务类</strong>：如日志管理、网络请求封装，单例避免多实例导致的资源冲突（如重复创建网络连接）。</li>
</ol>
<h1 id="单例的构建和引用"><a href="#单例的构建和引用" class="headerlink" title="单例的构建和引用"></a>单例的构建和引用</h1><h2 id="1-单例的核心构建规则"><a href="#1-单例的核心构建规则" class="headerlink" title="1. 单例的核心构建规则"></a>1. 单例的核心构建规则</h2><h3 id="头文件（-h）设计：封闭实例-开放访问"><a href="#头文件（-h）设计：封闭实例-开放访问" class="headerlink" title="头文件（.h）设计：封闭实例+开放访问"></a>头文件（.h）设计：封闭实例+开放访问</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 核心：私有静态实例 + 公有静态Get方法，确保唯一实例 + 全局访问</span></span><br><span class="line"><span class="keyword">struct</span>  <span class="title class_">FCustomGameplayTags</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 全局访问入口：返回const引用，避免外部修改实例</span></span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">const</span> FCustomGameplayTags&amp; <span class="title">Get</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> GameplayTags;&#125;</span><br><span class="line">    <span class="comment">// 初始化方法：单独封装Tag注册逻辑，在游戏启动时执行</span></span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">InitializeNativeGameplayTags</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 需全局共享的GameplayTag变量</span></span><br><span class="line">    FGameplayTag Attributes_Primary_Strength;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 私有静态实例：仅类内可访问，避免外部创建多实例</span></span><br><span class="line">	<span class="type">static</span> FCustomGameplayTags GameplayTags;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="源文件（-cpp）实现：初始化实例-注册逻辑"><a href="#源文件（-cpp）实现：初始化实例-注册逻辑" class="headerlink" title="源文件（.cpp）实现：初始化实例+注册逻辑"></a>源文件（.cpp）实现：初始化实例+注册逻辑</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化静态实例（程序启动时创建，全局唯一）</span></span><br><span class="line">FCustomGameplayTags FCustomGameplayTags::GameplayTags;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 封装GameplayTag的注册逻辑，仅需执行一次</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FCustomGameplayTags::InitializeNativeGameplayTags</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 向UE引擎注册自定义Native GameplayTag，绑定标记名和说明</span></span><br><span class="line">	GameplayTags.Attributes_Primary_Strength = UGameplayTagsManager::<span class="built_in">Get</span>().<span class="built_in">AddNativeGameplayTag</span>(</span><br><span class="line">		<span class="built_in">FName</span>(<span class="string">&quot;Attributes.Primary.Strength&quot;</span>) ,</span><br><span class="line">		<span class="built_in">FString</span>(<span class="string">&quot;Increases physical damage&quot;</span>)</span><br><span class="line">	);</span><br><span class="line">	<span class="comment">// 可扩展：注册更多Tag</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-单例的全局引用方式"><a href="#2-单例的全局引用方式" class="headerlink" title="2. 单例的全局引用方式"></a>2. 单例的全局引用方式</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 任意模块/类中，通过Get()获取唯一实例，访问已注册的Tag</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AEnemy::CalculateDamage</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 全局访问单例中的Tag，无需创建FCustomGameplayTags实例</span></span><br><span class="line">    <span class="type">const</span> FGameplayTag StrengthTag = FCustomGameplayTags::<span class="built_in">Get</span>().Attributes_Primary_Strength;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ProgrammingSkills</category>
      </categories>
      <tags>
        <tag>Singleton</tag>
      </tags>
  </entry>
  <entry>
    <title>AbilityTask</title>
    <url>/ue5-blog/2025/12/08/SystemDesigns/GAS/AbilityTask/</url>
    <content><![CDATA[<h1 id="核心总结"><a href="#核心总结" class="headerlink" title="核心总结"></a>核心总结</h1><span id="more"></span>]]></content>
      <categories>
        <category>SystemDesigns</category>
        <category>GAS</category>
      </categories>
      <tags>
        <tag>AbilityTask</tag>
      </tags>
  </entry>
  <entry>
    <title>AbilitySystemComponent (ASC)</title>
    <url>/ue5-blog/2025/12/12/SystemDesigns/GAS/AbilitySystemComponent/</url>
    <content><![CDATA[<h1 id="核心总结"><a href="#核心总结" class="headerlink" title="核心总结"></a>核心总结</h1><p>AbilitySystemComponent（ASC）是GAS框架的核心中枢，作为挂载在Actor&#x2F;Character上的“逻辑容器”，承接对象所有GAS相关能力与交互。GAS的核心逻辑（属性变更、效果施加、技能执行）均围绕ASC展开，所有交互遵循“ASC发起→ASC接收”的模式，是连接GE、GA、AttributeSet的核心桥梁。</p>
<span id="more"></span>

<h1 id="ASC-是什么"><a href="#ASC-是什么" class="headerlink" title="ASC 是什么"></a>ASC 是什么</h1><p>从GAS的核心逻辑视角，ASC是承载对象GAS能力的“逻辑核心”（Actor&#x2F;Character仅作为宿主，GAS层面无需关注其原生逻辑）——可将GAS需处理的所有对象，抽象为一个个独立的ASC实例。</p>
<p>每个ASC独立管理如下核心内容，构成GAS交互的基础：</p>
<h2 id="1-游戏效果（GameplayEffect，GE）：世界对ASC的作用载体"><a href="#1-游戏效果（GameplayEffect，GE）：世界对ASC的作用载体" class="headerlink" title="1. 游戏效果（GameplayEffect，GE）：世界对ASC的作用载体"></a>1. 游戏效果（GameplayEffect，GE）：世界对ASC的作用载体</h2><p>游戏世界中所有事件对当前ASC产生的影响，均通过挂载在该ASC上的GE实现；处理ASC对外部作用的反馈，核心是围绕GE的挂载、移除与响应展开。</p>
<h2 id="2-游戏技能（GameplayAbility，GA）：ASC对世界的作用载体"><a href="#2-游戏技能（GameplayAbility，GA）：ASC对世界的作用载体" class="headerlink" title="2. 游戏技能（GameplayAbility，GA）：ASC对世界的作用载体"></a>2. 游戏技能（GameplayAbility，GA）：ASC对世界的作用载体</h2><p>ASC对游戏世界产生的所有影响（如播放角色动画、生成带伤害GE的子弹），均依赖其拥有的GA实现。需注意：ASC管理的并非GA实例，而是Gameplay Ability Spec（技能规格）；关于Spec与Instance的区别见<a href="/ue5-blog/2025/12/11/GAS-GA/">此处</a>。</p>
<h2 id="3-补充：属性（Attribute）的管理"><a href="#3-补充：属性（Attribute）的管理" class="headerlink" title="3. 补充：属性（Attribute）的管理"></a>3. 补充：属性（Attribute）的管理</h2><p>属性用于描述对象的核心状态（如血量、蓝量、力量），虽可直接由ASC管理，但为逻辑解耦，通常单独通过AttributeSet封装；特殊属性（如玩家XP、技能点、属性点）可存储在PlayerState中，由ASC关联访问。</p>
<h2 id="ASC的核心交互逻辑"><a href="#ASC的核心交互逻辑" class="headerlink" title="ASC的核心交互逻辑"></a>ASC的核心交互逻辑</h2><p>GAS框架下所有交互均遵循“ASC发起→ASC接收”：</p>
<ol>
<li>发起方ASC通过自身拥有的GA触发对外作用；</li>
<li>GA执行过程中产生的各类影响（如伤害、视觉效果等），最终以GE的形式施加到目标ASC；</li>
<li>目标ASC接收GE后，修改自身Attribute，并触发配套的世界交互（如血量降低同步更新UI、触发死亡特效）。</li>
</ol>
<h1 id="ASC类提供的核心功能"><a href="#ASC类提供的核心功能" class="headerlink" title="ASC类提供的核心功能"></a>ASC类提供的核心功能</h1><h2 id="1-响应GE挂载：处理自身被施加GE后的逻辑"><a href="#1-响应GE挂载：处理自身被施加GE后的逻辑" class="headerlink" title="1. 响应GE挂载：处理自身被施加GE后的逻辑"></a>1. 响应GE挂载：处理自身被施加GE后的逻辑</h2><p>通过绑定ASC内置的<code>OnGameplayEffectAppliedDelegateToSelf</code>委托回调，可监听并处理GE施加到自身的逻辑。需注意：该委托仅在Server端生效（GE的核心生效逻辑均在Server执行），Client端需通过Server广播同步UI等视觉&#x2F;交互变化。</p>
<p>该委托回调会传入两个核心参数：<code>FGameplayEffectSpec</code>（GE的配置规格）、<code>FActiveGameplayEffectHandle</code>（GE实例的句柄），用于精准识别并处理对应的GE。</p>
<h2 id="2-管理GA：核心是管理Gameplay-Ability-Spec"><a href="#2-管理GA：核心是管理Gameplay-Ability-Spec" class="headerlink" title="2. 管理GA：核心是管理Gameplay Ability Spec"></a>2. 管理GA：核心是管理Gameplay Ability Spec</h2><p>ASC不直接与GA实例交互，所有GA相关操作均围绕Spec展开，核心能力包括：</p>
<h3 id="（1）Tag与Spec的关联管理"><a href="#（1）Tag与Spec的关联管理" class="headerlink" title="（1）Tag与Spec的关联管理"></a>（1）Tag与Spec的关联管理</h3><p>提供一系列工具函数，实现GameplayTag（Ability&#x2F;Status&#x2F;Input类标签）与Spec的绑定、查询与校验，例如：</p>
<ul>
<li><code>GetInputTagFromSpec</code>：从Spec中提取绑定的输入Tag；</li>
<li><code>AbilityHasSlot</code>：校验Spec是否绑定了指定技能槽位；</li>
<li><code>AssignSlotToAbility</code>：为Spec分配技能槽位。</li>
</ul>
<p>关键注意点：</p>
<ul>
<li>Spec的动态标签（如Status、Input Tag）：通过<code>Spec.GetDynamicSourceTags()</code>获取&#x2F;管理；</li>
<li>Spec的固定标签（如AbilityTag）：通过<code>Spec.Ability.Get()-&gt;GetAssetTags()</code>获取&#x2F;管理；</li>
<li>遍历已授予（granted）的技能Spec：调用<code>GetActivatableAbilities()</code>，返回值为Spec列表；<strong>遍历激活技能时必须加锁</strong>（如<code>FScopedAbilityListLock</code>），避免多线程冲突。</li>
</ul>
<h3 id="（2）授予新技能（Spec）"><a href="#（2）授予新技能（Spec）" class="headerlink" title="（2）授予新技能（Spec）"></a>（2）授予新技能（Spec）</h3><p>ASC的“技能槽”不仅包含UI可见技能，还涵盖所有已授予的技能；授予逻辑仅针对Spec，而非GA实例，核心步骤：</p>
<ol>
<li>创建新的Gameplay Ability Spec；</li>
<li>为Spec填充配置（如绑定Tag、设置等级、配置冷却）；</li>
<li>调用<code>GiveAbility(Spec)</code>完成授予（按需激活：<code>GiveAbilityAndActivateOnce(Spec)</code>会直接实例化并执行GA）；</li>
<li>向UI广播技能授予事件，同步界面展示，按需进行。</li>
</ol>
<h3 id="（3）处理技能输入响应"><a href="#（3）处理技能输入响应" class="headerlink" title="（3）处理技能输入响应"></a>（3）处理技能输入响应</h3><p>这是GA实例化（激活）的核心逻辑，ASC通过<code>AbilityInputTagPressed/Held/Released</code>等函数响应输入：</p>
<ul>
<li>职责边界：ASC仅负责触发GA的实例化&#x2F;激活，GA的结束逻辑由其自身控制；</li>
<li>输入习惯适配：通常在<code>AbilityInputTagHeld</code>中处理激活逻辑（绑定<code>ETriggerEvent::Triggered</code>，按下期间每帧触发），支持长按连续释放技能（需结合冷却&#x2F;激活状态判断）；</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UCustomAbilitySystemComponent::AbilityInputTagHeld</span><span class="params">(<span class="type">const</span> FGameplayTag&amp; InputTag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!InputTag.<span class="built_in">IsValid</span>()) <span class="keyword">return</span>;</span><br><span class="line">	<span class="function">FScopedAbilityListLock <span class="title">ActiveScopeLock</span><span class="params">(*<span class="keyword">this</span>)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (FGameplayAbilitySpec&amp; AbilitySpec : <span class="built_in">GetActivatableAbilities</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (AbilitySpec.<span class="built_in">GetDynamicSpecSourceTags</span>().<span class="built_in">HasTagExact</span>(InputTag))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">AbilitySpecInputPressed</span>(AbilitySpec);</span><br><span class="line">			<span class="keyword">if</span> (!AbilitySpec.<span class="built_in">IsActive</span>())</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">TryActivateAbility</span>(AbilitySpec.Handle);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>网络同步：输入事件发生在Client端，需同步到Server端以保证效果一致：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (AbilitySpec.<span class="built_in">IsActive</span>())</span><br><span class="line">&#123;</span><br><span class="line">    TArray&lt;UGameplayAbility*&gt; Instances = AbilitySpec.<span class="built_in">GetAbilityInstances</span>();</span><br><span class="line">    <span class="type">const</span> FGameplayAbilityActivationInfo&amp; ActivationInfo = Instances.<span class="built_in">Last</span>()-&gt;<span class="built_in">GetCurrentActivationInfoRef</span>();</span><br><span class="line">    FPredictionKey OriginalPredictionKey = ActivationInfo.<span class="built_in">GetActivationPredictionKey</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">InvokeReplicatedEvent</span>(EAbilityGenericReplicatedEvent::InputPressed , AbilitySpec.Handle , OriginalPredictionKey);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-处理属性变化"><a href="#3-处理属性变化" class="headerlink" title="3. 处理属性变化"></a>3. 处理属性变化</h2><p>属性变化的核心逻辑通常封装在AttributeSet中，ASC仅处理与技能强关联的属性变更场景：</p>
<ul>
<li>典型场景：角色等级提升解锁&#x2F;升级技能（需ASC执行技能授予&#x2F;更新Spec配置）；</li>
<li>实现方式：ASC通过<code>GetAvatarActor()</code>获取宿主对象，关联AttributeSet或PlayerState读取&#x2F;修改属性；</li>
<li>扩展方案：可通过GameplayEvent转发属性变化事件（详情见<a href="/ue5-blog/2025/12/12/GAS-GameplayEvent/">此处</a>查看）。</li>
</ul>
<h1 id="网络复制"><a href="#网络复制" class="headerlink" title="网络复制"></a>网络复制</h1><h2 id="Server与Client的职责"><a href="#Server与Client的职责" class="headerlink" title="Server与Client的职责"></a>Server与Client的职责</h2><p>为适配多人游戏，需明确ASC相关逻辑在Server&#x2F;Client的分工：</p>
<ul>
<li>Server端：执行核心逻辑（属性修改、技能授予、GE施加），保证数据权威；</li>
<li>Client端：仅处理UI同步、视觉反馈等非核心逻辑。</li>
</ul>
<p>设计范式：拆分“Server执行+Client广播”两套函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UCustomAbilitySystemComponent::ServerEquipAbility_Implementation</span><span class="params">(<span class="type">const</span> FGameplayTag&amp; AbilityTag,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                                    <span class="type">const</span> FGameplayTag&amp; Slot)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (FGameplayAbilitySpec* AbilitySpec = <span class="built_in">GetSpecFromAbilityTag</span>(AbilityTag))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// Server端修改Spec的核心逻辑</span></span><br><span class="line"></span><br><span class="line">		<span class="built_in">ClientEquipAbility</span>(AbilityTag , GameplayTags.Abilities_Status_Equipped , Slot , PrevSlot);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UCustomAbilitySystemComponent::ClientEquipAbility_Implementation</span><span class="params">(<span class="type">const</span> FGameplayTag&amp; AbilityTag, <span class="type">const</span> FGameplayTag&amp; Status,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                                    <span class="type">const</span> FGameplayTag&amp; Slot, <span class="type">const</span> FGameplayTag&amp; PreviousSlot)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	AbilityEquipped.<span class="built_in">Broadcast</span>(AbilityTag , Status , Slot , PreviousSlot);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">AbilitySpec.<span class="built_in">GetDynamicSpecSourceTags</span>().<span class="built_in">AddTag</span>(GameplayTags.Abilities_Status_Eligible);</span><br><span class="line"><span class="built_in">MarkAbilitySpecDirty</span>(AbilitySpec);</span><br><span class="line"><span class="comment">// 同步 “Spec 配置数据”，传递 Spec 的完整状态，用于保证配置一致。</span></span><br></pre></td></tr></table></figure>
<p>当手动修改了 AbilitySpec 的成员变量后（如设置目标、调整冷却），调用 MarkAbilitySpecDirty 可以立即生效这些更改，避免延迟或不同步状况。</p>
]]></content>
      <categories>
        <category>SystemDesigns</category>
        <category>GAS</category>
      </categories>
      <tags>
        <tag>GAS</tag>
        <tag>ASC</tag>
      </tags>
  </entry>
  <entry>
    <title>行为树 (BehaviorTree)</title>
    <url>/ue5-blog/2025/12/08/SystemDesigns/AI/BehaviorTree/</url>
    <content><![CDATA[<h1 id="核心总结"><a href="#核心总结" class="headerlink" title="核心总结"></a>核心总结</h1><span id="more"></span>]]></content>
      <categories>
        <category>SystemDesigns</category>
        <category>AI</category>
      </categories>
      <tags>
        <tag>BehavoirTree</tag>
        <tag>Blackboard</tag>
      </tags>
  </entry>
  <entry>
    <title>GameplayAbility (GA)</title>
    <url>/ue5-blog//2025/12/11/GAS-GA/</url>
    <content><![CDATA[<h1 id="核心总结"><a href="#核心总结" class="headerlink" title="核心总结"></a>核心总结</h1><span id="more"></span>

<h1 id="Gameplay-Ability-Spec-与-Gameplay-Ability-Instance"><a href="#Gameplay-Ability-Spec-与-Gameplay-Ability-Instance" class="headerlink" title="Gameplay Ability Spec 与 Gameplay Ability Instance"></a>Gameplay Ability Spec 与 Gameplay Ability Instance</h1><p>在GAS框架中，Gameplay Ability Spec（简称Spec，技能规格）与Gameplay Ability Instance（简称Instance，技能实例）是GA（Gameplay Ability）的两个核心要素，二者分工明确：Spec负责技能的“管理与配置”，Instance负责技能的“实际执行”。</p>
<h2 id="核心概念区分"><a href="#核心概念区分" class="headerlink" title="核心概念区分"></a>核心概念区分</h2><h3 id="1-Gameplay-Ability-Spec：技能的“管理槽位”"><a href="#1-Gameplay-Ability-Spec：技能的“管理槽位”" class="headerlink" title="1. Gameplay Ability Spec：技能的“管理槽位”"></a>1. Gameplay Ability Spec：技能的“管理槽位”</h3><p>Spec是ASC（AbilitySystemComponent）对技能的管理与配置对象，可类比为角色的“技能槽”：</p>
<ul>
<li>核心职责：存储并管控该技能的核心配置（等级、冷却时间、资源消耗、释放条件如所需GameplayTag），以及技能的可用状态（是否可释放、是否处于冷却）；</li>
<li>生命周期：与“技能授予”绑定——ASC授予技能时创建Spec，移除技能时销毁Spec，长期存在于ASC的技能管理列表中。</li>
</ul>
<h3 id="2-Gameplay-Ability-Instance：技能的“执行行为”"><a href="#2-Gameplay-Ability-Instance：技能的“执行行为”" class="headerlink" title="2. Gameplay Ability Instance：技能的“执行行为”"></a>2. Gameplay Ability Instance：技能的“执行行为”</h3><p>Instance是GA的实际运行实例，可类比为“角色放出一个火球的具体行为”：</p>
<ul>
<li>核心职责：执行技能的具体逻辑（如施法动画、生成火球等），仅在技能激活时创建，技能结束（施法完成&#x2F;被打断）后销毁；</li>
<li>生命周期：与“技能激活”绑定——每次激活技能（如点击释放火球术），ASC会基于Spec创建一个Instance，技能执行完毕后Instance随之销毁。</li>
</ul>
<h2 id="关键关系与特性"><a href="#关键关系与特性" class="headerlink" title="关键关系与特性"></a>关键关系与特性</h2><ol>
<li>一对多关联：一个Spec（技能槽）可对应多个Instance（多次释放技能）——比如角色的火球术技能槽（Spec），可反复激活生成多个火球术执行实例（Instance），也可对同一Instance进行激活、禁用等操作；</li>
<li>分工明确的交互逻辑：<ul>
<li>Spec直接与ASC交互：所有对技能的“管理操作”（如修改等级、重置冷却、判断释放权限）均通过ASC作用于Spec；</li>
<li>Instance与游戏世界交互：Instance专注完成技能的世界交互逻辑（如生成特效、检测碰撞、施加伤害），无需感知所属ASC，仅需完成自身的执行任务。</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>SystemDesigns</category>
        <category>GAS</category>
      </categories>
      <tags>
        <tag>GAS</tag>
        <tag>GA</tag>
        <tag>GameplayAbilitySpec</tag>
      </tags>
  </entry>
  <entry>
    <title>GameplayCue (GC)</title>
    <url>/ue5-blog/2025/12/08/SystemDesigns/GAS/GameplayCue/</url>
    <content><![CDATA[<h1 id="核心总结"><a href="#核心总结" class="headerlink" title="核心总结"></a>核心总结</h1><span id="more"></span>]]></content>
      <categories>
        <category>SystemDesigns</category>
        <category>GAS</category>
      </categories>
      <tags>
        <tag>GAS</tag>
        <tag>GC</tag>
      </tags>
  </entry>
  <entry>
    <title>GameplayEffect (GE)</title>
    <url>/ue5-blog//2025/12/12/GAS-GE/</url>
    <content><![CDATA[<h1 id="核心总结"><a href="#核心总结" class="headerlink" title="核心总结"></a>核心总结</h1><p>GameplayEffect（GE）是GAS框架中实现属性修改、传递附加效果信息的核心载体，其核心逻辑围绕“数值计算+信息传递+效果生效”展开：</p>
<ol>
<li><strong>核心功能</strong>：一方面通过硬编码、SetByCaller、Execution Class、MMC等不同复杂度的方式计算属性修改值（如伤害值）；另一方面通过自定义Context或Tag传递暴击、格挡、击退、Debuff等附加效果信息，最终在AttributeSet（AS）中完成这些附加效果的落地。</li>
<li><strong>实战核心流程（伤害类GE）</strong>：先将攻击方参数封装到<code>FDamageEffectParams</code>结构体，再基于该结构体填充自定义Context、构建GameplayEffectSpec（通过SetByCaller传递动态数值），接着通过Execution Class捕获源&#x2F;目标双方属性（如防御、抗性）完成复杂伤害计算（含范围伤害、Debuff概率判定），最后将GE挂载到目标ASC；Debuff作为伤害GE的附加效果，会在AS中检测到Context标记后动态创建专用GE并生效。</li>
<li><strong>关键技术要点</strong>：自定义Context需支持网络复制以跨端传递附加信息；Execution Class用于复杂数值计算（可捕获攻防双方属性），MMC作为其简化版适用于简单属性计算；GE的生效方式（瞬时&#x2F;持续&#x2F;堆叠）、Tag挂载等配置需根据场景定制，确保效果符合设计需求。</li>
</ol>
<span id="more"></span>

<h1 id="GE-的作用"><a href="#GE-的作用" class="headerlink" title="GE 的作用"></a>GE 的作用</h1><p>GE 的核心作用是对属性进行修改，同时传递属性修改附加效果的相关信息。<br>举例来说，造成伤害可视为一个典型的 GE 应用场景：其核心目标是计算出 IncomingDamage（元属性）的数值，同时将附加效果（是否格挡、是否暴击、是否击退、是否触发 Debuff 等）以上下文形式传递出去，最终让这些效果逐一生效。<br>附加效果的落地执行主要在 AS 中完成，详情见<a href="/ue5-blog/2025/12/12/GAS-AS/">此处</a>。站在 GE 的视角，核心是把需要传递的信息填充到 Context 中；若要实现击退、格挡、暴击、范围伤害等定制化效果，则需要自定义 Context 来承载这些信息。<br>除 Context 外，Tag 也是承载信息的重要方式，因此掌握向 GE 中添加 Tag 信息的方法同样关键。</p>
<p>另一个核心要点是数值计算——即确定 GE 最终修改属性的具体数值。以伤害计算为例：</p>
<ul>
<li>简单场景：直接硬编码数值、从 CurveTable 读取数值，或基于已有 Attribute 计算；</li>
<li>灵活场景：通过 Set by Caller Magnitude 动态传递数值；</li>
<li>复杂场景：需动态捕获目标防御值等数据时，要借助 Execution Class 实现。</li>
</ul>
<p>此外，GE 的作用方式也需提前定义，比如是瞬时作用还是持续作用、持续作用的周期、是否允许堆叠等，这些都要在制作 GE 时配置完成。</p>
<p>下文以“带有 Debuff 效果，且需兼顾 CriticalHit、Block、Knockback、RadialDamage 的伤害 GE”为例，逐步拆解伤害产生的完整流程。</p>
<h1 id="实战解析-Damage"><a href="#实战解析-Damage" class="headerlink" title="实战解析 Damage"></a>实战解析 Damage</h1><h2 id="1-封装伤害参数（FDamageEffectParams）"><a href="#1-封装伤害参数（FDamageEffectParams）" class="headerlink" title="1. 封装伤害参数（FDamageEffectParams）"></a>1. 封装伤害参数（FDamageEffectParams）</h2><p>所有能造成伤害的 GA 均继承自 GA_Damage，其核心作用是整合攻击方的参数并打包传递，主要实现两个功能：</p>
<ol>
<li>允许在具体技能 GA（如 GA_FireBolt）的 ClassDefaults 中编辑参数；</li>
<li>将 ClassDefaults 中配置的参数封装到 <code>FDamageEffectParams</code> 结构体中传递。</li>
</ol>
<p>该自定义结构体可包含如下内容：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">USTRUCT</span>(BlueprintType)</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">FDamageEffectParams</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line">	<span class="built_in">FDamageEffectParams</span>()&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(BlueprintReadWrite)</span><br><span class="line">	TObjectPtr&lt;UObject&gt; WorldContextObject = <span class="literal">nullptr</span>;</span><br><span class="line">	<span class="built_in">UPROPERTY</span>(BlueprintReadWrite)</span><br><span class="line">	TSubclassOf&lt;UGameplayEffect&gt; DamageGEClass = <span class="literal">nullptr</span>;</span><br><span class="line">	<span class="built_in">UPROPERTY</span>(BlueprintReadWrite)</span><br><span class="line">	TObjectPtr&lt;UAbilitySystemComponent&gt; SourceASC;</span><br><span class="line">	<span class="built_in">UPROPERTY</span>(BlueprintReadWrite)</span><br><span class="line">	TObjectPtr&lt;UAbilitySystemComponent&gt; TargetASC;</span><br><span class="line">	<span class="built_in">UPROPERTY</span>(BlueprintReadWrite)</span><br><span class="line">	FGameplayTag DamageType = <span class="built_in">FGameplayTag</span>();</span><br><span class="line">	<span class="built_in">UPROPERTY</span>(BlueprintReadWrite)</span><br><span class="line">	<span class="type">float</span> BaseDamage = <span class="number">0.f</span>;</span><br><span class="line">	<span class="built_in">UPROPERTY</span>(BlueprintReadWrite)</span><br><span class="line">	<span class="type">float</span> AbilityLevel = <span class="number">1.f</span>;</span><br><span class="line">	<span class="built_in">UPROPERTY</span>(BlueprintReadWrite)</span><br><span class="line">	<span class="type">float</span> DebuffChance = <span class="number">0.f</span>;</span><br><span class="line">	<span class="built_in">UPROPERTY</span>(BlueprintReadWrite)</span><br><span class="line">	<span class="type">float</span> DebuffDamage = <span class="number">0.f</span>;</span><br><span class="line">	<span class="built_in">UPROPERTY</span>(BlueprintReadWrite)</span><br><span class="line">	<span class="type">float</span> DebuffFrequency = <span class="number">0.f</span>;</span><br><span class="line">	<span class="built_in">UPROPERTY</span>(BlueprintReadWrite)</span><br><span class="line">	<span class="type">float</span> DebuffDuration = <span class="number">0.f</span>;</span><br><span class="line">	<span class="built_in">UPROPERTY</span>(BlueprintReadWrite)</span><br><span class="line">	<span class="type">float</span> DeathImpulseMagnitude = <span class="number">0.f</span>;</span><br><span class="line">	<span class="built_in">UPROPERTY</span>(BlueprintReadWrite)</span><br><span class="line">	FVector DeathImpulse = FVector::ZeroVector;</span><br><span class="line">	<span class="built_in">UPROPERTY</span>(BlueprintReadWrite)</span><br><span class="line">	<span class="type">float</span> KnockbackForceMagnitude = <span class="number">0.f</span>;</span><br><span class="line">	<span class="built_in">UPROPERTY</span>(BlueprintReadWrite)</span><br><span class="line">	<span class="type">float</span> KnockbackChance = <span class="number">0.f</span>;</span><br><span class="line">	<span class="built_in">UPROPERTY</span>(BlueprintReadWrite)</span><br><span class="line">	FVector KnockbackForce = FVector::ZeroVector;</span><br><span class="line">	<span class="built_in">UPROPERTY</span>(BlueprintReadWrite)</span><br><span class="line">	<span class="type">bool</span> bIsRadialDamage = <span class="literal">false</span>;</span><br><span class="line">	<span class="built_in">UPROPERTY</span>(BlueprintReadWrite)</span><br><span class="line">	<span class="type">float</span> RadialDamageInnerRadius = <span class="number">0.f</span>;</span><br><span class="line">	<span class="built_in">UPROPERTY</span>(BlueprintReadWrite)</span><br><span class="line">	<span class="type">float</span> RadialDamageOuterRadius = <span class="number">0.f</span>;</span><br><span class="line">	<span class="built_in">UPROPERTY</span>(BlueprintReadWrite)</span><br><span class="line">	FVector RadialDamageOrigin = FVector::ZeroVector;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">FDamageEffectParams <span class="title">UCustomDamageGameplayAbility::MakeDamageEffectParamsFromClassDefaults</span><span class="params">(AActor* TargetActor ,FVector InRadialDamageOrigin ,</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="type">bool</span> bOverrideKnockbackDirection ,FVector KnockbackDirectionOverride ,</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="type">bool</span> bOverrideDeathImpulse ,FVector DeathImpulseOverride ,</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="type">bool</span> bOverridePitch ,<span class="type">float</span> PitchOverride )</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	FDamageEffectParams Params;</span><br><span class="line"></span><br><span class="line">	Params.WorldContextObject = <span class="built_in">GetAvatarActorFromActorInfo</span>();</span><br><span class="line">	Params.DamageGEClass = DamageEffectClass;</span><br><span class="line">	Params.SourceASC = <span class="built_in">GetAbilitySystemComponentFromActorInfo</span>();</span><br><span class="line">	Params.TargetASC = UAbilitySystemBlueprintLibrary::<span class="built_in">GetAbilitySystemComponent</span>(TargetActor);</span><br><span class="line">	Params.DamageType = DamageType;</span><br><span class="line">	Params.BaseDamage = Damage.<span class="built_in">GetValueAtLevel</span>(<span class="built_in">GetAbilityLevel</span>());</span><br><span class="line">	Params.AbilityLevel = <span class="built_in">GetAbilityLevel</span>();</span><br><span class="line">	Params.DebuffChance = DebuffChance;</span><br><span class="line">	Params.DebuffDamage = DebuffDamage;</span><br><span class="line">	Params.DebuffDuration = DebuffDuration;</span><br><span class="line">	Params.DebuffFrequency = DebuffFrequency;</span><br><span class="line">	Params.DeathImpulseMagnitude = DeathImpulseMagnitude;</span><br><span class="line">	Params.KnockbackForceMagnitude = KnockbackForceMagnitude;</span><br><span class="line">	Params.KnockbackChance = KnockbackChance;</span><br><span class="line"></span><br><span class="line">	<span class="type">const</span> <span class="type">bool</span> bKnockback = FMath::<span class="built_in">RandRange</span>(<span class="number">1</span> , <span class="number">100</span>) &lt; Params.KnockbackChance;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">IsValid</span>(TargetActor))</span><br><span class="line">	&#123;</span><br><span class="line">		FRotator Rotation = (TargetActor-&gt;<span class="built_in">GetActorLocation</span>() - <span class="built_in">GetAvatarActorFromActorInfo</span>()-&gt;<span class="built_in">GetActorLocation</span>()).<span class="built_in">Rotation</span>();</span><br><span class="line">		Rotation.Pitch = <span class="number">45.f</span>;</span><br><span class="line">		<span class="keyword">if</span> (bOverridePitch)</span><br><span class="line">		&#123;</span><br><span class="line">			Rotation.Pitch = PitchOverride;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">const</span> FVector ToTarget = Rotation.<span class="built_in">Vector</span>();</span><br><span class="line">		<span class="keyword">if</span> (!bOverrideKnockbackDirection)</span><br><span class="line">		&#123;</span><br><span class="line">			Params.DeathImpulse = ToTarget * Params.DeathImpulseMagnitude;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!bOverrideDeathImpulse &amp;&amp; bKnockback)</span><br><span class="line">		&#123;</span><br><span class="line">			Params.KnockbackForce = ToTarget * Params.KnockbackForceMagnitude;	</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (bOverrideKnockbackDirection &amp;&amp; bKnockback)</span><br><span class="line">	&#123;</span><br><span class="line">		KnockbackDirectionOverride.<span class="built_in">Normalize</span>();</span><br><span class="line">		Params.KnockbackForce = KnockbackForceMagnitude * KnockbackDirectionOverride;</span><br><span class="line">		<span class="keyword">if</span> (bOverridePitch)</span><br><span class="line">		&#123;</span><br><span class="line">			FRotator KnockbackRotation = KnockbackDirectionOverride.<span class="built_in">Rotation</span>();</span><br><span class="line">			KnockbackRotation.Pitch = PitchOverride;</span><br><span class="line">			Params.KnockbackForce = KnockbackForceMagnitude * KnockbackRotation.<span class="built_in">Vector</span>();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (bOverrideDeathImpulse)</span><br><span class="line">	&#123;</span><br><span class="line">		DeathImpulseOverride.<span class="built_in">Normalize</span>();</span><br><span class="line">		Params.DeathImpulse = DeathImpulseMagnitude * DeathImpulseOverride;</span><br><span class="line">		<span class="keyword">if</span> (bOverridePitch)</span><br><span class="line">		&#123;</span><br><span class="line">			FRotator DeathImpulseRotation = DeathImpulseOverride.<span class="built_in">Rotation</span>();</span><br><span class="line">			DeathImpulseRotation.Pitch = PitchOverride;</span><br><span class="line">			Params.DeathImpulse = DeathImpulseMagnitude * DeathImpulseRotation.<span class="built_in">Vector</span>();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (bIsRadialDamage)</span><br><span class="line">	&#123;</span><br><span class="line">		Params.bIsRadialDamage = bIsRadialDamage;</span><br><span class="line">		Params.RadialDamageInnerRadius = RadialDamageInnerRadius;</span><br><span class="line">		Params.RadialDamageOuterRadius = RadialDamageOuterRadius;</span><br><span class="line">		Params.RadialDamageOrigin = InRadialDamageOrigin;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> Params;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的细节：<br>我们在 GA 中提前填写范围伤害中心、击退方向等信息，是因为 GA 中可直接获取发起者（GA 拥有者）和目标（鼠标追踪的 Actor，获取方式见<a href="">这里</a>），基于二者位置计算这些数据即可满足大部分场景需求。若需更精准的效果（如击退方向为击中瞬间的朝向），可在后续流程中覆盖 <code>FDamageEffectParams</code> 中的参数。<br>此外，该结构体仅存储攻击方数据，无法获取受击方的防御、抗性等信息。</p>
<h2 id="2-构建-GE-实例（通用函数）"><a href="#2-构建-GE-实例（通用函数）" class="headerlink" title="2. 构建 GE 实例（通用函数）"></a>2. 构建 GE 实例（通用函数）</h2><p>基于 <code>FDamageEffectParams</code> 制作 GE 实例的函数是通用逻辑，存放于 FunctionLibrary 中：</p>
<ul>
<li>近战伤害：可直接在 GA 中调用该函数；</li>
<li>远程伤害：需等到子弹击中目标时调用（覆盖 <code>FDamageEffectParams</code> 参数）。</li>
</ul>
<p>函数实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">FGameplayEffectContextHandle <span class="title">UCustomAbilitySystemLibrary::ApplyDamageEffect</span><span class="params">(<span class="type">const</span> FDamageEffectParams&amp; DamageEffectParams)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">const</span> FCustomGameplayTags GameplayTags = FCustomGameplayTags::<span class="built_in">Get</span>();</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 填写GameplayEffectContext</span></span><br><span class="line">	<span class="type">const</span> AActor* SourceAvatarActor = DamageEffectParams.SourceASC-&gt;<span class="built_in">GetAvatarActor</span>();</span><br><span class="line">	FGameplayEffectContextHandle EffectContextHandle = DamageEffectParams.SourceASC-&gt;<span class="built_in">MakeEffectContext</span>();</span><br><span class="line">	EffectContextHandle.<span class="built_in">AddSourceObject</span>(SourceAvatarActor);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">SetDeathImpulse</span>(EffectContextHandle , DamageEffectParams.DeathImpulse);</span><br><span class="line">	<span class="built_in">SetKnockbackForce</span>(EffectContextHandle , DamageEffectParams.KnockbackForce);</span><br><span class="line">	<span class="built_in">SetIsRadialDamage</span>(EffectContextHandle , DamageEffectParams.bIsRadialDamage);</span><br><span class="line">	<span class="built_in">SetRadialDamageInnerRadius</span>(EffectContextHandle , DamageEffectParams.RadialDamageInnerRadius);</span><br><span class="line">	<span class="built_in">SetRadialDamageOuterRadius</span>(EffectContextHandle , DamageEffectParams.RadialDamageOuterRadius);</span><br><span class="line">	<span class="built_in">SetRadialDamageOrigin</span>(EffectContextHandle , DamageEffectParams.RadialDamageOrigin);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 制作GameplayEffectSpec</span></span><br><span class="line">	FGameplayEffectSpecHandle SpecHandle = DamageEffectParams.SourceASC-&gt;<span class="built_in">MakeOutgoingSpec</span>(DamageEffectParams.DamageGEClass , DamageEffectParams.AbilityLevel , EffectContextHandle);</span><br><span class="line"></span><br><span class="line">	UAbilitySystemBlueprintLibrary::<span class="built_in">AssignTagSetByCallerMagnitude</span>(SpecHandle , DamageEffectParams.DamageType , DamageEffectParams.BaseDamage);</span><br><span class="line">	UAbilitySystemBlueprintLibrary::<span class="built_in">AssignTagSetByCallerMagnitude</span>(SpecHandle , GameplayTags.Debuff_Chance , DamageEffectParams.DebuffChance);</span><br><span class="line">	UAbilitySystemBlueprintLibrary::<span class="built_in">AssignTagSetByCallerMagnitude</span>(SpecHandle , GameplayTags.Debuff_Damage , DamageEffectParams.DebuffDamage);</span><br><span class="line">	UAbilitySystemBlueprintLibrary::<span class="built_in">AssignTagSetByCallerMagnitude</span>(SpecHandle , GameplayTags.Debuff_Duration , DamageEffectParams.DebuffDuration);</span><br><span class="line">	UAbilitySystemBlueprintLibrary::<span class="built_in">AssignTagSetByCallerMagnitude</span>(SpecHandle , GameplayTags.Debuff_Frequency , DamageEffectParams.DebuffFrequency);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 应用GameplayEffect到目标</span></span><br><span class="line">	DamageEffectParams.TargetASC-&gt;<span class="built_in">ApplyGameplayEffectSpecToSelf</span>(*SpecHandle.Data);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> EffectContextHandle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数核心分为三步：</p>
<ol>
<li>填写 GameplayEffectContext；</li>
<li>制作 GameplayEffectSpec；</li>
<li>应用 GameplayEffect 到目标。</li>
</ol>
<p>补充说明：代码中操作的 Handle 类型对象是 UE 的弱引用设计，关于 Handle 的更多内容可参考<a href="/ue5-blog/2025/12/10/ProgrammingSkills-Pointer/">此处</a>。</p>
<h3 id="填写-GameplayEffectContext"><a href="#填写-GameplayEffectContext" class="headerlink" title="填写 GameplayEffectContext"></a>填写 GameplayEffectContext</h3><p>步骤如下：</p>
<ol>
<li>调用 <code>MakeEffectContext</code> 创建新上下文，通过 <code>AddSourceObject</code> 填入 GE 发起者（易遗漏，编译时会报错提醒）；</li>
<li>自定义上下文需类型转换，因此 Set 类函数均包含 Cast 操作：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UCustomAbilitySystemLibrary::SetDeathImpulse</span><span class="params">(FGameplayEffectContextHandle&amp; EffectContextHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="type">const</span> FVector&amp; InDeathImpulse)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (FCustomGameplayEffectContext* CustomContext = <span class="built_in">static_cast</span>&lt;FCustomGameplayEffectContext*&gt;(EffectContextHandle.<span class="built_in">Get</span>()))</span><br><span class="line">	&#123;</span><br><span class="line">		CustomContext-&gt;<span class="built_in">SetDeathImpulse</span>(InDeathImpulse);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>自定义上下文需支持网络复制，为参数配置 Setter&#x2F;Getter 保证安全易用：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">USTRUCT</span>(BlueprintType)</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">FCustomGameplayEffectContext</span> : <span class="keyword">public</span> FGameplayEffectContext</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">IsBlockedHit</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> bIsBlockedHit;&#125;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">IsCriticalHit</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> bIsCriticalHit;&#125;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">IsSuccessfulDebuff</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> bIsSuccessfulDebuff;&#125;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">IsRadialDamage</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> bIsRadialDamage;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">float</span> <span class="title">GetDebuffDamage</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> DebuffDamage;&#125;</span><br><span class="line">	<span class="function"><span class="type">float</span> <span class="title">GetDebuffFrequency</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> DebuffFrequency;&#125;</span><br><span class="line">	<span class="function"><span class="type">float</span> <span class="title">GetDebuffDuration</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> DebuffDuration;&#125;</span><br><span class="line">	<span class="function"><span class="type">float</span> <span class="title">GetRadialDamageInnerRadius</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> RadialDamageInnerRadius;&#125;</span><br><span class="line">	<span class="function"><span class="type">float</span> <span class="title">GetRadialDamageOuterRadius</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> RadialDamageOuterRadius;&#125;</span><br><span class="line">	<span class="function">TSharedPtr&lt;FGameplayTag&gt; <span class="title">GetDamageType</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> DamageType;&#125;</span><br><span class="line">	<span class="function">FVector <span class="title">GetDeathImpulse</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> DeathImpulse;&#125;</span><br><span class="line">	<span class="function">FVector <span class="title">GetKnockbackForce</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> KnockbackForce;&#125;</span><br><span class="line">	<span class="function">FVector <span class="title">GetRadialDamageOrigin</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> RadialDamageOrigin;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">SetBlockedHit</span><span class="params">(<span class="type">bool</span> bInIsBlockedHit)</span> </span>&#123;bIsBlockedHit = bInIsBlockedHit;&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">SetCriticalHit</span><span class="params">(<span class="type">bool</span> bInIsCriticalHit)</span> </span>&#123;bIsCriticalHit = bInIsCriticalHit;&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">SetSuccessfulDebuff</span><span class="params">(<span class="type">bool</span> bInIsSuccessfulDebuff)</span></span>&#123; bIsSuccessfulDebuff = bInIsSuccessfulDebuff;&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">SetRadialDamage</span><span class="params">(<span class="type">bool</span> bInIsRadialDamage)</span></span>&#123;bIsRadialDamage = bInIsRadialDamage;&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">SetDebuffDamage</span><span class="params">(<span class="type">float</span> InDebuffDamage)</span> </span>&#123; DebuffDamage = InDebuffDamage;&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">SetDebuffDuration</span><span class="params">(<span class="type">float</span> InDebuffDuration)</span> </span>&#123; DebuffDuration = InDebuffDuration;&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">SetDebuffFrequency</span><span class="params">(<span class="type">float</span> InDebuffFrequency)</span></span>&#123; DebuffFrequency = InDebuffFrequency;&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">SetRadialDamageInnerRadius</span><span class="params">(<span class="type">float</span> InInnerRadius)</span></span>&#123;RadialDamageInnerRadius = InInnerRadius;&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">SetRadialDamageOuterRadius</span><span class="params">(<span class="type">float</span> InOuterRadius)</span></span>&#123;RadialDamageOuterRadius = InOuterRadius;&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">SetDamageType</span><span class="params">(TSharedPtr&lt;FGameplayTag&gt; InDamageType)</span> </span>&#123; DamageType = InDamageType; &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">SetDeathImpulse</span><span class="params">(<span class="type">const</span> FVector&amp; InImpulse)</span> </span>&#123; DeathImpulse = InImpulse; &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">SetKnockbackForce</span><span class="params">(<span class="type">const</span> FVector&amp; InForce)</span> </span>&#123; KnockbackForce = InForce; &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">SetRadialDamageOrigin</span><span class="params">(<span class="type">const</span> FVector&amp; InOrigin)</span> </span>&#123; RadialDamageOrigin = InOrigin; &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> UScriptStruct* <span class="title">GetScriptStruct</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">StaticStruct</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> FCustomGameplayEffectContext* <span class="title">Duplicate</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		FCustomGameplayEffectContext* NewContext = <span class="keyword">new</span> <span class="built_in">FCustomGameplayEffectContext</span>();</span><br><span class="line">		*NewContext = *<span class="keyword">this</span>;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">GetHitResult</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			NewContext-&gt;<span class="built_in">AddHitResult</span>(*<span class="built_in">GetHitResult</span>(), <span class="literal">true</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> NewContext;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">NetSerialize</span><span class="params">(FArchive&amp; Ar, <span class="keyword">class</span> UPackageMap* Map, <span class="type">bool</span>&amp; bOutSuccess)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="built_in">UPROPERTY</span>()</span><br><span class="line">	<span class="type">bool</span> bIsBlockedHit = <span class="literal">false</span>;</span><br><span class="line">	<span class="built_in">UPROPERTY</span>()</span><br><span class="line">	<span class="type">bool</span> bIsCriticalHit = <span class="literal">false</span>;</span><br><span class="line">	<span class="built_in">UPROPERTY</span>()</span><br><span class="line">	<span class="type">bool</span> bIsSuccessfulDebuff = <span class="literal">false</span>;</span><br><span class="line">	<span class="built_in">UPROPERTY</span>()</span><br><span class="line">	<span class="type">float</span> DebuffDamage = <span class="number">0.f</span>;</span><br><span class="line">	<span class="built_in">UPROPERTY</span>()</span><br><span class="line">	<span class="type">float</span> DebuffFrequency = <span class="number">0.f</span>;</span><br><span class="line">	<span class="built_in">UPROPERTY</span>()</span><br><span class="line">	<span class="type">float</span> DebuffDuration = <span class="number">0.f</span>;</span><br><span class="line">	TSharedPtr&lt;FGameplayTag&gt; DamageType;</span><br><span class="line">	<span class="built_in">UPROPERTY</span>()</span><br><span class="line">	FVector DeathImpulse = FVector::ZeroVector;</span><br><span class="line">	<span class="built_in">UPROPERTY</span>()</span><br><span class="line">	FVector KnockbackForce = FVector::ZeroVector;</span><br><span class="line">	<span class="built_in">UPROPERTY</span>()</span><br><span class="line">	<span class="type">bool</span> bIsRadialDamage = <span class="literal">false</span>;</span><br><span class="line">	<span class="built_in">UPROPERTY</span>()</span><br><span class="line">	<span class="type">float</span> RadialDamageInnerRadius = <span class="number">0.f</span>;</span><br><span class="line">	<span class="built_in">UPROPERTY</span>()</span><br><span class="line">	<span class="type">float</span> RadialDamageOuterRadius = <span class="number">0.f</span>;</span><br><span class="line">	<span class="built_in">UPROPERTY</span>()</span><br><span class="line">	FVector RadialDamageOrigin = FVector::ZeroVector;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TStructOpsTypeTraits</span>&lt;FCustomGameplayEffectContext&gt; : <span class="keyword">public</span> TStructOpsTypeTraitsBase2&lt;FCustomGameplayEffectContext&gt;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">enum</span></span><br><span class="line">	&#123;</span><br><span class="line">		WithNetSerializer = <span class="literal">true</span>,</span><br><span class="line">		WithCopy = <span class="literal">true</span></span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>使用自定义Context还需要完成如下步骤：</p>
<ul>
<li><ol>
<li>创建自定义Globals类，并重写函数<code>AllocGameplayEffectContext</code></li>
</ol>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GAS_Custom_API</span> UCustomAbilitySystemGlobals : <span class="keyword">public</span> UAbilitySystemGlobals</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> FGameplayEffectContext* <span class="title">AllocGameplayEffectContext</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">	</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">FGameplayEffectContext* <span class="title">UCustomAbilitySystemGlobals::AllocGameplayEffectContext</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">FCustomGameplayEffectContext</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><ol start="2">
<li>更改配置，使用自定义Context<br>修改Config&#x2F;DefaultGame.ini文件，添加如下内容：</li>
</ol>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[/Script/GameplayAbilities.AbilitySystemGlobals]</span><br><span class="line">+AbilitySystemGlobalsClassName=&quot;Script/ProjectName.CustomeAbilitySystemGlobals&quot;</span><br></pre></td></tr></table></figure>

<h3 id="制作-GameplayEffectSpec"><a href="#制作-GameplayEffectSpec" class="headerlink" title="制作 GameplayEffectSpec"></a>制作 GameplayEffectSpec</h3><p>调用 <code>MakeOutgoingSpec</code> 制作 Spec，需传入 GE 模板类、等级和上下文信息。Spec 是控制 GE 实例化的核心，应用 Spec 即表示将 GE 实例挂载到目标 ASC 上。</p>
<p>核心问题是确定 GE 修改的属性数值（如伤害值）：</p>
<ol>
<li>数据传递：攻击方攻击力已封装在 EffectParams 中，但未传入 Context（Context 主要传递 GE 后续影响，攻击力仅影响 GE 最终修改的属性值）；</li>
<li>Debuff 数据处理：虽自定义 Context 包含 Debuff 数据，但暂不传递，原因是：<ul>
<li>Debuff 是概率事件，未触发时无需序列化，可优化性能；</li>
<li>Debuff 需结合受击方抗性计算，此时仅能获取攻击方数据，传递时机过早。</li>
</ul>
</li>
</ol>
<p>因此需通过 SetByCaller 将 EffectParams 数据传入 EffectSpec——Spec 内部维护 Tag 到数值的映射表，存取方式如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 绑定数据到Tag</span></span><br><span class="line">UAbilitySystemBlueprintLibrary::<span class="built_in">AssignTagSetByCallerMagnitude</span>(SpecHandle , DamageEffectParams.DamageType , DamageEffectParams.BaseDamage);</span><br><span class="line"><span class="comment">// 从Tag读取数据（后两个参数：未找到标签是否警告、未找到时返回值）</span></span><br><span class="line"><span class="type">const</span> <span class="type">float</span> TypeDamage = Spec.<span class="built_in">GetSetByCallerMagnitude</span>(DamageType , <span class="literal">false</span> , <span class="number">-1.f</span>);</span><br></pre></td></tr></table></figure>

<p>其中 DamageType 标签用于区分攻击类型（如火攻、雷攻）。</p>
<h3 id="应用-GameplayEffect-到目标"><a href="#应用-GameplayEffect-到目标" class="headerlink" title="应用 GameplayEffect 到目标"></a>应用 GameplayEffect 到目标</h3><p>代码中调用 <code>TargetASC-&gt;ApplyGameplayEffectSpecToSelf</code> 看似直接应用 GE，但核心的伤害计算封装在底层——GE 最终挂载在目标 ASC 上，EffectSpec 已包含上下文和 SetByCaller 数据，足以支撑计算。</p>
<p>GE 模板类（如 GE_Damage）需定义以下核心要素：</p>
<ol>
<li>Duration Policy：分为 Instant（瞬时）、Infinite（永久）、Duration（持续），暂不考虑持续伤害（归为 Debuff 处理）；</li>
<li>Modifier：简单数值计算（硬编码&#x2F;ScalableFloat），Debuff 的 GE 会用到；</li>
<li>Execution：复杂数值计算（捕获属性、定制化逻辑），需在蓝图中添加继承自 <code>UGameplayEffectExecutionCalculation</code> 的自定义类型；</li>
<li>Component：挂载 Tag，Debuff 的 GE 会用到；</li>
<li>Stacking：叠加策略，简化场景下选 None 即可。</li>
</ol>
<h4 id="Exec-Damage-定制化计算"><a href="#Exec-Damage-定制化计算" class="headerlink" title="Exec_Damage 定制化计算"></a>Exec_Damage 定制化计算</h4><p>核心是重写 <code>Execute_Implementation</code> 函数，步骤如下：</p>
<h5 id="步骤1：定义并注册属性捕获规则"><a href="#步骤1：定义并注册属性捕获规则" class="headerlink" title="步骤1：定义并注册属性捕获规则"></a>步骤1：定义并注册属性捕获规则</h5><p>通过静态函数封装规则避免重复注册，规则格式：<code>DEFINE_ATTRIBUTE_CAPTUREDEF(AS类 , 属性名 , 捕获源（Source/Target） , 是否快照)</code>。是否快照一般选 false，防止参数变化影响计算。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">CustomDamageStatics</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">DECLARE_ATTRIBUTE_CAPTUREDEF</span>(Armor);</span><br><span class="line">	<span class="built_in">DECLARE_ATTRIBUTE_CAPTUREDEF</span>(ArmorPenetration);</span><br><span class="line">	<span class="built_in">DECLARE_ATTRIBUTE_CAPTUREDEF</span>(BlockChance);</span><br><span class="line">	<span class="built_in">DECLARE_ATTRIBUTE_CAPTUREDEF</span>(CriticalHitChance);</span><br><span class="line">	<span class="built_in">DECLARE_ATTRIBUTE_CAPTUREDEF</span>(CriticalHitDamage);</span><br><span class="line">	<span class="built_in">DECLARE_ATTRIBUTE_CAPTUREDEF</span>(CriticalHitResistance);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">DECLARE_ATTRIBUTE_CAPTUREDEF</span>(FireResistance);</span><br><span class="line">	<span class="built_in">DECLARE_ATTRIBUTE_CAPTUREDEF</span>(LightningResistance);</span><br><span class="line">	<span class="built_in">DECLARE_ATTRIBUTE_CAPTUREDEF</span>(ArcaneResistance);</span><br><span class="line">	<span class="built_in">DECLARE_ATTRIBUTE_CAPTUREDEF</span>(PhysicalResistance);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">CustomDamageStatics</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">DEFINE_ATTRIBUTE_CAPTUREDEF</span>(UCustomAttributeSet , Armor , Target , <span class="literal">false</span>);</span><br><span class="line">		<span class="built_in">DEFINE_ATTRIBUTE_CAPTUREDEF</span>(UCustomAttributeSet , ArmorPenetration , Source , <span class="literal">false</span>);</span><br><span class="line">		<span class="built_in">DEFINE_ATTRIBUTE_CAPTUREDEF</span>(UCustomAttributeSet , BlockChance , Target , <span class="literal">false</span>);</span><br><span class="line">		<span class="built_in">DEFINE_ATTRIBUTE_CAPTUREDEF</span>(UCustomAttributeSet , CriticalHitChance , Source , <span class="literal">false</span>);</span><br><span class="line">		<span class="built_in">DEFINE_ATTRIBUTE_CAPTUREDEF</span>(UCustomAttributeSet , CriticalHitDamage , Source , <span class="literal">false</span>);</span><br><span class="line">		<span class="built_in">DEFINE_ATTRIBUTE_CAPTUREDEF</span>(UCustomAttributeSet , CriticalHitResistance , Target , <span class="literal">false</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="built_in">DEFINE_ATTRIBUTE_CAPTUREDEF</span>(UCustomAttributeSet , FireResistance , Target , <span class="literal">false</span>);</span><br><span class="line">		<span class="built_in">DEFINE_ATTRIBUTE_CAPTUREDEF</span>(UCustomAttributeSet , LightningResistance , Target , <span class="literal">false</span>);</span><br><span class="line">		<span class="built_in">DEFINE_ATTRIBUTE_CAPTUREDEF</span>(UCustomAttributeSet , ArcaneResistance , Target , <span class="literal">false</span>);</span><br><span class="line">		<span class="built_in">DEFINE_ATTRIBUTE_CAPTUREDEF</span>(UCustomAttributeSet , PhysicalResistance , Target , <span class="literal">false</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">const</span> CustomDamageStatics&amp; <span class="title">DamageStatics</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">static</span> CustomDamageStatics  DStatics;</span><br><span class="line">	<span class="keyword">return</span> DStatics;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="步骤2：注册捕获规则"><a href="#步骤2：注册捕获规则" class="headerlink" title="步骤2：注册捕获规则"></a>步骤2：注册捕获规则</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">UExecCalc_Damage::<span class="built_in">UExecCalc_Damage</span>()</span><br><span class="line">&#123;</span><br><span class="line">	RelevantAttributesToCapture.<span class="built_in">Add</span>(<span class="built_in">DamageStatics</span>().ArmorDef);</span><br><span class="line">	RelevantAttributesToCapture.<span class="built_in">Add</span>(<span class="built_in">DamageStatics</span>().ArmorPenetrationDef);</span><br><span class="line">	RelevantAttributesToCapture.<span class="built_in">Add</span>(<span class="built_in">DamageStatics</span>().BlockChanceDef);</span><br><span class="line">	RelevantAttributesToCapture.<span class="built_in">Add</span>(<span class="built_in">DamageStatics</span>().CriticalHitChanceDef);</span><br><span class="line">	RelevantAttributesToCapture.<span class="built_in">Add</span>(<span class="built_in">DamageStatics</span>().CriticalHitDamageDef);</span><br><span class="line">	RelevantAttributesToCapture.<span class="built_in">Add</span>(<span class="built_in">DamageStatics</span>().CriticalHitResistanceDef);</span><br><span class="line">	</span><br><span class="line">	RelevantAttributesToCapture.<span class="built_in">Add</span>(<span class="built_in">DamageStatics</span>().FireResistanceDef);</span><br><span class="line">	RelevantAttributesToCapture.<span class="built_in">Add</span>(<span class="built_in">DamageStatics</span>().LightningResistanceDef);</span><br><span class="line">	RelevantAttributesToCapture.<span class="built_in">Add</span>(<span class="built_in">DamageStatics</span>().ArcaneResistanceDef);</span><br><span class="line">	RelevantAttributesToCapture.<span class="built_in">Add</span>(<span class="built_in">DamageStatics</span>().PhysicalResistanceDef);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="步骤3：使用捕获属性计算伤害"><a href="#步骤3：使用捕获属性计算伤害" class="headerlink" title="步骤3：使用捕获属性计算伤害"></a>步骤3：使用捕获属性计算伤害</h5><p>先准备 EvaluateParams 和 Context，再调用 <code>AttemptCalculateCapturedAttributeMagnitude</code> 获取属性值，同时将是否暴击等信息写入 Context（引用传递可直接修改）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> FGameplayEffectSpec&amp; Spec = ExecutionParams.<span class="built_in">GetOwningSpec</span>();</span><br><span class="line">FGameplayEffectContextHandle EffectContextHandle = Spec.<span class="built_in">GetContext</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> FGameplayTagContainer* SourceTags = Spec.CapturedSourceTags.<span class="built_in">GetAggregatedTags</span>();</span><br><span class="line"><span class="type">const</span> FGameplayTagContainer* TargetTags = Spec.CapturedTargetTags.<span class="built_in">GetAggregatedTags</span>();</span><br><span class="line">FAggregatorEvaluateParameters EvaluateParameters;</span><br><span class="line">EvaluateParameters.SourceTags = SourceTags;</span><br><span class="line">EvaluateParameters.TargetTags = TargetTags;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> TargetBlockChance = <span class="number">0.f</span>;</span><br><span class="line">ExecutionParams.<span class="built_in">AttemptCalculateCapturedAttributeMagnitude</span>(<span class="built_in">DamageStatics</span>().BlockChanceDef , EvaluateParameters , TargetBlockChance);</span><br><span class="line">TargetBlockChance = FMath::<span class="built_in">Max</span>&lt;<span class="type">float</span>&gt;(TargetBlockChance, <span class="number">0.f</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">bool</span> bBlocked = FMath::<span class="built_in">RandRange</span>(<span class="number">1</span> , <span class="number">100</span>) &lt; TargetBlockChance;</span><br><span class="line">UCustomAbilitySystemLibrary::<span class="built_in">SetIsBlockedHit</span>(EffectContextHandle , bBlocked);</span><br><span class="line"></span><br><span class="line">Damage = bBlocked ? Damage / <span class="number">2.f</span> : Damage;</span><br></pre></td></tr></table></figure>

<h4 id="RadialDamage-范围伤害实现"><a href="#RadialDamage-范围伤害实现" class="headerlink" title="RadialDamage 范围伤害实现"></a>RadialDamage 范围伤害实现</h4><p>实现步骤：</p>
<ol>
<li>计算完抗性减免后的伤害值 DamageTypeValue；</li>
<li>调用 <code>UGameplayStatics::ApplyRadialDamageWithFalloff</code> 计算范围伤害；</li>
<li>该函数会触发角色类 <code>TakeDamage</code>，需在 <code>TakeDamage</code> 中广播伤害值，再绑定回调获取并覆盖 DamageTypeValue。</li>
</ol>
<p>逻辑需注意：先绑定回调再广播，才能正确捕获数值：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (UCustomAbilitySystemLibrary::<span class="built_in">IsRadialDamage</span>(EffectContextHandle))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (ICombatInterface* CombatInterface = <span class="built_in">Cast</span>&lt;ICombatInterface&gt;(TargetAvatar))</span><br><span class="line">    &#123;</span><br><span class="line">        CombatInterface-&gt;<span class="built_in">GetOnDamageDelegate</span>().<span class="built_in">AddLambda</span>(</span><br><span class="line">            [&amp;](<span class="type">float</span> DamageAmount)</span><br><span class="line">            &#123;</span><br><span class="line">                DamageTypeValue = DamageAmount;</span><br><span class="line">            &#125;</span><br><span class="line">            );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    UGameplayStatics::<span class="built_in">ApplyRadialDamageWithFalloff</span>(</span><br><span class="line">        TargetAvatar ,</span><br><span class="line">        DamageTypeValue ,</span><br><span class="line">        <span class="number">0.f</span> ,</span><br><span class="line">        UCustomAbilitySystemLibrary::<span class="built_in">GetRadialDamageOrigin</span>(EffectContextHandle) ,</span><br><span class="line">        UCustomAbilitySystemLibrary::<span class="built_in">GetRadialDamageInnerRadius</span>(EffectContextHandle) ,</span><br><span class="line">        UCustomAbilitySystemLibrary::<span class="built_in">GetRadialDamageOuterRadius</span>(EffectContextHandle) ,</span><br><span class="line">        <span class="number">1.f</span> ,</span><br><span class="line">        UDamageType::<span class="built_in">StaticClass</span>() ,</span><br><span class="line">        <span class="built_in">TArray</span>&lt;AActor*&gt;() ,</span><br><span class="line">        SourceAvatar ,</span><br><span class="line">        <span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>补充说明：该方式逻辑稍绕，但无需关注范围伤害细节；也可基于 Context 中的范围伤害原点、目标位置自定义算法实现。</p>
<h4 id="Debuff-处理"><a href="#Debuff-处理" class="headerlink" title="Debuff 处理"></a>Debuff 处理</h4><p>Debuff 是伤害 GE 的附加作用，核心是填充 Context（在 Execution 中计算是因为需结合受击方抗性，而非仅用攻击方数据）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">float</span> TypeDamage = Spec.<span class="built_in">GetSetByCallerMagnitude</span>(DamageType , <span class="literal">false</span> , <span class="number">-1.f</span>);</span><br><span class="line"><span class="keyword">if</span> (TypeDamage &gt; <span class="number">-1.f</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">float</span> SourceDebuffChance = Spec.<span class="built_in">GetSetByCallerMagnitude</span>(GameplayTags.Debuff_Chance , <span class="literal">false</span> , <span class="number">-1.f</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> TargetDebuffResistance = <span class="number">0.f</span>;</span><br><span class="line">    <span class="type">const</span> FGameplayTag&amp; ResistanceTag = GameplayTags.DamageTypesToResistances[DamageType];</span><br><span class="line">    ExecutionParams.<span class="built_in">AttemptCalculateCapturedAttributeMagnitude</span>(InTagsToDefs[ResistanceTag] , EvaluateParameters , TargetDebuffResistance);</span><br><span class="line">    <span class="type">const</span> <span class="type">float</span> EffectiveDebuffChance = SourceDebuffChance * (<span class="number">100.f</span> - TargetDebuffResistance) / <span class="number">100.f</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span> bDebuff = FMath::<span class="built_in">RandRange</span>(<span class="number">1</span> , <span class="number">100</span>) &lt; EffectiveDebuffChance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bDebuff)</span><br><span class="line">    &#123;</span><br><span class="line">        FGameplayEffectContextHandle ContextHandle = Spec.<span class="built_in">GetContext</span>();</span><br><span class="line"></span><br><span class="line">        UCustomAbilitySystemLibrary::<span class="built_in">SetIsSuccessfulDebuff</span>(ContextHandle , <span class="literal">true</span>);</span><br><span class="line">        UCustomAbilitySystemLibrary::<span class="built_in">SetDamageType</span>(ContextHandle , DamageType);</span><br><span class="line"></span><br><span class="line">        <span class="type">const</span> <span class="type">float</span> DebuffDamage = Spec.<span class="built_in">GetSetByCallerMagnitude</span>(GameplayTags.Debuff_Damage , <span class="literal">false</span> , <span class="number">-1.f</span>);</span><br><span class="line">        <span class="type">const</span> <span class="type">float</span> DebuffDuration = Spec.<span class="built_in">GetSetByCallerMagnitude</span>(GameplayTags.Debuff_Duration, <span class="literal">false</span> , <span class="number">-1.f</span>);</span><br><span class="line">        <span class="type">const</span> <span class="type">float</span> DebuffFrequency = Spec.<span class="built_in">GetSetByCallerMagnitude</span>(GameplayTags.Debuff_Frequency , <span class="literal">false</span> , <span class="number">-1.f</span>);</span><br><span class="line"></span><br><span class="line">        UCustomAbilitySystemLibrary::<span class="built_in">SetDebuffDamage</span>(ContextHandle , DebuffDamage);</span><br><span class="line">        UCustomAbilitySystemLibrary::<span class="built_in">SetDebuffDuration</span>(ContextHandle , DebuffDuration);</span><br><span class="line">        UCustomAbilitySystemLibrary::<span class="built_in">SetDebuffFrequency</span>(ContextHandle , DebuffFrequency);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：DamageType 是预定义的伤害类型 Tag，若 <code>AssignTagSetByCallerMagnitude</code> 未注册对应 Tag，读取会返回 -1.f。</p>
<h1 id="Debuff的生效"><a href="#Debuff的生效" class="headerlink" title="Debuff的生效"></a>Debuff的生效</h1><p>GE_Damage 最终传递到目标 AS（修改元属性 IncomingDamage，原因见<a href="/ue5-blog/2025/12/12/GAS-AS/">此处</a>），传递的不仅是属性数值，还有完整的 GE Context——AS 会基于 Context 处理 Debuff 等附加效果。</p>
<p>AS 中检测到 Context 标记 <code>IsSuccessfulDebuff</code> 为 true 时，调用 <code>HandleDebuff</code> 处理：Debuff 本质是新的 GE（无需复用 GE_Damage，避免冗余的击退、暴击逻辑），需动态创建并挂载到目标 ASC。</p>
<p>具体步骤：</p>
<ol>
<li>制作 Context，填入 <code>AddSourceObject</code>；</li>
<li>新建 GE 实例：<code>NewObject&lt;UGameplayEffect&gt;(GetTransientPackage() , FName(DebuffName))</code>（Outer 参数用 <code>GetTransientPackage()</code>）；</li>
<li>配置 Duration Policy（使用 Context 传递的数值，数据已整理到 Props 结构体，见<a href="/ue5-blog/2025/12/12/GAS-AS/">此处</a>）；</li>
<li>添加 Tag（示例：眩晕 Debuff 屏蔽玩家输入）；</li>
<li>设置堆叠规则（限制叠加重数）；</li>
<li>添加 Modifier（用简单的 FScalableFloat 类型）；</li>
<li>应用新建的 GE。</li>
</ol>
<p>代码实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UCustomAttributeSet::HandleDebuff</span><span class="params">(<span class="type">const</span> FEffectProperties&amp; Props)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">const</span> FCustomGameplayTags GameplayTags = FCustomGameplayTags::<span class="built_in">Get</span>();</span><br><span class="line">	</span><br><span class="line">	FGameplayEffectContextHandle EffectContext = Props.SourceASC-&gt;<span class="built_in">MakeEffectContext</span>();</span><br><span class="line">	EffectContext.<span class="built_in">AddSourceObject</span>(Props.SourceAvatarActor);</span><br><span class="line"></span><br><span class="line">	<span class="type">const</span> FGameplayTag DamageType = UCustomAbilitySystemLibrary::<span class="built_in">GetDamageType</span>(Props.EffectContextHandle);</span><br><span class="line">	<span class="type">const</span> <span class="type">float</span> DebuffDamage = UCustomAbilitySystemLibrary::<span class="built_in">GetDebuffDamage</span>(Props.EffectContextHandle);</span><br><span class="line">	<span class="type">const</span> <span class="type">float</span> DebuffDuration = UCustomAbilitySystemLibrary::<span class="built_in">GetDebuffDuration</span>(Props.EffectContextHandle);</span><br><span class="line">	<span class="type">const</span> <span class="type">float</span> DebuffFrequency = UCustomAbilitySystemLibrary::<span class="built_in">GetDebuffFrequency</span>(Props.EffectContextHandle);</span><br><span class="line">	</span><br><span class="line">	FString DebuffName = FString::<span class="built_in">Printf</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;DynamicDebuff_%s&quot;</span>) , *DamageType.<span class="built_in">ToString</span>() );</span><br><span class="line">	UGameplayEffect* Effect = <span class="built_in">NewObject</span>&lt;UGameplayEffect&gt;(<span class="built_in">GetTransientPackage</span>() , <span class="built_in">FName</span>(DebuffName));</span><br><span class="line"></span><br><span class="line">	Effect-&gt;DurationPolicy = EGameplayEffectDurationType::HasDuration;</span><br><span class="line">	Effect-&gt;Period = DebuffFrequency;</span><br><span class="line">	Effect-&gt;DurationMagnitude = <span class="built_in">FScalableFloat</span>(DebuffDuration);</span><br><span class="line"></span><br><span class="line">	<span class="type">const</span> FGameplayTag DebuffTag = GameplayTags.DamageTypesToDebuffs[DamageType];</span><br><span class="line">	FInheritedTagContainer TagContainer = <span class="built_in">FInheritedTagContainer</span>();</span><br><span class="line">	UTargetTagsGameplayEffectComponent&amp; Component = Effect-&gt;<span class="built_in">FindOrAddComponent</span>&lt;UTargetTagsGameplayEffectComponent&gt;();</span><br><span class="line">	TagContainer.Added.<span class="built_in">AddTag</span>(DebuffTag);</span><br><span class="line">	<span class="keyword">if</span> (DebuffTag.<span class="built_in">MatchesTagExact</span>(GameplayTags.Debuff_Stun))</span><br><span class="line">	&#123;</span><br><span class="line">		TagContainer.Added.<span class="built_in">AddTag</span>(GameplayTags.Player_Block_InputHeld);</span><br><span class="line">		TagContainer.Added.<span class="built_in">AddTag</span>(GameplayTags.Player_Block_CursorTrace);</span><br><span class="line">		TagContainer.Added.<span class="built_in">AddTag</span>(GameplayTags.Player_Block_InputPressed);</span><br><span class="line">		TagContainer.Added.<span class="built_in">AddTag</span>(GameplayTags.Player_Block_InputReleased);</span><br><span class="line">	&#125;</span><br><span class="line">	Component.<span class="built_in">SetAndApplyTargetTagChanges</span>(TagContainer);</span><br><span class="line"></span><br><span class="line">	Effect-&gt;StackingType = EGameplayEffectStackingType::AggregateBySource;</span><br><span class="line">	Effect-&gt;StackLimitCount = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="type">const</span> int32 Index = Effect-&gt;Modifiers.<span class="built_in">Num</span>();</span><br><span class="line">	Effect-&gt;Modifiers.<span class="built_in">Add</span>(<span class="built_in">FGameplayModifierInfo</span>());</span><br><span class="line">	FGameplayModifierInfo&amp; ModifierInfo = Effect-&gt;Modifiers[Index];</span><br><span class="line"></span><br><span class="line">	ModifierInfo.ModifierMagnitude = <span class="built_in">FScalableFloat</span>(DebuffDamage);</span><br><span class="line">	ModifierInfo.ModifierOp = EGameplayModOp::Additive;</span><br><span class="line">	ModifierInfo.Attribute = UCustomAttributeSet::<span class="built_in">GetIncomingDamageAttribute</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (FGameplayEffectSpec* MutableSpec = <span class="keyword">new</span> <span class="built_in">FGameplayEffectSpec</span>(Effect , EffectContext , <span class="number">1.f</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		FCustomGameplayEffectContext* CustomContext = <span class="built_in">static_cast</span>&lt;FCustomGameplayEffectContext*&gt;(MutableSpec-&gt;<span class="built_in">GetContext</span>().<span class="built_in">Get</span>());</span><br><span class="line">		TSharedPtr&lt;FGameplayTag&gt; DebuffDamageType = <span class="built_in">MakeShareable</span>(<span class="keyword">new</span> <span class="built_in">FGameplayTag</span>(DamageType));</span><br><span class="line">		CustomContext-&gt;<span class="built_in">SetDamageType</span>(DebuffDamageType);</span><br><span class="line">		Props.TargetASC-&gt;<span class="built_in">ApplyGameplayEffectSpecToSelf</span>(*MutableSpec);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="ModMagCalc-MMC"><a href="#ModMagCalc-MMC" class="headerlink" title="ModMagCalc (MMC)"></a>ModMagCalc (MMC)</h1><p>补充一种 GE 数值计算方式：在 Modifier 中选择 MMC 并自定义类型，是 Execution 的弱化版，仅需完成以下步骤：</p>
<ol>
<li>定义捕获属性，在构造函数中注册；</li>
<li>重写 <code>CalculateBaseMagnitude_Implementation</code> 返回计算结果；</li>
<li>计算前准备 EvaluateParams，调用 <code>GetCapturedAttributeMagnitude</code> 获取属性值；</li>
<li>基于获取的数据完成计算并返回。</li>
</ol>
<p>声明与实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GAS_Custom_API</span> UMMC_MaxHealth : <span class="keyword">public</span> UGameplayModMagnitudeCalculation</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">GENERATED_BODY</span>()</span><br><span class="line">	</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">UMMC_MaxHealth</span>();</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">float</span> <span class="title">CalculateBaseMagnitude_Implementation</span><span class="params">(<span class="type">const</span> FGameplayEffectSpec&amp; Spec)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	FGameplayEffectAttributeCaptureDefinition VigorDef;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">UMMC_MaxHealth::<span class="built_in">UMMC_MaxHealth</span>()</span><br><span class="line">&#123;</span><br><span class="line">	VigorDef.AttributeToCapture = UCustomAttributeSet::<span class="built_in">GetVigorAttribute</span>();</span><br><span class="line">	VigorDef.AttributeSource = EGameplayEffectAttributeCaptureSource::Target;</span><br><span class="line">	VigorDef.bSnapshot = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	RelevantAttributesToCapture.<span class="built_in">Add</span>(VigorDef);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">UMMC_MaxHealth::CalculateBaseMagnitude_Implementation</span><span class="params">(<span class="type">const</span> FGameplayEffectSpec&amp; Spec)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">	<span class="type">const</span> FGameplayTagContainer* SourceTags = Spec.CapturedSourceTags.<span class="built_in">GetAggregatedTags</span>();</span><br><span class="line">	<span class="type">const</span> FGameplayTagContainer* TargetTags = Spec.CapturedTargetTags.<span class="built_in">GetAggregatedTags</span>();</span><br><span class="line">	FAggregatorEvaluateParameters EvaluateParameters;</span><br><span class="line">	EvaluateParameters.SourceTags = SourceTags;</span><br><span class="line">	EvaluateParameters.TargetTags = TargetTags;</span><br><span class="line"></span><br><span class="line">	<span class="type">float</span> Vigor = <span class="number">0.f</span>;</span><br><span class="line">	<span class="built_in">GetCapturedAttributeMagnitude</span>(VigorDef , Spec , EvaluateParameters , Vigor);</span><br><span class="line">	Vigor = FMath::<span class="built_in">Max</span>&lt;<span class="type">float</span>&gt;(Vigor , <span class="number">0.f</span>);</span><br><span class="line"></span><br><span class="line">	int32 PlayerLevel = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (Spec.<span class="built_in">GetContext</span>().<span class="built_in">GetSourceObject</span>()-&gt;<span class="built_in">Implements</span>&lt;UCombatInterface&gt;())</span><br><span class="line">	&#123;</span><br><span class="line">		PlayerLevel = ICombatInterface::<span class="built_in">Execute_GetPlayerLevel</span>(Spec.<span class="built_in">GetContext</span>().<span class="built_in">GetSourceObject</span>());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">80.f</span> + <span class="number">2.5f</span> * Vigor + <span class="number">10.f</span> * PlayerLevel;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>SystemDesigns</category>
        <category>GAS</category>
      </categories>
      <tags>
        <tag>GAS</tag>
        <tag>GE</tag>
      </tags>
  </entry>
  <entry>
    <title>GameplayEvent</title>
    <url>/ue5-blog//2025/12/12/GAS-GameplayEvent/</url>
    <content><![CDATA[<h1 id="核心总结"><a href="#核心总结" class="headerlink" title="核心总结"></a>核心总结</h1><p>GameplayEvent 是 GAS 框架中类委托（Delegate）的消息传递机制，核心作用是实现对象间的事件通知与数据传递：通过自定义事件标签发送包含数据的事件，Actor 所拥有的 GameplayAbility（GA）可通过 <code>WaitGameplayEvent</code> 监听并响应事件，相比普通委托，它是定制化的消息管道，专用于 GAS 体系内的事件交互。</p>
<span id="more"></span>

<h1 id="GameplayEvent-的作用"><a href="#GameplayEvent-的作用" class="headerlink" title="GameplayEvent 的作用"></a>GameplayEvent 的作用</h1><p>GameplayEvent 功能上与委托（Delegate）相似，核心用于<strong>对象间的事件通知与数据传递</strong>：当一个对象需要触发另一个对象执行特定逻辑时，可发送带有自定义标签的 GameplayEvent，并在事件中承载数据供接收方处理。</p>
<p>其与普通委托的核心区别在于：GameplayEvent 是 GAS 体系下的定制化消息管道，事件会发送至目标 Actor，该 Actor 挂载的 GA 可通过 <code>WaitGameplayEvent</code> 节点&#x2F;函数监听并捕获对应事件，适配 GAS 框架的能力体系设计。</p>
<h1 id="GameplayEvent-的使用"><a href="#GameplayEvent-的使用" class="headerlink" title="GameplayEvent 的使用"></a>GameplayEvent 的使用</h1><p>以下通过两个典型场景，说明 GameplayEvent 的发送、接收及数据传递方式：</p>
<h2 id="场景1：来自动画的通知（无数据传递）"><a href="#场景1：来自动画的通知（无数据传递）" class="headerlink" title="场景1：来自动画的通知（无数据传递）"></a>场景1：来自动画的通知（无数据传递）</h2><p>以火球技能（GA_FireBolt）为例，需求是“角色动画播放到指定帧时，生成并释放火球”，核心流程如下：</p>
<ol>
<li><strong>插入动画通知</strong>：在火球技能对应的动画蒙太奇（Montage）中，在目标时间点插入 Anim_Notify，绑定事件标签 <code>Event.Montage.FireBolt</code>；</li>
<li><strong>发送 GameplayEvent</strong>：在该 Anim_Notify 的逻辑中，向角色 Actor 发送带有 <code>Event.Montage.FireBolt</code> 标签的 GameplayEvent（无额外数据）；<br><img src="/ue5-blog/2025/12/12/GAS-GameplayEvent/GameplayEvent_1.png" alt="alt text"></li>
<li><strong>监听并响应事件</strong>：在 GA_FireBolt 中播放动画蒙太奇的同时，启用 <code>WaitGameplayEvent</code> 监听 <code>Event.Montage.FireBolt</code> 标签；一旦捕获到该事件，即判定动画播放至指定时机，执行火球生成与释放逻辑。<br><img src="/ue5-blog/2025/12/12/GAS-GameplayEvent/GameplayEvent_2.png" alt="alt text"></li>
</ol>
<h2 id="场景2：使用属性点增加属性（带数据传递）"><a href="#场景2：使用属性点增加属性（带数据传递）" class="headerlink" title="场景2：使用属性点增加属性（带数据传递）"></a>场景2：使用属性点增加属性（带数据传递）</h2><p>需求是“消耗1个属性点，提升指定属性数值”，需实现<strong>带数据的事件发送</strong>与<strong>持续监听的事件接收</strong>，核心分为发送、接收两步：</p>
<h3 id="步骤1：发送-GameplayEvent（带Payload数据）"><a href="#步骤1：发送-GameplayEvent（带Payload数据）" class="headerlink" title="步骤1：发送 GameplayEvent（带Payload数据）"></a>步骤1：发送 GameplayEvent（带Payload数据）</h3><p>与无数据传递的场景不同，需将“提升的属性标签”“提升数值”封装到 <code>FGameplayEventData</code>（Payload）中，再发送事件：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UCustomAbilitySystemComponent::ServerUpgradeAttribute_Implementation</span><span class="params">(<span class="type">const</span> FGameplayTag&amp; AttributeTag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	FGameplayEventData Payload;</span><br><span class="line">	Payload.EventTag = AttributeTag;</span><br><span class="line">	Payload.EventMagnitude = <span class="number">1.f</span>;</span><br><span class="line"></span><br><span class="line">	UAbilitySystemBlueprintLibrary::<span class="built_in">SendGameplayEventToActor</span>(<span class="built_in">GetAvatarActor</span>() , AttributeTag , Payload);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">GetAvatarActor</span>()-&gt;<span class="built_in">Implements</span>&lt;UPlayerInterface&gt;())</span><br><span class="line">	&#123;</span><br><span class="line">		IPlayerInterface::<span class="built_in">Execute_AddToAttributePoints</span>(<span class="built_in">GetAvatarActor</span>() , <span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="步骤2：接收-GameplayEvent（持续监听）"><a href="#步骤2：接收-GameplayEvent（持续监听）" class="headerlink" title="步骤2：接收 GameplayEvent（持续监听）"></a>步骤2：接收 GameplayEvent（持续监听）</h3><p>GameplayEvent 的接收端固定为 GA，需为玩家角色配置一个全程激活的 GA（如 GA_ListenForEvent），核心逻辑：</p>
<ol>
<li>持续通过 <code>WaitGameplayEvent</code> 监听属性提升相关事件，捕获“待修改属性标签”“提升数值”；</li>
<li>基于通用 GE 模板类（GE_ListenForEvent）制作 GE 实例，修改目标属性数值。</li>
</ol>
<h4 id="GE-模板类（GE-ListenForEvent）设计"><a href="#GE-模板类（GE-ListenForEvent）设计" class="headerlink" title="GE 模板类（GE_ListenForEvent）设计"></a>GE 模板类（GE_ListenForEvent）设计</h4><p>为减少 GE 资源开销，仅创建一个通用 GE 模板类，包含所有可提升属性的 Modifier，通过 Set By Caller 传递数值：</p>
<ul>
<li>为每个可修改属性创建对应的 Modifier；</li>
<li>无需修改的属性传入 0 值，仅对目标属性传入有效数值。</li>
</ul>
<h4 id="设计说明"><a href="#设计说明" class="headerlink" title="设计说明"></a>设计说明</h4><p>优先在单个 GE 中包含多属性 Modifier，而非创建多个专用 GE：</p>
<ul>
<li>优势：GE 是包含 Context 的重量级资源，单个通用 GE 可大幅减少资源开销（本场景中 Context 无实际作用）；</li>
<li>劣势：每次构建 GE 需遍历所有 Modifier 并填充 Set By Caller 数值，但因可修改属性数量有限，性能损耗可忽略。</li>
</ul>
]]></content>
      <categories>
        <category>SystemDesigns</category>
        <category>GAS</category>
      </categories>
      <tags>
        <tag>GAS</tag>
        <tag>GameplayEvent</tag>
      </tags>
  </entry>
  <entry>
    <title>GameplayTag</title>
    <url>/ue5-blog/2025/12/14/SystemDesigns/GAS/GameplayTag/</url>
    <content><![CDATA[<h1 id="核心总结"><a href="#核心总结" class="headerlink" title="核心总结"></a>核心总结</h1><p>GameplayTag 是 GAS 框架的核心全局标识工具，通过轻量化的标签体系实现“数值映射、信息传递、资产区分、状态&#x2F;类型标记”等核心功能，其核心价值在于全局共识性——当对象间需基于统一标识完成交互时，GameplayTag 是最优选择。</p>
<span id="more"></span>

<h1 id="Tag-的作用"><a href="#Tag-的作用" class="headerlink" title="Tag 的作用"></a>Tag 的作用</h1><p>GAS 框架中 GameplayTag 应用场景灵活且广泛，核心作用可归纳为：</p>
<ol>
<li>数值映射标识：作为变量名标记需修改的属性，如 Set By Caller 机制通过 Tag 关联待修改的属性数值；</li>
<li>信息传递验证：如 Anim Notify 中通过 GameplayEvent 传递 Tag，标识动画蒙太奇（Montage）的特定播放阶段；</li>
<li>资产索引区分：为同类资产（如技能动画）打 Tag，通过 Tag 快速索引目标资产；</li>
<li>状态标记：标记技能&#x2F;角色的状态（如技能锁定、装备中），用于状态校验与逻辑分支判断；</li>
<li>类型标识：区分不同类别（如主动&#x2F;被动技能、火攻&#x2F;雷攻伤害类型），替代枚举实现更灵活的类型管理。</li>
</ol>
<p>GameplayTag 的核心优势是全局通用性，只要两个对象需基于“全局共识的标识”完成交互，即可优先使用 Tag。</p>
<h1 id="Tag-的创建"><a href="#Tag-的创建" class="headerlink" title="Tag 的创建"></a>Tag 的创建</h1><h2 id="蓝图创建"><a href="#蓝图创建" class="headerlink" title="蓝图创建"></a>蓝图创建</h2><p>进入「Project Settings → GameplayTag」可可视化管理蓝图层面的 Tag：</p>
<ul>
<li>操作便捷，适合快速定义蓝图专属 Tag；</li>
<li>局限性：仅能在蓝图中使用，C++ 代码无法访问。</li>
</ul>
<h2 id="C-端-Native-Tag"><a href="#C-端-Native-Tag" class="headerlink" title="C++ 端 Native Tag"></a>C++ 端 Native Tag</h2><p>通过单例模式注册 Native Tag（单例实现详见<a href="/ue5-blog/2025/12/10/ProgrammingSkills/Singleton">这里</a>），需将 Tag 注册到自定义 AssetManager 并配置生效：</p>
<h3 id="1-自定义-AssetManager-注册-Tag"><a href="#1-自定义-AssetManager-注册-Tag" class="headerlink" title="1. 自定义 AssetManager 注册 Tag"></a>1. 自定义 AssetManager 注册 Tag</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GAS_Custom_API</span> UCustomAssetManager : <span class="keyword">public</span> UAssetManager</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">static</span> UCustomAssetManager&amp; <span class="title">Get</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">StartInitialLoading</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">UCustomAssetManager&amp; <span class="title">UCustomAssetManager::Get</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">check</span>(GEngine);</span><br><span class="line"></span><br><span class="line">	UCustomAssetManager* CustomAssetManager = <span class="built_in">Cast</span>&lt;UCustomAssetManager&gt;(GEngine-&gt;AssetManager);</span><br><span class="line">	<span class="keyword">return</span> * CustomAssetManager;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UCustomAssetManager::StartInitialLoading</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Super::<span class="built_in">StartInitialLoading</span>();</span><br><span class="line"></span><br><span class="line">	FCustomGameplayTags::<span class="built_in">InitializeNativeGameplayTags</span>();</span><br><span class="line">	<span class="comment">// 初始化 GAS 全局数据</span></span><br><span class="line">	UAbilitySystemGlobals::<span class="built_in">Get</span>().<span class="built_in">InitGlobalData</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-修改项目配置文件"><a href="#2-修改项目配置文件" class="headerlink" title="2. 修改项目配置文件"></a>2. 修改项目配置文件</h3><p>打开「Config&#x2F;DefaultEngine.ini」，找到「[&#x2F;Script&#x2F;Engine.Engine]」节点，添加如下配置指定自定义 AssetManager：<br>AssetManagerClassName&#x3D;&#x2F;Script&#x2F;ProjectName.CustomAssetManager</p>
]]></content>
      <categories>
        <category>SystemDesigns</category>
        <category>GAS</category>
      </categories>
      <tags>
        <tag>GAS</tag>
        <tag>GameplayTag</tag>
      </tags>
  </entry>
  <entry>
    <title>EnhancedInput</title>
    <url>/ue5-blog/2025/12/08/SystemDesigns/Input/EnhancedInput/</url>
    <content><![CDATA[<h1 id="核心总结"><a href="#核心总结" class="headerlink" title="核心总结"></a>核心总结</h1><span id="more"></span>]]></content>
      <categories>
        <category>SystemDesigns</category>
        <category>Input</category>
      </categories>
      <tags>
        <tag>EnhancedInput</tag>
      </tags>
  </entry>
  <entry>
    <title>数据驱动系统 (DataDriven)</title>
    <url>/ue5-blog/2025/12/08/SystemDesigns/DataDriven/Data/</url>
    <content><![CDATA[<h1 id="核心总结"><a href="#核心总结" class="headerlink" title="核心总结"></a>核心总结</h1><span id="more"></span>]]></content>
      <categories>
        <category>SystemDesigns</category>
        <category>DataDriven</category>
      </categories>
      <tags>
        <tag>DataAsset</tag>
        <tag>DataTable</tag>
      </tags>
  </entry>
  <entry>
    <title>Highlight</title>
    <url>/ue5-blog/2025/12/08/SystemDesigns/Input/Highlight/</url>
    <content><![CDATA[<h1 id="核心总结"><a href="#核心总结" class="headerlink" title="核心总结"></a>核心总结</h1><span id="more"></span>]]></content>
      <categories>
        <category>SystemDesigns</category>
        <category>Input</category>
      </categories>
      <tags>
        <tag>Highlight</tag>
      </tags>
  </entry>
  <entry>
    <title>Model View Controller (MVC)</title>
    <url>/ue5-blog/2025/12/08/SystemDesigns/UI/MVC/</url>
    <content><![CDATA[<h1 id="核心总结"><a href="#核心总结" class="headerlink" title="核心总结"></a>核心总结</h1><span id="more"></span>]]></content>
      <categories>
        <category>SystemDesigns</category>
        <category>UI</category>
      </categories>
      <tags>
        <tag>MVC</tag>
        <tag>Widget</tag>
        <tag>WidgetController</tag>
      </tags>
  </entry>
  <entry>
    <title>AttributeSet (AS)</title>
    <url>/ue5-blog//2025/12/12/GAS-AS/</url>
    <content><![CDATA[<h1 id="核心总结"><a href="#核心总结" class="headerlink" title="核心总结"></a>核心总结</h1><p>AttributeSet（AS）是GAS框架中统一管理角色属性的核心类，承担“属性存储+属性变化处理”两大核心职责：按属性特性划分存储策略（通用属性存AS、玩家特有属性存PlayerState），通过“普通属性+元属性”分层处理简单&#x2F;复杂属性修改逻辑，最终依托重写核心函数完成属性变化的标准化处理。</p>
<span id="more"></span>

<h1 id="定义属性"><a href="#定义属性" class="headerlink" title="定义属性"></a>定义属性</h1><h2 id="核心说明"><a href="#核心说明" class="headerlink" title="核心说明"></a>核心说明</h2><p>AS的属性存储与生命周期按角色类型和属性用途区分：</p>
<ol>
<li><strong>通用属性</strong>（血量、蓝量、力量等）：存放于AS中，适配所有角色（玩家&#x2F;敌人）；</li>
<li><strong>玩家特有属性</strong>（XP、属性点、技能点等）：存放于PlayerState（PS）中（敌人无此类属性）；</li>
<li><strong>AS挂载策略</strong>：<ul>
<li>玩家AS：挂载在PS中，死亡后可继承属性（满足存档&#x2F;持久化需求）；</li>
<li>敌人AS：挂载在角色类中，随角色创建实例化、销毁后自动释放。</li>
</ul>
</li>
</ol>
<h2 id="普通属性"><a href="#普通属性" class="headerlink" title="普通属性"></a>普通属性</h2><p>普通属性是角色长期持有的核心属性（如血量、力量），需网络复制保证多端数据一致，定义流程如下：</p>
<h3 id="1-封装属性访问器"><a href="#1-封装属性访问器" class="headerlink" title="1. 封装属性访问器"></a>1. 封装属性访问器</h3><p>通过自定义宏快速生成属性的Getter&#x2F;Setter&#x2F;Initter，避免重复编写访问逻辑：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ATTRIBUTE_ACCESSORS(ClassName, PropertyName) \</span></span><br><span class="line"><span class="meta">	GAMEPLAYATTRIBUTE_PROPERTY_GETTER(ClassName, PropertyName) \</span></span><br><span class="line"><span class="meta">	GAMEPLAYATTRIBUTE_VALUE_GETTER(PropertyName) \</span></span><br><span class="line"><span class="meta">	GAMEPLAYATTRIBUTE_VALUE_SETTER(PropertyName) \</span></span><br><span class="line"><span class="meta">	GAMEPLAYATTRIBUTE_VALUE_INITTER(PropertyName)</span></span><br></pre></td></tr></table></figure>

<h3 id="2-定义Tag-属性映射模板"><a href="#2-定义Tag-属性映射模板" class="headerlink" title="2. 定义Tag-属性映射模板"></a>2. 定义Tag-属性映射模板</h3><p>模板用于构建GameplayTag与属性的映射表，每个AS实例持有该映射，支持通过Tag快速定位属性：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">template&lt;class T&gt;</span><br><span class="line">using TStaticFuncPtr = TBaseStaticDelegateInstance&lt;T , FDefaultDelegateUserPolicy&gt;::FFuncPtr;</span><br></pre></td></tr></table></figure>

<h3 id="3-AS类核心定义（含网络复制）"><a href="#3-AS类核心定义（含网络复制）" class="headerlink" title="3. AS类核心定义（含网络复制）"></a>3. AS类核心定义（含网络复制）</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GAS_Custom_API</span> UCustomAttributeSet : <span class="keyword">public</span> UAttributeSet</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">GENERATED_BODY</span>()</span><br><span class="line">	</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 构造函数：初始化Tag与属性的映射关系</span></span><br><span class="line">	<span class="built_in">UCustomAttributeSet</span>();</span><br><span class="line">	<span class="comment">// Tag-属性映射表：通过Tag快速获取属性，避免硬编码</span></span><br><span class="line">	TMap&lt;FGameplayTag , TStaticFuncPtr&lt;<span class="built_in">FGameplayAttribute</span>()&gt;&gt; TagToAttribute;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写：注册需网络复制的属性</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">GetLifetimeReplicatedProps</span><span class="params">(TArray&lt;<span class="keyword">class</span> FLifetimeProperty&gt;&amp; OutLifetimeProps)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生命值属性：GAS标准数据类型，指定同步回调</span></span><br><span class="line">    <span class="built_in">UPROPERTY</span>(BlueprintReadOnly , ReplicatedUsing = OnRep_Health , Category = <span class="string">&quot;Vital Attributes&quot;</span>)</span><br><span class="line">	FGameplayAttributeData Health;</span><br><span class="line">	<span class="comment">// 生命值同步回调：Server属性变化后触发Client逻辑</span></span><br><span class="line">	<span class="built_in">UFUNCTION</span>()</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">OnRep_Health</span><span class="params">(<span class="type">const</span> FGameplayAttributeData&amp; OldHealth)</span> <span class="type">const</span></span>;</span><br><span class="line">	<span class="comment">// 生成生命值访问器（复用自定义宏）</span></span><br><span class="line">	<span class="built_in">ATTRIBUTE_ACCESSORS</span>(UCustomAttributeSet , Health);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数：绑定Tag与属性的映射</span></span><br><span class="line">UCustomAttributeSet::<span class="built_in">UCustomAttributeSet</span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">const</span> FCustomGameplayTags&amp; GameplayTags = FCustomGameplayTags::<span class="built_in">Get</span>();</span><br><span class="line">	TagToAttribute.<span class="built_in">Add</span>(GameplayTags.Attributes_Primary_Health , GetHealthAttribute);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册网络复制规则</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UCustomAttributeSet::GetLifetimeReplicatedProps</span><span class="params">(TArray&lt;<span class="keyword">class</span> FLifetimeProperty&gt;&amp; OutLifetimeProps)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Super::<span class="built_in">GetLifetimeReplicatedProps</span>(OutLifetimeProps);</span><br><span class="line">	<span class="comment">// COND_None：属性变化即同步；REPNOTIFY_Always：同步必触发回调</span></span><br><span class="line">	<span class="built_in">DOREPLIFETIME_CONDITION_NOTIFY</span>(UCustomAttributeSet , Health , COND_None , REPNOTIFY_Always);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 属性同步回调：处理Client端属性变化逻辑</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UCustomAttributeSet::OnRep_Health</span><span class="params">(<span class="type">const</span> FGameplayAttributeData&amp; OldHealth)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// GAS内置宏：触发属性变化全局回调（如UI更新、死亡判定）</span></span><br><span class="line">	<span class="built_in">GAMEPLAYATTRIBUTE_REPNOTIFY</span>(UCustomAttributeSet , Health , OldHealth);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="元属性（Meta-Attribute）"><a href="#元属性（Meta-Attribute）" class="headerlink" title="元属性（Meta Attribute）"></a>元属性（Meta Attribute）</h2><p>元属性是临时属性，仅用于复杂属性变化的过渡计算，无需网络复制（仅Server端处理）：</p>
<h3 id="1-元属性的必要性"><a href="#1-元属性的必要性" class="headerlink" title="1. 元属性的必要性"></a>1. 元属性的必要性</h3><p>GE对属性的作用常包含复杂逻辑（如伤害附带击退、Debuff），无法直接修改普通属性完成。通过元属性（如IncomingDamage）作为“过渡载体”：</p>
<ul>
<li>GE先计算最终效果值，修改元属性；</li>
<li>AS监听元属性变化，完成最终属性修改+附加效果（击退、Debuff）。</li>
</ul>
<h3 id="2-元属性定义方式"><a href="#2-元属性定义方式" class="headerlink" title="2. 元属性定义方式"></a>2. 元属性定义方式</h3><p>仅需声明属性（无网络复制），复用访问器宏即可：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UPROPERTY</span>(BlueprintReadOnly , Category = <span class="string">&quot;Meta Attributes&quot;</span>)</span><br><span class="line">FGameplayAttributeData IncomingDamage;</span><br><span class="line"><span class="built_in">ATTRIBUTE_ACCESSORS</span>(UCustomAttributeSet , IncomingDamage);</span><br></pre></td></tr></table></figure>

<h1 id="处理属性变化"><a href="#处理属性变化" class="headerlink" title="处理属性变化"></a>处理属性变化</h1><h2 id="基本方法"><a href="#基本方法" class="headerlink" title="基本方法"></a>基本方法</h2><p>核心是重写<code>PostGameplayEffectExecute</code>函数，按属性类型处理修改逻辑：简单属性仅做合法性校验，复杂属性调用自定义处理函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UCustomAttributeSet::PostGameplayEffectExecute</span><span class="params">(<span class="type">const</span> FGameplayEffectModCallbackData&amp; Data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Super::<span class="built_in">PostGameplayEffectExecute</span>(Data);</span><br><span class="line"></span><br><span class="line">	FEffectProperties Props;</span><br><span class="line">	<span class="built_in">SetEffectProperties</span>(Data , Props);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 角色已死亡则跳过属性处理</span></span><br><span class="line">	<span class="keyword">if</span> (Props.TargetCharacter-&gt;<span class="built_in">Implements</span>&lt;UCombatInterface&gt;() &amp;&amp; ICombatInterface::<span class="built_in">Execute_IsDead</span>(Props.TargetCharacter)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 简单属性：法力值范围校验</span></span><br><span class="line">	<span class="keyword">if</span> (Data.EvaluatedData.Attribute == <span class="built_in">GetManaAttribute</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">SetMana</span>(FMath::<span class="built_in">Clamp</span>(<span class="built_in">GetMana</span>() , <span class="number">0.f</span> , <span class="built_in">GetMaxMana</span>()));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 复杂属性：调用自定义伤害处理逻辑</span></span><br><span class="line">	<span class="keyword">if</span> (Data.EvaluatedData.Attribute == <span class="built_in">GetIncomingDamageAttribute</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">HandleIncomingDamage</span>(Props);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="属性变化后处理"><a href="#属性变化后处理" class="headerlink" title="属性变化后处理"></a>属性变化后处理</h3><p>重写<code>PostAttributeChange</code>可在属性最终修改后执行附加逻辑，例：满血状态下最大血量提升时自动补满当前血量（否则UI上看起来血量反而下降）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UCustomAttributeSet::PostAttributeChange</span><span class="params">(<span class="type">const</span> FGameplayAttribute&amp; Attribute, <span class="type">float</span> OldValue, <span class="type">float</span> NewValue)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Super::<span class="built_in">PostAttributeChange</span>(Attribute, OldValue, NewValue);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (Attribute == <span class="built_in">GetMaxHealthAttribute</span>() &amp;&amp; bTopOffHealth)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">SetHealth</span>(<span class="built_in">GetMaxHealth</span>());</span><br><span class="line">		bTopOffHealth = <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="自定义数据结构"><a href="#自定义数据结构" class="headerlink" title="自定义数据结构"></a>自定义数据结构</h2><p>从GE回调数据中提取核心信息封装为结构体，便于复用和代码整洁：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">USTRUCT</span>()</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">FEffectProperties</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line">	<span class="built_in">FEffectProperties</span>()&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// GE上下文句柄：存储施法者、目标、伤害类型等信息</span></span><br><span class="line">	FGameplayEffectContextHandle EffectContextHandle;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 源端（施法者）数据</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>()</span><br><span class="line">	UAbilitySystemComponent* SourceASC = <span class="literal">nullptr</span>;</span><br><span class="line">	<span class="built_in">UPROPERTY</span>()</span><br><span class="line">	AActor* SourceAvatarActor = <span class="literal">nullptr</span>;</span><br><span class="line">	<span class="built_in">UPROPERTY</span>()</span><br><span class="line">	AController* SourceController =	<span class="literal">nullptr</span>;</span><br><span class="line">	<span class="built_in">UPROPERTY</span>()</span><br><span class="line">	ACharacter* SourceCharacter = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 目标端（受击者）数据</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>()</span><br><span class="line">	UAbilitySystemComponent* TargetASC = <span class="literal">nullptr</span>;</span><br><span class="line">	<span class="built_in">UPROPERTY</span>()</span><br><span class="line">	AActor* TargetAvatarActor = <span class="literal">nullptr</span>;</span><br><span class="line">	<span class="built_in">UPROPERTY</span>()</span><br><span class="line">	AController* TargetController =	<span class="literal">nullptr</span>;</span><br><span class="line">	<span class="built_in">UPROPERTY</span>()</span><br><span class="line">	ACharacter* TargetCharacter = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 填充结构体数据：从GE回调中提取源/目标信息</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UCustomAttributeSet::SetEffectProperties</span><span class="params">(<span class="type">const</span> FGameplayEffectModCallbackData&amp; Data, FEffectProperties&amp; Props)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Props.EffectContextHandle = Data.EffectSpec.<span class="built_in">GetContext</span>();</span><br><span class="line">	Props.SourceASC = Props.EffectContextHandle.<span class="built_in">GetOriginalInstigatorAbilitySystemComponent</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 填充源端数据</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">IsValid</span>(Props.SourceASC) &amp;&amp; Props.SourceASC-&gt;AbilityActorInfo.<span class="built_in">IsValid</span>() &amp;&amp; Props.SourceASC-&gt;AbilityActorInfo-&gt;AvatarActor.<span class="built_in">IsValid</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		Props.SourceAvatarActor = Props.SourceASC-&gt;AbilityActorInfo-&gt;AvatarActor.<span class="built_in">Get</span>();</span><br><span class="line">		Props.SourceController = Props.SourceASC-&gt;AbilityActorInfo-&gt;PlayerController.<span class="built_in">Get</span>();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (Props.SourceController == <span class="literal">nullptr</span> &amp;&amp; Props.SourceAvatarActor != <span class="literal">nullptr</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (APawn* Pawn = <span class="built_in">Cast</span>&lt;APawn&gt;(Props.SourceAvatarActor))</span><br><span class="line">			&#123;</span><br><span class="line">				Props.SourceController = Pawn-&gt;<span class="built_in">GetController</span>();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (Props.SourceController)</span><br><span class="line">		&#123;</span><br><span class="line">			Props.SourceCharacter = <span class="built_in">Cast</span>&lt;ACharacter&gt;(Props.SourceController-&gt;<span class="built_in">GetPawn</span>());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 填充目标端数据</span></span><br><span class="line">	<span class="keyword">if</span> (Data.Target.AbilityActorInfo.<span class="built_in">IsValid</span>() &amp;&amp; Data.Target.AbilityActorInfo-&gt;AvatarActor.<span class="built_in">IsValid</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		Props.TargetAvatarActor = Data.Target.AbilityActorInfo-&gt;AvatarActor.<span class="built_in">Get</span>();</span><br><span class="line">		Props.TargetController = Data.Target.AbilityActorInfo-&gt;PlayerController.<span class="built_in">Get</span>();</span><br><span class="line">		Props.TargetCharacter = <span class="built_in">Cast</span>&lt;ACharacter&gt;(Props.TargetAvatarActor);</span><br><span class="line">		Props.TargetASC = UAbilitySystemBlueprintLibrary::<span class="built_in">GetAbilitySystemComponent</span>(Props.TargetAvatarActor);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="解耦操作"><a href="#解耦操作" class="headerlink" title="解耦操作"></a>解耦操作</h2><p>AS仅负责属性变化的分发，具体业务逻辑（如伤害、击退）解耦到FunctionLibrary中，保证AS职责单一：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UCustomAttributeSet::HandleIncomingDamage</span><span class="params">(<span class="type">const</span> FEffectProperties&amp; Props)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">const</span> <span class="type">float</span> LocalIncomingDamage = <span class="built_in">GetIncomingDamage</span>();</span><br><span class="line">	<span class="built_in">SetIncomingDamage</span>(<span class="number">0.f</span>); <span class="comment">// 重置元属性</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (LocalIncomingDamage &gt; <span class="number">0.f</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 1. 计算最终血量并校验范围</span></span><br><span class="line">		<span class="type">const</span> <span class="type">float</span> NewHealth = <span class="built_in">GetHealth</span>() - LocalIncomingDamage;</span><br><span class="line">		<span class="built_in">SetHealth</span>(FMath::<span class="built_in">Clamp</span>(NewHealth , <span class="number">0.f</span> , <span class="built_in">GetMaxHealth</span>()));</span><br><span class="line"></span><br><span class="line">		<span class="type">const</span> <span class="type">bool</span> bFatal = (NewHealth &lt;= <span class="number">0.f</span>);</span><br><span class="line">		<span class="keyword">if</span> (!bFatal)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// 2. 非致命伤害：触发受击反应（GA）</span></span><br><span class="line">			<span class="keyword">if</span> (Props.TargetCharacter-&gt;<span class="built_in">Implements</span>&lt;UCombatInterface&gt;() &amp;&amp; !ICombatInterface::<span class="built_in">Execute_IsBeingShocked</span>(Props.TargetCharacter))</span><br><span class="line">			&#123;</span><br><span class="line">				FGameplayTagContainer TagContainer;</span><br><span class="line">				TagContainer.<span class="built_in">AddTag</span>(FCustomGameplayTags::<span class="built_in">Get</span>().Effects_HitReact);</span><br><span class="line">				Props.TargetASC-&gt;<span class="built_in">TryActivateAbilitiesByTag</span>(TagContainer);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 3. 触发击退效果</span></span><br><span class="line">			<span class="type">const</span> FVector KnockbackForce = UCustomAbilitySystemLibrary::<span class="built_in">GetKnockbackForce</span>(Props.EffectContextHandle);</span><br><span class="line">			<span class="keyword">if</span> (!KnockbackForce.<span class="built_in">IsNearlyZero</span>(<span class="number">1.f</span>))</span><br><span class="line">			&#123;</span><br><span class="line">				Props.TargetCharacter-&gt;<span class="built_in">LaunchCharacter</span>(KnockbackForce , <span class="literal">true</span> , <span class="literal">true</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// 4. 致命伤害：触发死亡逻辑</span></span><br><span class="line">			ICombatInterface* CombatInterface = <span class="built_in">Cast</span>&lt;ICombatInterface&gt;(Props.TargetAvatarActor);</span><br><span class="line">			<span class="keyword">if</span> (CombatInterface)</span><br><span class="line">			&#123;</span><br><span class="line">				CombatInterface-&gt;<span class="built_in">Die</span>(UCustomAbilitySystemLibrary::<span class="built_in">GetDeathImpulse</span>(Props.EffectContextHandle));</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 5. 击杀奖励：发放经验</span></span><br><span class="line">			<span class="built_in">SendXPEvent</span>(Props);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 6. 显示伤害飘字（区分格挡/暴击）</span></span><br><span class="line">		<span class="type">const</span> <span class="type">bool</span> bBlockedHit = UCustomAbilitySystemLibrary::<span class="built_in">IsBlockedHit</span>(Props.EffectContextHandle);</span><br><span class="line">		<span class="type">const</span> <span class="type">bool</span> bCriticalHit = UCustomAbilitySystemLibrary::<span class="built_in">IsCriticalHit</span>(Props.EffectContextHandle);</span><br><span class="line">		<span class="built_in">ShowFloatingText</span>(Props , LocalIncomingDamage , bBlockedHit , bCriticalHit);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 7. 触发Debuff效果</span></span><br><span class="line">		<span class="keyword">if</span> (UCustomAbilitySystemLibrary::<span class="built_in">IsSuccessfulDebuff</span>(Props.EffectContextHandle))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">HandleDebuff</span>(Props);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注：HandleDebuff需结合自定义GE实现，详情见<a href="/ue5-blog/2025/12/12/GAS-GE">此处</a>。</p>
]]></content>
      <categories>
        <category>SystemDesigns</category>
        <category>GAS</category>
      </categories>
      <tags>
        <tag>GAS</tag>
        <tag>AS</tag>
      </tags>
  </entry>
  <entry>
    <title>Head Up Display (HUD)</title>
    <url>/ue5-blog/2025/12/08/SystemDesigns/UI/HUD/</url>
    <content><![CDATA[<h1 id="核心总结"><a href="#核心总结" class="headerlink" title="核心总结"></a>核心总结</h1><span id="more"></span>]]></content>
      <categories>
        <category>SystemDesigns</category>
        <category>UI</category>
      </categories>
      <tags>
        <tag>HUD</tag>
      </tags>
  </entry>
  <entry>
    <title>Model View ViewModel (MVVM)</title>
    <url>/ue5-blog/2025/12/08/SystemDesigns/UI/MVVM/</url>
    <content><![CDATA[<h1 id="核心总结"><a href="#核心总结" class="headerlink" title="核心总结"></a>核心总结</h1><span id="more"></span>]]></content>
      <categories>
        <category>SystemDesigns</category>
        <category>UI</category>
      </categories>
      <tags>
        <tag>MVVM</tag>
        <tag>FieldNotify</tag>
      </tags>
  </entry>
  <entry>
    <title>Load</title>
    <url>/ue5-blog/2025/12/08/SystemDesigns/SaveAndLoad/Load/</url>
    <content><![CDATA[<h1 id="核心总结"><a href="#核心总结" class="headerlink" title="核心总结"></a>核心总结</h1><span id="more"></span>]]></content>
      <categories>
        <category>SystemDesigns</category>
        <category>SaveAndLoad</category>
      </categories>
      <tags>
        <tag>Load</tag>
      </tags>
  </entry>
  <entry>
    <title>GameMode</title>
    <url>/ue5-blog/2025/12/08/SystemDesigns/SaveAndLoad/GameMode/</url>
    <content><![CDATA[<h1 id="核心总结"><a href="#核心总结" class="headerlink" title="核心总结"></a>核心总结</h1><span id="more"></span>]]></content>
      <categories>
        <category>SystemDesigns</category>
        <category>SaveAndLoad</category>
      </categories>
      <tags>
        <tag>GameMode</tag>
      </tags>
  </entry>
  <entry>
    <title>GameInstace (GI)</title>
    <url>/ue5-blog/2025/12/08/SystemDesigns/SaveAndLoad/GameInstance/</url>
    <content><![CDATA[<h1 id="核心总结"><a href="#核心总结" class="headerlink" title="核心总结"></a>核心总结</h1><span id="more"></span>]]></content>
      <categories>
        <category>SystemDesigns</category>
        <category>SaveAndLoad</category>
      </categories>
      <tags>
        <tag>GI</tag>
      </tags>
  </entry>
  <entry>
    <title>WorldTransition</title>
    <url>/ue5-blog/2025/12/08/SystemDesigns/Levels/WorldTransition/</url>
    <content><![CDATA[<h1 id="核心总结"><a href="#核心总结" class="headerlink" title="核心总结"></a>核心总结</h1><span id="more"></span>]]></content>
      <categories>
        <category>SystemDesigns</category>
        <category>Levels</category>
      </categories>
      <tags>
        <tag>WorldTransition</tag>
      </tags>
  </entry>
  <entry>
    <title>Save</title>
    <url>/ue5-blog/2025/12/08/SystemDesigns/SaveAndLoad/Save/</url>
    <content><![CDATA[<h1 id="核心总结"><a href="#核心总结" class="headerlink" title="核心总结"></a>核心总结</h1><span id="more"></span>]]></content>
      <categories>
        <category>SystemDesigns</category>
        <category>SaveAndLoad</category>
      </categories>
      <tags>
        <tag>Save</tag>
      </tags>
  </entry>
  <entry>
    <title>SpawnVolume and SpawnPoint</title>
    <url>/ue5-blog/2025/12/08/SystemDesigns/Levels/SpawnVolume/</url>
    <content><![CDATA[<h1 id="核心总结"><a href="#核心总结" class="headerlink" title="核心总结"></a>核心总结</h1><span id="more"></span>]]></content>
      <categories>
        <category>SystemDesigns</category>
        <category>Levels</category>
      </categories>
      <tags>
        <tag>SpawnVolume</tag>
        <tag>SpawnPoint</tag>
      </tags>
  </entry>
</search>
